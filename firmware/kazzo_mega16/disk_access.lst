   1               		.file	"disk_access.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	disk_status_get
  12               	disk_status_get:
  13               	.LVL0:
  14               	.LFB7:
  15               		.file 1 "disk_access.c"
   1:disk_access.c **** #include <avr/interrupt.h>
   2:disk_access.c **** #include <util/delay.h>
   3:disk_access.c **** #include "bus_access.h"
   4:disk_access.c **** #include "disk_access.h"
   5:disk_access.c **** 
   6:disk_access.c **** uint16_t disk_status_get(uint8_t *data)
   7:disk_access.c **** {
  16               		.loc 1 7 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               		.loc 1 7 1 is_stmt 0 view .LVU1
  23 0000 AC01      		movw r20,r24
   8:disk_access.c **** 	const uint16_t length = 2;
  24               		.loc 1 8 2 is_stmt 1 view .LVU2
  25               	.LVL1:
   9:disk_access.c **** 	cpu_read(0x4030, length, data);
  26               		.loc 1 9 2 view .LVU3
  27 0002 62E0      		ldi r22,lo8(2)
  28 0004 70E0      		ldi r23,0
  29 0006 80E3      		ldi r24,lo8(48)
  30 0008 90E4      		ldi r25,lo8(64)
  31               	.LVL2:
  32               		.loc 1 9 2 is_stmt 0 view .LVU4
  33 000a 0E94 0000 		call cpu_read
  34               	.LVL3:
  10:disk_access.c **** 	return length;
  35               		.loc 1 10 2 is_stmt 1 view .LVU5
  11:disk_access.c **** }
  36               		.loc 1 11 1 is_stmt 0 view .LVU6
  37 000e 82E0      		ldi r24,lo8(2)
  38 0010 90E0      		ldi r25,0
  39               	/* epilogue start */
  40 0012 0895      		ret
  41               		.cfi_endproc
  42               	.LFE7:
  44               	.global	disk_init
  46               	disk_init:
  47               	.LVL4:
  48               	.LFB8:
  12:disk_access.c **** static enum sequence{
  13:disk_access.c **** 	IDLE = 0, 
  14:disk_access.c **** 	INIT_MOTOR_STOP, INIT_BATTERY, INIT_MOTOR_START,
  15:disk_access.c **** 	WAIT_READY,
  16:disk_access.c **** 	READ_START, READING, READ_END
  17:disk_access.c **** } sequence = IDLE;
  18:disk_access.c **** 
  19:disk_access.c **** void disk_init(enum DISK_REQUEST r)
  20:disk_access.c **** {
  49               		.loc 1 20 1 is_stmt 1 view -0
  50               		.cfi_startproc
  51               	/* prologue: function */
  52               	/* frame size = 0 */
  53               	/* stack size = 0 */
  54               	.L__stack_usage = 0
  21:disk_access.c **** 	sequence = INIT_MOTOR_STOP;
  55               		.loc 1 21 2 view .LVU8
  56               		.loc 1 21 11 is_stmt 0 view .LVU9
  57 0014 81E0      		ldi r24,lo8(1)
  58               	.LVL5:
  59               		.loc 1 21 11 view .LVU10
  60 0016 8093 0000 		sts sequence,r24
  61               	/* epilogue start */
  22:disk_access.c **** }
  62               		.loc 1 22 1 view .LVU11
  63 001a 0895      		ret
  64               		.cfi_endproc
  65               	.LFE8:
  67               		.section	.rodata.str1.1,"aMS",@progbits,1
  68               	.LC0:
  69 0000 AA55 AA55 		.string	"\252U\252U\252U\252U\252U\252U\252U\252U"
  69      AA55 AA55 
  69      AA55 AA55 
  69      AA55 AA55 
  69      00
  70               		.text
  71               	.global	disk_process
  73               	disk_process:
  74               	.LFB13:
  23:disk_access.c **** 
  24:disk_access.c **** enum disk_control{ //$4025 control bitfield assignment
  25:disk_access.c **** 	MOTOR = 0, //0:stop, 1:work
  26:disk_access.c **** 	TRANSFER_RESET, //1:do reset
  27:disk_access.c **** 	DIRECTION, //0:write, 1:read
  28:disk_access.c **** 	VRAM_MIRRORING,
  29:disk_access.c **** 	BLOCK_END_MARK,
  30:disk_access.c **** 	UNKOWN, //always 1
  31:disk_access.c **** 	ACCESS_START,
  32:disk_access.c **** 	INTERRUPT //0:off, 1:on
  33:disk_access.c **** };
  34:disk_access.c **** static inline uint8_t bit_set(enum disk_control bit)
  35:disk_access.c **** {
  36:disk_access.c **** 	return 1 << bit;
  37:disk_access.c **** };
  38:disk_access.c **** enum{
  39:disk_access.c **** 	BUFFER_ADDRESS = 0x0000,
  40:disk_access.c **** 	DRQ_COUNT = 0x0400,
  41:disk_access.c **** 	DISK_CONTROL = 0x4025
  42:disk_access.c **** };
  43:disk_access.c **** static void data_buffer_init(void)
  44:disk_access.c **** {
  45:disk_access.c **** 	const uint8_t filldata[] = {
  46:disk_access.c **** 		0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 
  47:disk_access.c **** 		0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55
  48:disk_access.c **** 	};
  49:disk_access.c **** 	uint16_t address = BUFFER_ADDRESS;
  50:disk_access.c **** 	while(address < BUFFER_ADDRESS + DRQ_COUNT){
  51:disk_access.c **** 		ppu_write(address, sizeof(filldata), filldata);
  52:disk_access.c **** 		address += sizeof(filldata);
  53:disk_access.c **** 	}
  54:disk_access.c **** }
  55:disk_access.c **** 
  56:disk_access.c **** static inline void motor_stop(void)
  57:disk_access.c **** {
  58:disk_access.c **** 	uint8_t w;
  59:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(TRANSFER_RESET);
  60:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
  61:disk_access.c **** }
  62:disk_access.c **** 
  63:disk_access.c **** static inline void motor_start(void)
  64:disk_access.c **** {
  65:disk_access.c **** 	uint8_t w;
  66:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(TRANSFER_RESET)| bit_set(MOTOR);
  67:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
  68:disk_access.c **** 	clock_wait(9);
  69:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(MOTOR);
  70:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
  71:disk_access.c **** }
  72:disk_access.c **** 
  73:disk_access.c **** volatile static uint16_t drq_count;
  74:disk_access.c **** void disk_process(void)
  75:disk_access.c **** {
  75               		.loc 1 75 1 is_stmt 1 view -0
  76               		.cfi_startproc
  77 001c EF92      		push r14
  78               	.LCFI0:
  79               		.cfi_def_cfa_offset 3
  80               		.cfi_offset 14, -2
  81 001e FF92      		push r15
  82               	.LCFI1:
  83               		.cfi_def_cfa_offset 4
  84               		.cfi_offset 15, -3
  85 0020 0F93      		push r16
  86               	.LCFI2:
  87               		.cfi_def_cfa_offset 5
  88               		.cfi_offset 16, -4
  89 0022 1F93      		push r17
  90               	.LCFI3:
  91               		.cfi_def_cfa_offset 6
  92               		.cfi_offset 17, -5
  93 0024 CF93      		push r28
  94               	.LCFI4:
  95               		.cfi_def_cfa_offset 7
  96               		.cfi_offset 28, -6
  97 0026 DF93      		push r29
  98               	.LCFI5:
  99               		.cfi_def_cfa_offset 8
 100               		.cfi_offset 29, -7
 101 0028 CDB7      		in r28,__SP_L__
 102 002a DEB7      		in r29,__SP_H__
 103               	.LCFI6:
 104               		.cfi_def_cfa_register 28
 105 002c 6497      		sbiw r28,20
 106               	.LCFI7:
 107               		.cfi_def_cfa_offset 28
 108 002e 0FB6      		in __tmp_reg__,__SREG__
 109 0030 F894      		cli
 110 0032 DEBF      		out __SP_H__,r29
 111 0034 0FBE      		out __SREG__,__tmp_reg__
 112 0036 CDBF      		out __SP_L__,r28
 113               	/* prologue: function */
 114               	/* frame size = 20 */
 115               	/* stack size = 26 */
 116               	.L__stack_usage = 26
  76:disk_access.c **** 	const uint16_t status = 0x4032;
 117               		.loc 1 76 2 view .LVU13
 118               	.LVL6:
  77:disk_access.c **** 	switch(sequence){
 119               		.loc 1 77 2 view .LVU14
 120 0038 8091 0000 		lds r24,sequence
 121 003c EFEF      		ldi r30,lo8(-1)
 122 003e E80F      		add r30,r24
 123 0040 E730      		cpi r30,lo8(7)
 124 0042 00F4      		brsh .L22
 125 0044 F0E0      		ldi r31,0
 126 0046 E050      		subi r30,lo8(-(gs(.L7)))
 127 0048 F040      		sbci r31,hi8(-(gs(.L7)))
 128 004a 0C94 0000 		jmp __tablejump2__
 129               		.section	.jumptables.gcc.disk_process,"a",@progbits
 130               		.p2align	1
 131               	.L7:
 132 0000 0000      		.word gs(.L13)
 133 0002 0000      		.word gs(.L12)
 134 0004 0000      		.word gs(.L11)
 135 0006 0000      		.word gs(.L10)
 136 0008 0000      		.word gs(.L9)
 137 000a 0000      		.word gs(.L8)
 138 000c 0000      		.word gs(.L6)
 139               		.text
 140               	.L6:
  78:disk_access.c **** 	default:
  79:disk_access.c **** 	case IDLE:
  80:disk_access.c **** 		break;
  81:disk_access.c **** 	case INIT_MOTOR_STOP:{
  82:disk_access.c **** 		const uint8_t writebuf[] = {0, 0, 0, 0x83};
  83:disk_access.c **** 		//GICR &= ~bit_set(INT1);
  84:disk_access.c **** 		data_buffer_init();
  85:disk_access.c **** 		//timer interrupt off, disk IO on
  86:disk_access.c **** 		cpu_write_6502(0x4020, sizeof(writebuf), writebuf);
  87:disk_access.c **** 		motor_stop();
  88:disk_access.c **** 		_delay_ms(0x200);
  89:disk_access.c **** 		sequence = INIT_BATTERY;
  90:disk_access.c **** 		}break;
  91:disk_access.c **** 	case INIT_BATTERY:{
  92:disk_access.c **** 		motor_start();
  93:disk_access.c **** 		_delay_ms(150);
  94:disk_access.c **** 		uint8_t w = 0xff;
  95:disk_access.c **** 		cpu_write_6502(0x4026, 1, &w);
  96:disk_access.c **** 		sequence = INIT_MOTOR_START;
  97:disk_access.c **** 		}
  98:disk_access.c **** 		break;
  99:disk_access.c **** 	case INIT_MOTOR_START:{
 100:disk_access.c **** 		motor_stop();
 101:disk_access.c **** 		motor_start();
 102:disk_access.c **** 		sequence = WAIT_READY;
 103:disk_access.c **** 		}break;
 104:disk_access.c **** 	case WAIT_READY:{
 105:disk_access.c **** 		uint8_t s;
 106:disk_access.c **** 		cpu_read_6502(status, 1, &s);
 107:disk_access.c **** 		if((s & 0b10) == 0b00){
 108:disk_access.c **** 			sequence = READ_START;
 109:disk_access.c **** 		}
 110:disk_access.c **** 		}break;
 111:disk_access.c **** 	case READ_START:{
 112:disk_access.c **** 		uint8_t w;
 113:disk_access.c **** 		_delay_ms(267 + 5);
 114:disk_access.c **** 		
 115:disk_access.c **** 		w = bit_set(ACCESS_START) | bit_set(UNKOWN) | bit_set(VRAM_MIRRORING) | bit_set(DIRECTION) | bit_
 116:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 117:disk_access.c **** 		clock_wait(21 - 1);
 118:disk_access.c **** 		//DRQ enable
 119:disk_access.c **** 		//MCU INT1 init
 120:disk_access.c **** //		GICR |= bit_set(INT1);
 121:disk_access.c **** 		drq_count = DRQ_COUNT;
 122:disk_access.c **** 		//RP2C33 IRQ enable
 123:disk_access.c **** 		w |= bit_set(INTERRUPT);
 124:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 125:disk_access.c **** 		sequence = READING;
 126:disk_access.c **** 		}break;
 127:disk_access.c **** 	case READING:
 128:disk_access.c **** 		if(drq_count == 0){
 129:disk_access.c **** 			sequence = READ_END;
 130:disk_access.c **** 		}
 131:disk_access.c **** 		break;
 132:disk_access.c **** 	case READ_END:{
 133:disk_access.c **** /*		uint8_t w;
 134:disk_access.c **** 		w = bit_set(ACCESS_START) | bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(MOTOR);
 135:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);*/
 136:disk_access.c **** //		GICR &= ~bit_set(INT1);
 137:disk_access.c **** 		
 138:disk_access.c **** 		sequence = IDLE;
 141               		.loc 1 138 3 view .LVU15
 142               		.loc 1 138 12 is_stmt 0 view .LVU16
 143 004e 1092 0000 		sts sequence,__zero_reg__
 139:disk_access.c **** 		}break;
 144               		.loc 1 139 4 is_stmt 1 view .LVU17
 145               		.loc 1 139 3 is_stmt 0 view .LVU18
 146 0052 80E0      		ldi r24,0
 147               	.L22:
 148 0054 8E01      		movw r16,r28
 149 0056 0F5F      		subi r16,-1
 150 0058 1F4F      		sbci r17,-1
 151               	.L5:
 140:disk_access.c **** 	}
 141:disk_access.c **** 	uint8_t w[2];
 152               		.loc 1 141 2 is_stmt 1 view .LVU19
 142:disk_access.c **** 	w[0] = sequence;
 153               		.loc 1 142 2 view .LVU20
 154               		.loc 1 142 7 is_stmt 0 view .LVU21
 155 005a 8983      		std Y+1,r24
 143:disk_access.c **** 	w[1] = 0x55;
 156               		.loc 1 143 2 is_stmt 1 view .LVU22
 157               		.loc 1 143 7 is_stmt 0 view .LVU23
 158 005c 85E5      		ldi r24,lo8(85)
 159 005e 8A83      		std Y+2,r24
 144:disk_access.c **** 	ppu_write(0x0aaa, 2, w);
 160               		.loc 1 144 2 is_stmt 1 view .LVU24
 161 0060 A801      		movw r20,r16
 162 0062 62E0      		ldi r22,lo8(2)
 163 0064 70E0      		ldi r23,0
 164 0066 8AEA      		ldi r24,lo8(-86)
 165 0068 9AE0      		ldi r25,lo8(10)
 166 006a 0E94 0000 		call ppu_write
 167               	.LVL7:
 145:disk_access.c **** 	phi2_update();
 168               		.loc 1 145 2 view .LVU25
 169 006e 0E94 0000 		call phi2_update
 170               	.LVL8:
 171               	/* epilogue start */
 146:disk_access.c **** }
 172               		.loc 1 146 1 is_stmt 0 view .LVU26
 173 0072 6496      		adiw r28,20
 174 0074 0FB6      		in __tmp_reg__,__SREG__
 175 0076 F894      		cli
 176 0078 DEBF      		out __SP_H__,r29
 177 007a 0FBE      		out __SREG__,__tmp_reg__
 178 007c CDBF      		out __SP_L__,r28
 179 007e DF91      		pop r29
 180 0080 CF91      		pop r28
 181 0082 1F91      		pop r17
 182 0084 0F91      		pop r16
 183 0086 FF90      		pop r15
 184 0088 EF90      		pop r14
 185 008a 0895      		ret
 186               	.L8:
 128:disk_access.c **** 			sequence = READ_END;
 187               		.loc 1 128 3 is_stmt 1 view .LVU27
 128:disk_access.c **** 			sequence = READ_END;
 188               		.loc 1 128 16 is_stmt 0 view .LVU28
 189 008c 2091 0000 		lds r18,drq_count
 190 0090 3091 0000 		lds r19,drq_count+1
 128:disk_access.c **** 			sequence = READ_END;
 191               		.loc 1 128 5 view .LVU29
 192 0094 232B      		or r18,r19
 193 0096 01F4      		brne .L22
 129:disk_access.c **** 		}
 194               		.loc 1 129 4 is_stmt 1 view .LVU30
 129:disk_access.c **** 		}
 195               		.loc 1 129 13 is_stmt 0 view .LVU31
 196 0098 87E0      		ldi r24,lo8(7)
 197 009a 8093 0000 		sts sequence,r24
 198 009e 8E01      		movw r16,r28
 199 00a0 0F5F      		subi r16,-1
 200 00a2 1F4F      		sbci r17,-1
 201 00a4 00C0      		rjmp .L5
 202               	.L13:
 203               	.LBB97:
  82:disk_access.c **** 		//GICR &= ~bit_set(INT1);
 204               		.loc 1 82 3 is_stmt 1 view .LVU32
  82:disk_access.c **** 		//GICR &= ~bit_set(INT1);
 205               		.loc 1 82 17 is_stmt 0 view .LVU33
 206 00a6 1A8A      		std Y+18,__zero_reg__
 207 00a8 198A      		std Y+17,__zero_reg__
 208 00aa 80E0      		ldi r24,0
 209 00ac 93E8      		ldi r25,lo8(-125)
 210 00ae 9C8B      		std Y+20,r25
 211 00b0 8B8B      		std Y+19,r24
  84:disk_access.c **** 		//timer interrupt off, disk IO on
 212               		.loc 1 84 3 is_stmt 1 view .LVU34
 213               	.LBB98:
 214               	.LBI98:
  43:disk_access.c **** {
 215               		.loc 1 43 13 view .LVU35
 216               	.LBB99:
  45:disk_access.c **** 		0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 
 217               		.loc 1 45 2 view .LVU36
  45:disk_access.c **** 		0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 
 218               		.loc 1 45 16 is_stmt 0 view .LVU37
 219 00b2 80E1      		ldi r24,lo8(16)
 220 00b4 E0E0      		ldi r30,lo8(.LC0)
 221 00b6 F0E0      		ldi r31,hi8(.LC0)
 222 00b8 8E01      		movw r16,r28
 223 00ba 0F5F      		subi r16,-1
 224 00bc 1F4F      		sbci r17,-1
 225 00be D801      		movw r26,r16
 226               		0:
 227 00c0 0190      		ld r0,Z+
 228 00c2 0D92      		st X+,r0
 229 00c4 8A95      		dec r24
 230 00c6 01F4      		brne 0b
  49:disk_access.c **** 	while(address < BUFFER_ADDRESS + DRQ_COUNT){
 231               		.loc 1 49 2 is_stmt 1 view .LVU38
 232               	.LVL9:
  50:disk_access.c **** 		ppu_write(address, sizeof(filldata), filldata);
 233               		.loc 1 50 2 view .LVU39
  50:disk_access.c **** 		ppu_write(address, sizeof(filldata), filldata);
 234               		.loc 1 50 7 view .LVU40
  49:disk_access.c **** 	while(address < BUFFER_ADDRESS + DRQ_COUNT){
 235               		.loc 1 49 11 is_stmt 0 view .LVU41
 236 00c8 F12C      		mov r15,__zero_reg__
 237 00ca E12C      		mov r14,__zero_reg__
 238               	.LVL10:
 239               	.L14:
  51:disk_access.c **** 		address += sizeof(filldata);
 240               		.loc 1 51 3 is_stmt 1 view .LVU42
 241 00cc A801      		movw r20,r16
 242 00ce 60E1      		ldi r22,lo8(16)
 243 00d0 70E0      		ldi r23,0
 244 00d2 C701      		movw r24,r14
 245 00d4 0E94 0000 		call ppu_write
 246               	.LVL11:
  52:disk_access.c **** 	}
 247               		.loc 1 52 3 view .LVU43
  52:disk_access.c **** 	}
 248               		.loc 1 52 11 is_stmt 0 view .LVU44
 249 00d8 20E1      		ldi r18,16
 250 00da E20E      		add r14,r18
 251 00dc F11C      		adc r15,__zero_reg__
 252               	.LVL12:
  50:disk_access.c **** 		ppu_write(address, sizeof(filldata), filldata);
 253               		.loc 1 50 7 is_stmt 1 view .LVU45
 254 00de E114      		cp r14,__zero_reg__
 255 00e0 84E0      		ldi r24,4
 256 00e2 F806      		cpc r15,r24
 257 00e4 01F4      		brne .L14
 258               	.LVL13:
  50:disk_access.c **** 		ppu_write(address, sizeof(filldata), filldata);
 259               		.loc 1 50 7 is_stmt 0 view .LVU46
 260               	.LBE99:
 261               	.LBE98:
  86:disk_access.c **** 		motor_stop();
 262               		.loc 1 86 3 is_stmt 1 view .LVU47
 263 00e6 AE01      		movw r20,r28
 264 00e8 4F5E      		subi r20,-17
 265 00ea 5F4F      		sbci r21,-1
 266 00ec 64E0      		ldi r22,lo8(4)
 267 00ee 70E0      		ldi r23,0
 268 00f0 80E2      		ldi r24,lo8(32)
 269 00f2 90E4      		ldi r25,lo8(64)
 270 00f4 0E94 0000 		call cpu_write_6502
 271               	.LVL14:
  87:disk_access.c **** 		_delay_ms(0x200);
 272               		.loc 1 87 3 view .LVU48
 273               	.LBB100:
 274               	.LBI100:
  56:disk_access.c **** {
 275               		.loc 1 56 20 view .LVU49
 276               	.LBB101:
  58:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(TRANSFER_RESET);
 277               		.loc 1 58 2 view .LVU50
  59:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 278               		.loc 1 59 2 view .LVU51
  59:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 279               		.loc 1 59 2 is_stmt 0 view .LVU52
 280               	.LBE101:
 281               	.LBE100:
 282               	.LBE97:
  36:disk_access.c **** };
 283               		.loc 1 36 2 is_stmt 1 view .LVU53
  36:disk_access.c **** };
 284               		.loc 1 36 2 view .LVU54
  36:disk_access.c **** };
 285               		.loc 1 36 2 view .LVU55
 286               	.LBB106:
 287               	.LBB103:
 288               	.LBB102:
  59:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 289               		.loc 1 59 4 is_stmt 0 view .LVU56
 290 00f8 86E2      		ldi r24,lo8(38)
 291 00fa 8983      		std Y+1,r24
  60:disk_access.c **** }
 292               		.loc 1 60 2 is_stmt 1 view .LVU57
 293 00fc A801      		movw r20,r16
 294 00fe 61E0      		ldi r22,lo8(1)
 295 0100 70E0      		ldi r23,0
 296 0102 85E2      		ldi r24,lo8(37)
 297 0104 90E4      		ldi r25,lo8(64)
 298 0106 0E94 0000 		call cpu_write_6502
 299               	.LVL15:
 300               	.LBE102:
 301               	.LBE103:
  88:disk_access.c **** 		sequence = INIT_BATTERY;
 302               		.loc 1 88 3 view .LVU58
 303               	.LBB104:
 304               	.LBI104:
 305               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 306               		.loc 2 166 1 view .LVU59
 307               	.LBB105:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 308               		.loc 2 168 2 view .LVU60
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 309               		.loc 2 172 2 view .LVU61
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 310               		.loc 2 173 2 view .LVU62
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 311               		.loc 2 174 2 view .LVU63
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 312               		.loc 2 184 3 view .LVU64
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 313               		.loc 2 187 2 view .LVU65
 314 010a 9FEF      		ldi r25,lo8(1638399)
 315 010c 2FEF      		ldi r18,hi8(1638399)
 316 010e 88E1      		ldi r24,hlo8(1638399)
 317 0110 9150      	1:	subi r25,1
 318 0112 2040      		sbci r18,0
 319 0114 8040      		sbci r24,0
 320 0116 01F4      		brne 1b
 321 0118 00C0      		rjmp .
 322 011a 0000      		nop
 323               	.LVL16:
 324               		.loc 2 187 2 is_stmt 0 view .LVU66
 325               	.LBE105:
 326               	.LBE104:
  89:disk_access.c **** 		}break;
 327               		.loc 1 89 3 is_stmt 1 view .LVU67
  89:disk_access.c **** 		}break;
 328               		.loc 1 89 12 is_stmt 0 view .LVU68
 329 011c 82E0      		ldi r24,lo8(2)
 330 011e 8093 0000 		sts sequence,r24
 331               	.LBE106:
  90:disk_access.c **** 	case INIT_BATTERY:{
 332               		.loc 1 90 4 is_stmt 1 view .LVU69
  90:disk_access.c **** 	case INIT_BATTERY:{
 333               		.loc 1 90 3 is_stmt 0 view .LVU70
 334 0122 00C0      		rjmp .L5
 335               	.L12:
 336               	.LBB107:
  92:disk_access.c **** 		_delay_ms(150);
 337               		.loc 1 92 3 is_stmt 1 view .LVU71
 338               	.LBB108:
 339               	.LBI108:
  63:disk_access.c **** {
 340               		.loc 1 63 20 view .LVU72
 341               	.LBB109:
  65:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(TRANSFER_RESET)| bit_set(MOTOR);
 342               		.loc 1 65 2 view .LVU73
  66:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 343               		.loc 1 66 2 view .LVU74
 344               	.LVL17:
  66:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 345               		.loc 1 66 2 is_stmt 0 view .LVU75
 346               	.LBE109:
 347               	.LBE108:
 348               	.LBE107:
  36:disk_access.c **** };
 349               		.loc 1 36 2 is_stmt 1 view .LVU76
  36:disk_access.c **** };
 350               		.loc 1 36 2 view .LVU77
  36:disk_access.c **** };
 351               		.loc 1 36 2 view .LVU78
  36:disk_access.c **** };
 352               		.loc 1 36 2 view .LVU79
 353               	.LBB122:
 354               	.LBB117:
 355               	.LBB114:
  66:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 356               		.loc 1 66 4 is_stmt 0 view .LVU80
 357 0124 87E2      		ldi r24,lo8(39)
 358 0126 8983      		std Y+1,r24
  67:disk_access.c **** 	clock_wait(9);
 359               		.loc 1 67 2 is_stmt 1 view .LVU81
 360 0128 8E01      		movw r16,r28
 361 012a 0F5F      		subi r16,-1
 362 012c 1F4F      		sbci r17,-1
 363 012e A801      		movw r20,r16
 364 0130 61E0      		ldi r22,lo8(1)
 365 0132 70E0      		ldi r23,0
 366 0134 85E2      		ldi r24,lo8(37)
 367 0136 90E4      		ldi r25,lo8(64)
 368 0138 0E94 0000 		call cpu_write_6502
 369               	.LVL18:
  68:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(MOTOR);
 370               		.loc 1 68 2 view .LVU82
 371               	.LBB110:
 372               	.LBI110:
 373               		.file 3 "bus_access.h"
   1:bus_access.h  **** #ifndef _BUS_ACCESS_H_
   2:bus_access.h  **** #define _BUS_ACCESS_H_
   3:bus_access.h  **** void bus_init(void);
   4:bus_access.h  **** void phi2_init(void);
   5:bus_access.h  **** void phi2_update(void);
   6:bus_access.h  **** void cpu_read(uint16_t address, uint16_t length, uint8_t *data);
   7:bus_access.h  **** void cpu_read_6502(uint16_t address, uint16_t length, uint8_t *data);
   8:bus_access.h  **** void ppu_read(uint16_t address, uint16_t length, uint8_t *data);
   9:bus_access.h  **** void cpu_write_6502(uint16_t address, uint16_t length, const uint8_t *data);
  10:bus_access.h  **** void cpu_write_flash(uint16_t address, uint16_t length, const uint8_t *data);
  11:bus_access.h  **** void ppu_write(uint16_t address, uint16_t length, const uint8_t *data);
  12:bus_access.h  **** 
  13:bus_access.h  **** enum compare_status{
  14:bus_access.h  **** 	OK, NG
  15:bus_access.h  **** };
  16:bus_access.h  **** enum compare_status cpu_compare(uint16_t address, uint16_t length, const uint8_t *data);
  17:bus_access.h  **** enum compare_status ppu_compare(uint16_t address, uint16_t length, const uint8_t *data);
  18:bus_access.h  **** enum{
  19:bus_access.h  **** 	FLASH_PROGRAM_ORDER = 3
  20:bus_access.h  **** };
  21:bus_access.h  **** struct flash_order{
  22:bus_access.h  **** 	uint16_t address;
  23:bus_access.h  **** 	uint8_t data;
  24:bus_access.h  **** };
  25:bus_access.h  **** void cpu_write_flash_order(const struct flash_order *t);
  26:bus_access.h  **** void ppu_write_order(const struct flash_order *t);
  27:bus_access.h  **** uint8_t vram_connection_get(void);
  28:bus_access.h  **** 
  29:bus_access.h  **** void mcu_programdata_read(uint16_t address, uint16_t length, uint8_t *data);
  30:bus_access.h  **** 
  31:bus_access.h  **** #include <util/delay.h>
  32:bus_access.h  **** static inline void clock_wait(double clock)
 374               		.loc 3 32 20 view .LVU83
 375               	.LBE110:
 376               	.LBE114:
 377               	.LBE117:
 378               	.LBE122:
  33:bus_access.h  **** {
  34:bus_access.h  **** 	_delay_us(clock * 0.55);
 379               		.loc 3 34 2 view .LVU84
 380               	.LBB123:
 381               	.LBB118:
 382               	.LBB115:
 383               	.LBB113:
 384               	.LBB111:
 385               	.LBI111:
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 386               		.loc 2 255 1 view .LVU85
 387               	.LBB112:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 388               		.loc 2 257 2 view .LVU86
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 389               		.loc 2 261 2 view .LVU87
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 390               		.loc 2 262 2 view .LVU88
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 391               		.loc 2 263 2 view .LVU89
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 392               		.loc 2 273 3 view .LVU90
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 393               		.loc 2 276 2 view .LVU91
 394 013c 9AE1      		ldi r25,lo8(26)
 395 013e 9A95      	1:	dec r25
 396 0140 01F4      		brne 1b
 397 0142 00C0      		rjmp .
 398               	.LVL19:
 399               		.loc 2 276 2 is_stmt 0 view .LVU92
 400               	.LBE112:
 401               	.LBE111:
 402               	.LBE113:
  69:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 403               		.loc 1 69 2 is_stmt 1 view .LVU93
  69:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 404               		.loc 1 69 2 is_stmt 0 view .LVU94
 405               	.LBE115:
 406               	.LBE118:
 407               	.LBE123:
  36:disk_access.c **** };
 408               		.loc 1 36 2 is_stmt 1 view .LVU95
  36:disk_access.c **** };
 409               		.loc 1 36 2 view .LVU96
  36:disk_access.c **** };
 410               		.loc 1 36 2 view .LVU97
 411               	.LBB124:
 412               	.LBB119:
 413               	.LBB116:
  69:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 414               		.loc 1 69 4 is_stmt 0 view .LVU98
 415 0144 85E2      		ldi r24,lo8(37)
 416 0146 8983      		std Y+1,r24
  70:disk_access.c **** }
 417               		.loc 1 70 2 is_stmt 1 view .LVU99
 418 0148 A801      		movw r20,r16
 419 014a 61E0      		ldi r22,lo8(1)
 420 014c 70E0      		ldi r23,0
 421 014e 85E2      		ldi r24,lo8(37)
 422 0150 90E4      		ldi r25,lo8(64)
 423 0152 0E94 0000 		call cpu_write_6502
 424               	.LVL20:
 425               	.LBE116:
 426               	.LBE119:
  93:disk_access.c **** 		uint8_t w = 0xff;
 427               		.loc 1 93 3 view .LVU100
 428               	.LBB120:
 429               	.LBI120:
 166:/usr/avr/include/util/delay.h **** {
 430               		.loc 2 166 1 view .LVU101
 431               	.LBB121:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 432               		.loc 2 168 2 view .LVU102
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 433               		.loc 2 172 2 view .LVU103
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 434               		.loc 2 173 2 view .LVU104
 174:/usr/avr/include/util/delay.h **** 
 435               		.loc 2 174 2 view .LVU105
 184:/usr/avr/include/util/delay.h **** 	#endif
 436               		.loc 2 184 3 view .LVU106
 187:/usr/avr/include/util/delay.h **** 
 437               		.loc 2 187 2 view .LVU107
 438 0156 2FEF      		ldi r18,lo8(479999)
 439 0158 82E5      		ldi r24,hi8(479999)
 440 015a 97E0      		ldi r25,hlo8(479999)
 441 015c 2150      	1:	subi r18,1
 442 015e 8040      		sbci r24,0
 443 0160 9040      		sbci r25,0
 444 0162 01F4      		brne 1b
 445 0164 00C0      		rjmp .
 446 0166 0000      		nop
 447               	.LVL21:
 187:/usr/avr/include/util/delay.h **** 
 448               		.loc 2 187 2 is_stmt 0 view .LVU108
 449               	.LBE121:
 450               	.LBE120:
  94:disk_access.c **** 		cpu_write_6502(0x4026, 1, &w);
 451               		.loc 1 94 3 is_stmt 1 view .LVU109
  94:disk_access.c **** 		cpu_write_6502(0x4026, 1, &w);
 452               		.loc 1 94 11 is_stmt 0 view .LVU110
 453 0168 8FEF      		ldi r24,lo8(-1)
 454 016a 8983      		std Y+1,r24
  95:disk_access.c **** 		sequence = INIT_MOTOR_START;
 455               		.loc 1 95 3 is_stmt 1 view .LVU111
 456 016c A801      		movw r20,r16
 457 016e 61E0      		ldi r22,lo8(1)
 458 0170 70E0      		ldi r23,0
 459 0172 86E2      		ldi r24,lo8(38)
 460 0174 90E4      		ldi r25,lo8(64)
 461 0176 0E94 0000 		call cpu_write_6502
 462               	.LVL22:
  96:disk_access.c **** 		}
 463               		.loc 1 96 3 view .LVU112
  96:disk_access.c **** 		}
 464               		.loc 1 96 12 is_stmt 0 view .LVU113
 465 017a 83E0      		ldi r24,lo8(3)
 466 017c 8093 0000 		sts sequence,r24
 467               	.LBE124:
  98:disk_access.c **** 	case INIT_MOTOR_START:{
 468               		.loc 1 98 3 is_stmt 1 view .LVU114
 469 0180 00C0      		rjmp .L5
 470               	.L11:
 100:disk_access.c **** 		motor_start();
 471               		.loc 1 100 3 view .LVU115
 472               	.LBB125:
 473               	.LBI125:
  56:disk_access.c **** {
 474               		.loc 1 56 20 view .LVU116
 475               	.LBB126:
  58:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(TRANSFER_RESET);
 476               		.loc 1 58 2 view .LVU117
  59:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 477               		.loc 1 59 2 view .LVU118
 478               	.LVL23:
  59:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 479               		.loc 1 59 2 is_stmt 0 view .LVU119
 480               	.LBE126:
 481               	.LBE125:
  36:disk_access.c **** };
 482               		.loc 1 36 2 is_stmt 1 view .LVU120
  36:disk_access.c **** };
 483               		.loc 1 36 2 view .LVU121
  36:disk_access.c **** };
 484               		.loc 1 36 2 view .LVU122
 485               	.LBB128:
 486               	.LBB127:
  59:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 487               		.loc 1 59 4 is_stmt 0 view .LVU123
 488 0182 86E2      		ldi r24,lo8(38)
 489 0184 8983      		std Y+1,r24
  60:disk_access.c **** }
 490               		.loc 1 60 2 is_stmt 1 view .LVU124
 491 0186 8E01      		movw r16,r28
 492 0188 0F5F      		subi r16,-1
 493 018a 1F4F      		sbci r17,-1
 494 018c A801      		movw r20,r16
 495 018e 61E0      		ldi r22,lo8(1)
 496 0190 70E0      		ldi r23,0
 497 0192 85E2      		ldi r24,lo8(37)
 498 0194 90E4      		ldi r25,lo8(64)
 499 0196 0E94 0000 		call cpu_write_6502
 500               	.LVL24:
 501               	.LBE127:
 502               	.LBE128:
 101:disk_access.c **** 		sequence = WAIT_READY;
 503               		.loc 1 101 3 view .LVU125
 504               	.LBB129:
 505               	.LBI129:
  63:disk_access.c **** {
 506               		.loc 1 63 20 view .LVU126
 507               	.LBB130:
  65:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(TRANSFER_RESET)| bit_set(MOTOR);
 508               		.loc 1 65 2 view .LVU127
  66:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 509               		.loc 1 66 2 view .LVU128
  66:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 510               		.loc 1 66 2 is_stmt 0 view .LVU129
 511               	.LBE130:
 512               	.LBE129:
  36:disk_access.c **** };
 513               		.loc 1 36 2 is_stmt 1 view .LVU130
  36:disk_access.c **** };
 514               		.loc 1 36 2 view .LVU131
  36:disk_access.c **** };
 515               		.loc 1 36 2 view .LVU132
  36:disk_access.c **** };
 516               		.loc 1 36 2 view .LVU133
 517               	.LBB138:
 518               	.LBB135:
  66:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 519               		.loc 1 66 4 is_stmt 0 view .LVU134
 520 019a 87E2      		ldi r24,lo8(39)
 521 019c 8983      		std Y+1,r24
  67:disk_access.c **** 	clock_wait(9);
 522               		.loc 1 67 2 is_stmt 1 view .LVU135
 523 019e A801      		movw r20,r16
 524 01a0 61E0      		ldi r22,lo8(1)
 525 01a2 70E0      		ldi r23,0
 526 01a4 85E2      		ldi r24,lo8(37)
 527 01a6 90E4      		ldi r25,lo8(64)
 528 01a8 0E94 0000 		call cpu_write_6502
 529               	.LVL25:
  68:disk_access.c **** 	w = bit_set(UNKOWN) | bit_set(DIRECTION) | bit_set(MOTOR);
 530               		.loc 1 68 2 view .LVU136
 531               	.LBB131:
 532               	.LBI131:
  32:bus_access.h  **** {
 533               		.loc 3 32 20 view .LVU137
 534               	.LBE131:
 535               	.LBE135:
 536               	.LBE138:
 537               		.loc 3 34 2 view .LVU138
 538               	.LBB139:
 539               	.LBB136:
 540               	.LBB134:
 541               	.LBB132:
 542               	.LBI132:
 255:/usr/avr/include/util/delay.h **** {
 543               		.loc 2 255 1 view .LVU139
 544               	.LBB133:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 545               		.loc 2 257 2 view .LVU140
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 546               		.loc 2 261 2 view .LVU141
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 547               		.loc 2 262 2 view .LVU142
 263:/usr/avr/include/util/delay.h **** 
 548               		.loc 2 263 2 view .LVU143
 273:/usr/avr/include/util/delay.h **** 	#endif
 549               		.loc 2 273 3 view .LVU144
 550               		.loc 2 276 2 view .LVU145
 551 01ac 2AE1      		ldi r18,lo8(26)
 552 01ae 2A95      	1:	dec r18
 553 01b0 01F4      		brne 1b
 554 01b2 00C0      		rjmp .
 555               	.LVL26:
 556               		.loc 2 276 2 is_stmt 0 view .LVU146
 557               	.LBE133:
 558               	.LBE132:
 559               	.LBE134:
  69:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 560               		.loc 1 69 2 is_stmt 1 view .LVU147
  69:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 561               		.loc 1 69 2 is_stmt 0 view .LVU148
 562               	.LBE136:
 563               	.LBE139:
  36:disk_access.c **** };
 564               		.loc 1 36 2 is_stmt 1 view .LVU149
  36:disk_access.c **** };
 565               		.loc 1 36 2 view .LVU150
  36:disk_access.c **** };
 566               		.loc 1 36 2 view .LVU151
 567               	.LBB140:
 568               	.LBB137:
  69:disk_access.c **** 	cpu_write_6502(DISK_CONTROL, 1, &w);
 569               		.loc 1 69 4 is_stmt 0 view .LVU152
 570 01b4 85E2      		ldi r24,lo8(37)
 571 01b6 8983      		std Y+1,r24
  70:disk_access.c **** }
 572               		.loc 1 70 2 is_stmt 1 view .LVU153
 573 01b8 A801      		movw r20,r16
 574 01ba 61E0      		ldi r22,lo8(1)
 575 01bc 70E0      		ldi r23,0
 576 01be 85E2      		ldi r24,lo8(37)
 577 01c0 90E4      		ldi r25,lo8(64)
 578 01c2 0E94 0000 		call cpu_write_6502
 579               	.LVL27:
 580               	.LBE137:
 581               	.LBE140:
 102:disk_access.c **** 		}break;
 582               		.loc 1 102 3 view .LVU154
 102:disk_access.c **** 		}break;
 583               		.loc 1 102 12 is_stmt 0 view .LVU155
 584 01c6 84E0      		ldi r24,lo8(4)
 585 01c8 8093 0000 		sts sequence,r24
 103:disk_access.c **** 	case WAIT_READY:{
 586               		.loc 1 103 4 is_stmt 1 view .LVU156
 103:disk_access.c **** 	case WAIT_READY:{
 587               		.loc 1 103 3 is_stmt 0 view .LVU157
 588 01cc 00C0      		rjmp .L5
 589               	.L10:
 590               	.LBB141:
 105:disk_access.c **** 		cpu_read_6502(status, 1, &s);
 591               		.loc 1 105 3 is_stmt 1 view .LVU158
 106:disk_access.c **** 		if((s & 0b10) == 0b00){
 592               		.loc 1 106 3 view .LVU159
 593 01ce 8E01      		movw r16,r28
 594 01d0 0F5F      		subi r16,-1
 595 01d2 1F4F      		sbci r17,-1
 596 01d4 A801      		movw r20,r16
 597 01d6 61E0      		ldi r22,lo8(1)
 598 01d8 70E0      		ldi r23,0
 599 01da 82E3      		ldi r24,lo8(50)
 600 01dc 90E4      		ldi r25,lo8(64)
 601 01de 0E94 0000 		call cpu_read_6502
 602               	.LVL28:
 107:disk_access.c **** 			sequence = READ_START;
 603               		.loc 1 107 3 view .LVU160
 107:disk_access.c **** 			sequence = READ_START;
 604               		.loc 1 107 5 is_stmt 0 view .LVU161
 605 01e2 8981      		ldd r24,Y+1
 606 01e4 81FF      		sbrs r24,1
 607 01e6 00C0      		rjmp .L15
 608 01e8 8091 0000 		lds r24,sequence
 609 01ec 00C0      		rjmp .L5
 610               	.L9:
 611               	.LBE141:
 612               	.LBB142:
 112:disk_access.c **** 		_delay_ms(267 + 5);
 613               		.loc 1 112 3 is_stmt 1 view .LVU162
 113:disk_access.c **** 		
 614               		.loc 1 113 3 view .LVU163
 615               	.LVL29:
 616               	.LBB143:
 617               	.LBI143:
 166:/usr/avr/include/util/delay.h **** {
 618               		.loc 2 166 1 view .LVU164
 619               	.LBB144:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 620               		.loc 2 168 2 view .LVU165
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 621               		.loc 2 172 2 view .LVU166
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 622               		.loc 2 173 2 view .LVU167
 174:/usr/avr/include/util/delay.h **** 
 623               		.loc 2 174 2 view .LVU168
 184:/usr/avr/include/util/delay.h **** 	#endif
 624               		.loc 2 184 3 view .LVU169
 187:/usr/avr/include/util/delay.h **** 
 625               		.loc 2 187 2 view .LVU170
 626 01ee 8FEF      		ldi r24,lo8(870399)
 627 01f0 97E4      		ldi r25,hi8(870399)
 628 01f2 2DE0      		ldi r18,hlo8(870399)
 629 01f4 8150      	1:	subi r24,1
 630 01f6 9040      		sbci r25,0
 631 01f8 2040      		sbci r18,0
 632 01fa 01F4      		brne 1b
 633 01fc 00C0      		rjmp .
 634 01fe 0000      		nop
 635               	.LVL30:
 187:/usr/avr/include/util/delay.h **** 
 636               		.loc 2 187 2 is_stmt 0 view .LVU171
 637               	.LBE144:
 638               	.LBE143:
 115:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 639               		.loc 1 115 3 is_stmt 1 view .LVU172
 115:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 640               		.loc 1 115 3 is_stmt 0 view .LVU173
 641               	.LBE142:
  36:disk_access.c **** };
 642               		.loc 1 36 2 is_stmt 1 view .LVU174
  36:disk_access.c **** };
 643               		.loc 1 36 2 view .LVU175
  36:disk_access.c **** };
 644               		.loc 1 36 2 view .LVU176
  36:disk_access.c **** };
 645               		.loc 1 36 2 view .LVU177
  36:disk_access.c **** };
 646               		.loc 1 36 2 view .LVU178
 647               	.LBB149:
 115:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 648               		.loc 1 115 5 is_stmt 0 view .LVU179
 649 0200 8DE6      		ldi r24,lo8(109)
 650 0202 8983      		std Y+1,r24
 116:disk_access.c **** 		clock_wait(21 - 1);
 651               		.loc 1 116 3 is_stmt 1 view .LVU180
 652 0204 8E01      		movw r16,r28
 653 0206 0F5F      		subi r16,-1
 654 0208 1F4F      		sbci r17,-1
 655 020a A801      		movw r20,r16
 656 020c 61E0      		ldi r22,lo8(1)
 657 020e 70E0      		ldi r23,0
 658 0210 85E2      		ldi r24,lo8(37)
 659 0212 90E4      		ldi r25,lo8(64)
 660 0214 0E94 0000 		call cpu_write_6502
 661               	.LVL31:
 117:disk_access.c **** 		//DRQ enable
 662               		.loc 1 117 3 view .LVU181
 663               	.LBB145:
 664               	.LBI145:
  32:bus_access.h  **** {
 665               		.loc 3 32 20 view .LVU182
 666               	.LBE145:
 667               	.LBE149:
 668               		.loc 3 34 2 view .LVU183
 669               	.LBB150:
 670               	.LBB148:
 671               	.LBB146:
 672               	.LBI146:
 255:/usr/avr/include/util/delay.h **** {
 673               		.loc 2 255 1 view .LVU184
 674               	.LBB147:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 675               		.loc 2 257 2 view .LVU185
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 676               		.loc 2 261 2 view .LVU186
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 677               		.loc 2 262 2 view .LVU187
 263:/usr/avr/include/util/delay.h **** 
 678               		.loc 2 263 2 view .LVU188
 273:/usr/avr/include/util/delay.h **** 	#endif
 679               		.loc 2 273 3 view .LVU189
 680               		.loc 2 276 2 view .LVU190
 681 0218 8AE3      		ldi r24,lo8(58)
 682 021a 8A95      	1:	dec r24
 683 021c 01F4      		brne 1b
 684 021e 00C0      		rjmp .
 685               	.LVL32:
 686               		.loc 2 276 2 is_stmt 0 view .LVU191
 687               	.LBE147:
 688               	.LBE146:
 689               	.LBE148:
 121:disk_access.c **** 		//RP2C33 IRQ enable
 690               		.loc 1 121 3 is_stmt 1 view .LVU192
 121:disk_access.c **** 		//RP2C33 IRQ enable
 691               		.loc 1 121 13 is_stmt 0 view .LVU193
 692 0220 80E0      		ldi r24,0
 693 0222 94E0      		ldi r25,lo8(4)
 694 0224 9093 0000 		sts drq_count+1,r25
 695 0228 8093 0000 		sts drq_count,r24
 123:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 696               		.loc 1 123 3 is_stmt 1 view .LVU194
 697               	.LVL33:
 123:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 698               		.loc 1 123 3 is_stmt 0 view .LVU195
 699               	.LBE150:
  36:disk_access.c **** };
 700               		.loc 1 36 2 is_stmt 1 view .LVU196
 701               	.LBB151:
 123:disk_access.c **** 		cpu_write_6502(DISK_CONTROL, 1, &w);
 702               		.loc 1 123 5 is_stmt 0 view .LVU197
 703 022c 8981      		ldd r24,Y+1
 704 022e 8068      		ori r24,lo8(-128)
 705 0230 8983      		std Y+1,r24
 124:disk_access.c **** 		sequence = READING;
 706               		.loc 1 124 3 is_stmt 1 view .LVU198
 707 0232 A801      		movw r20,r16
 708 0234 61E0      		ldi r22,lo8(1)
 709 0236 70E0      		ldi r23,0
 710 0238 85E2      		ldi r24,lo8(37)
 711 023a 90E4      		ldi r25,lo8(64)
 712 023c 0E94 0000 		call cpu_write_6502
 713               	.LVL34:
 125:disk_access.c **** 		}break;
 714               		.loc 1 125 3 view .LVU199
 125:disk_access.c **** 		}break;
 715               		.loc 1 125 12 is_stmt 0 view .LVU200
 716 0240 86E0      		ldi r24,lo8(6)
 717 0242 8093 0000 		sts sequence,r24
 718               	.LBE151:
 126:disk_access.c **** 	case READING:
 719               		.loc 1 126 4 is_stmt 1 view .LVU201
 126:disk_access.c **** 	case READING:
 720               		.loc 1 126 3 is_stmt 0 view .LVU202
 721 0246 00C0      		rjmp .L5
 722               	.L15:
 723               	.LBB152:
 108:disk_access.c **** 		}
 724               		.loc 1 108 4 is_stmt 1 view .LVU203
 108:disk_access.c **** 		}
 725               		.loc 1 108 13 is_stmt 0 view .LVU204
 726 0248 85E0      		ldi r24,lo8(5)
 727 024a 8093 0000 		sts sequence,r24
 728               	.LBE152:
 110:disk_access.c **** 	case READ_START:{
 729               		.loc 1 110 4 is_stmt 1 view .LVU205
 110:disk_access.c **** 	case READ_START:{
 730               		.loc 1 110 3 is_stmt 0 view .LVU206
 731 024e 00C0      		rjmp .L5
 732               		.cfi_endproc
 733               	.LFE13:
 735               	.global	__vector_2
 737               	__vector_2:
 738               	.LFB14:
 147:disk_access.c **** 
 148:disk_access.c **** ISR(INT1_vect)
 149:disk_access.c **** {
 739               		.loc 1 149 1 is_stmt 1 view -0
 740               		.cfi_startproc
 741 0250 1F92      		push r1
 742               	.LCFI8:
 743               		.cfi_def_cfa_offset 3
 744               		.cfi_offset 1, -2
 745 0252 0F92      		push r0
 746               	.LCFI9:
 747               		.cfi_def_cfa_offset 4
 748               		.cfi_offset 0, -3
 749 0254 0FB6      		in r0,__SREG__
 750 0256 0F92      		push r0
 751 0258 1124      		clr __zero_reg__
 752 025a 2F93      		push r18
 753               	.LCFI10:
 754               		.cfi_def_cfa_offset 5
 755               		.cfi_offset 18, -4
 756 025c 3F93      		push r19
 757               	.LCFI11:
 758               		.cfi_def_cfa_offset 6
 759               		.cfi_offset 19, -5
 760 025e 4F93      		push r20
 761               	.LCFI12:
 762               		.cfi_def_cfa_offset 7
 763               		.cfi_offset 20, -6
 764 0260 5F93      		push r21
 765               	.LCFI13:
 766               		.cfi_def_cfa_offset 8
 767               		.cfi_offset 21, -7
 768 0262 6F93      		push r22
 769               	.LCFI14:
 770               		.cfi_def_cfa_offset 9
 771               		.cfi_offset 22, -8
 772 0264 7F93      		push r23
 773               	.LCFI15:
 774               		.cfi_def_cfa_offset 10
 775               		.cfi_offset 23, -9
 776 0266 8F93      		push r24
 777               	.LCFI16:
 778               		.cfi_def_cfa_offset 11
 779               		.cfi_offset 24, -10
 780 0268 9F93      		push r25
 781               	.LCFI17:
 782               		.cfi_def_cfa_offset 12
 783               		.cfi_offset 25, -11
 784 026a AF93      		push r26
 785               	.LCFI18:
 786               		.cfi_def_cfa_offset 13
 787               		.cfi_offset 26, -12
 788 026c BF93      		push r27
 789               	.LCFI19:
 790               		.cfi_def_cfa_offset 14
 791               		.cfi_offset 27, -13
 792 026e EF93      		push r30
 793               	.LCFI20:
 794               		.cfi_def_cfa_offset 15
 795               		.cfi_offset 30, -14
 796 0270 FF93      		push r31
 797               	.LCFI21:
 798               		.cfi_def_cfa_offset 16
 799               		.cfi_offset 31, -15
 800 0272 CF93      		push r28
 801               	.LCFI22:
 802               		.cfi_def_cfa_offset 17
 803               		.cfi_offset 28, -16
 804 0274 DF93      		push r29
 805               	.LCFI23:
 806               		.cfi_def_cfa_offset 18
 807               		.cfi_offset 29, -17
 808 0276 0F92      		push __tmp_reg__
 809               	.LCFI24:
 810               		.cfi_def_cfa_offset 19
 811 0278 CDB7      		in r28,__SP_L__
 812 027a DEB7      		in r29,__SP_H__
 813               	.LCFI25:
 814               		.cfi_def_cfa_register 28
 815               	/* prologue: Signal */
 816               	/* frame size = 1 */
 817               	/* stack size = 18 */
 818               	.L__stack_usage = 18
 150:disk_access.c **** 	static uint16_t buffer_pointer = BUFFER_ADDRESS;
 819               		.loc 1 150 2 view .LVU208
 151:disk_access.c **** 	uint8_t d;
 820               		.loc 1 151 2 view .LVU209
 152:disk_access.c **** 	cpu_read_6502(0x4031, 1, &d);
 821               		.loc 1 152 2 view .LVU210
 822 027c AE01      		movw r20,r28
 823 027e 4F5F      		subi r20,-1
 824 0280 5F4F      		sbci r21,-1
 825 0282 61E0      		ldi r22,lo8(1)
 826 0284 70E0      		ldi r23,0
 827 0286 81E3      		ldi r24,lo8(49)
 828 0288 90E4      		ldi r25,lo8(64)
 829 028a 0E94 0000 		call cpu_read_6502
 830               	.LVL35:
 153:disk_access.c **** 	ppu_write(buffer_pointer++, 1, &d);
 831               		.loc 1 153 2 view .LVU211
 832 028e 8091 0000 		lds r24,buffer_pointer.1761
 833 0292 9091 0000 		lds r25,buffer_pointer.1761+1
 834 0296 9C01      		movw r18,r24
 835 0298 2F5F      		subi r18,-1
 836 029a 3F4F      		sbci r19,-1
 837 029c 3093 0000 		sts buffer_pointer.1761+1,r19
 838 02a0 2093 0000 		sts buffer_pointer.1761,r18
 839 02a4 AE01      		movw r20,r28
 840 02a6 4F5F      		subi r20,-1
 841 02a8 5F4F      		sbci r21,-1
 842 02aa 61E0      		ldi r22,lo8(1)
 843 02ac 70E0      		ldi r23,0
 844 02ae 0E94 0000 		call ppu_write
 845               	.LVL36:
 154:disk_access.c **** 	//cpu_write_6502(buffer_pointer++, 1, &d);
 155:disk_access.c **** 	if(buffer_pointer >= BUFFER_ADDRESS + DRQ_COUNT){
 846               		.loc 1 155 2 view .LVU212
 847               		.loc 1 155 4 is_stmt 0 view .LVU213
 848 02b2 8091 0000 		lds r24,buffer_pointer.1761
 849 02b6 9091 0000 		lds r25,buffer_pointer.1761+1
 850 02ba 8115      		cp r24,__zero_reg__
 851 02bc 9440      		sbci r25,4
 852 02be 00F0      		brlo .L24
 156:disk_access.c **** 		buffer_pointer = 0;
 853               		.loc 1 156 3 is_stmt 1 view .LVU214
 854               		.loc 1 156 18 is_stmt 0 view .LVU215
 855 02c0 1092 0000 		sts buffer_pointer.1761+1,__zero_reg__
 856 02c4 1092 0000 		sts buffer_pointer.1761,__zero_reg__
 857               	.L24:
 157:disk_access.c **** 	}
 158:disk_access.c **** 	drq_count -= 1;
 858               		.loc 1 158 2 is_stmt 1 view .LVU216
 859               		.loc 1 158 12 is_stmt 0 view .LVU217
 860 02c8 8091 0000 		lds r24,drq_count
 861 02cc 9091 0000 		lds r25,drq_count+1
 862 02d0 0197      		sbiw r24,1
 863 02d2 9093 0000 		sts drq_count+1,r25
 864 02d6 8093 0000 		sts drq_count,r24
 865               	/* epilogue start */
 159:disk_access.c **** }
 866               		.loc 1 159 1 view .LVU218
 867 02da 0F90      		pop __tmp_reg__
 868 02dc DF91      		pop r29
 869 02de CF91      		pop r28
 870 02e0 FF91      		pop r31
 871 02e2 EF91      		pop r30
 872 02e4 BF91      		pop r27
 873 02e6 AF91      		pop r26
 874 02e8 9F91      		pop r25
 875 02ea 8F91      		pop r24
 876 02ec 7F91      		pop r23
 877 02ee 6F91      		pop r22
 878 02f0 5F91      		pop r21
 879 02f2 4F91      		pop r20
 880 02f4 3F91      		pop r19
 881 02f6 2F91      		pop r18
 882 02f8 0F90      		pop r0
 883 02fa 0FBE      		out __SREG__,r0
 884 02fc 0F90      		pop r0
 885 02fe 1F90      		pop r1
 886 0300 1895      		reti
 887               		.cfi_endproc
 888               	.LFE14:
 890               		.local	buffer_pointer.1761
 891               		.comm	buffer_pointer.1761,2,1
 892               		.local	drq_count
 893               		.comm	drq_count,2,1
 894               		.local	sequence
 895               		.comm	sequence,1,1
 896               	.Letext0:
 897               		.file 4 "/usr/avr/include/stdint.h"
 898               		.file 5 "disk_access.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 disk_access.c
     /tmp/ccdipY0m.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccdipY0m.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccdipY0m.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccdipY0m.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccdipY0m.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccdipY0m.s:12     .text:0000000000000000 disk_status_get
     /tmp/ccdipY0m.s:46     .text:0000000000000014 disk_init
     /tmp/ccdipY0m.s:893    .bss:0000000000000004 sequence
     /tmp/ccdipY0m.s:73     .text:000000000000001c disk_process
     /tmp/ccdipY0m.s:891    .bss:0000000000000002 drq_count
     /tmp/ccdipY0m.s:737    .text:0000000000000250 __vector_2
                             .bss:0000000000000000 buffer_pointer.1761

UNDEFINED SYMBOLS
cpu_read
__tablejump2__
ppu_write
phi2_update
cpu_write_6502
cpu_read_6502
__do_copy_data
__do_clear_bss
