   1               		.file	"bus_access.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	bus_init
  12               	bus_init:
  13               	.LFB11:
  14               		.file 1 "bus_access.c"
   1:bus_access.c  **** 
   2:bus_access.c  **** 
   3:bus_access.c  **** #include <util/delay.h>
   4:bus_access.c  **** #include <avr/io.h>
   5:bus_access.c  **** #include "type.h"
   6:bus_access.c  **** #include "bus_access.h"
   7:bus_access.c  **** 
   8:bus_access.c  **** //avr/io.h use many macros, I want use IO access by inline function...
   9:bus_access.c  **** #define IO_DIRECTION(NAME) (DDR##NAME)
  10:bus_access.c  **** #define IO_OUT(NAME) (PORT##NAME)
  11:bus_access.c  **** #define IO_IN(NAME) (PIN##NAME)
  12:bus_access.c  **** /*
  13:bus_access.c  **** --------- assignment and functions for PCB revision 1.x --------
  14:bus_access.c  **** */
  15:bus_access.c  **** #if PCB_REVISION == 1
  16:bus_access.c  **** /* PAx: output only
  17:bus_access.c  **** connected CPU and PPU databus*/
  18:bus_access.c  **** #define ADDRESSBUS_A0_A7_DIR IO_DIRECTION(A)
  19:bus_access.c  **** #define ADDRESSBUS_A0_A7_OUT IO_OUT(A)
  20:bus_access.c  **** /* PBx: output/input
  21:bus_access.c  **** connected address high latch(HC573), CPU and PPU databus*/
  22:bus_access.c  **** #define DATABUS_DIR IO_DIRECTION(B)
  23:bus_access.c  **** #define DATABUS_OUT IO_OUT(B)
  24:bus_access.c  **** #define DATABUS_IN IO_IN(B)
  25:bus_access.c  **** /*PCx: output ADDRESS_HIGH_LATCH connect HC574 clock pin or HC573 latch enable bar pin, bus control
  26:bus_access.c  **** VRAM_CS is input port this is design mistake!
  27:bus_access.c  **** */
  28:bus_access.c  **** #define BUS_CONTROL_DIR IO_DIRECTION(C)
  29:bus_access.c  **** #define BUS_CONTROL_OUT IO_OUT(C)
  30:bus_access.c  **** enum iobit_bus_control{
  31:bus_access.c  **** 	CPU_PHI2 = 0, CPU_ROMCS, CPU_RW,
  32:bus_access.c  **** 	RESERVE_PPU_POS_A13, PPU_RD, PPU_WR,
  33:bus_access.c  **** 	VRAM_CS, ADDRESS_HIGH_LATCH
  34:bus_access.c  **** };
  35:bus_access.c  **** /*PDx: use input, empty pin is output*/
  36:bus_access.c  **** #define USB_MISC_DIR IO_DIRECTION(D)
  37:bus_access.c  **** #define USB_MISC_PULLUP IO_OUT(D)
  38:bus_access.c  **** #define USB_MISC_IN IO_IN(D)
  39:bus_access.c  **** enum iobit_usb_misc{
  40:bus_access.c  **** 	USB_DPLUS = 2, CPU_IRQ, 
  41:bus_access.c  **** 	USB_DMINUS, VRAM_A10
  42:bus_access.c  **** };
  43:bus_access.c  **** #endif
  44:bus_access.c  **** /*
  45:bus_access.c  **** --------- assignment and functions for PCB revision 2.x --------
  46:bus_access.c  **** */
  47:bus_access.c  **** #if PCB_REVISION == 2
  48:bus_access.c  **** /* PBx: misc IO 
  49:bus_access.c  **** 0:IO:USB D+ / PCINT0.vector.PCI0
  50:bus_access.c  **** 1:IO:USB D-
  51:bus_access.c  **** 2:I :VRAM A10
  52:bus_access.c  **** 3:I :VRAM CS# / MOSI
  53:bus_access.c  **** 4: O:Address Low Latch / MISO
  54:bus_access.c  **** 5: O:Address High Latch / SCK 
  55:bus_access.c  **** */
  56:bus_access.c  **** #define USB_MISC_DIR IO_DIRECTION(B)
  57:bus_access.c  **** #define USB_MISC_PULLUP IO_OUT(B)
  58:bus_access.c  **** #define USB_MISC_IN IO_IN(B)
  59:bus_access.c  **** enum iobit_usb_misc{
  60:bus_access.c  **** 	USB_DPLUS = 0, USB_DMINUS,
  61:bus_access.c  **** 	VRAM_A10, VRAM_CS,
  62:bus_access.c  **** 	ADDRESS_LOW_LATCH, ADDRESS_HIGH_LATCH,
  63:bus_access.c  **** 	XTAL1, XTAL2
  64:bus_access.c  **** };
  65:bus_access.c  **** /* PCx: output; memory control + etc 
  66:bus_access.c  **** 0:I :CPU IRQ# / PCINT8.vector.PCI1
  67:bus_access.c  **** 1: O:CPU PHI2
  68:bus_access.c  **** 2: O:CPU ROMCS#
  69:bus_access.c  **** 3: O:CPU R/W
  70:bus_access.c  **** 4: O:PPU RD#
  71:bus_access.c  **** 5: O:PPU WR#
  72:bus_access.c  **** 6:I :MCU RESET
  73:bus_access.c  **** */
  74:bus_access.c  **** #define BUS_CONTROL_DIR IO_DIRECTION(C)
  75:bus_access.c  **** #define BUS_CONTROL_OUT IO_OUT(C)
  76:bus_access.c  **** enum iobit_bus_control{
  77:bus_access.c  **** 	CPU_IRQ = 0, CPU_PHI2, CPU_ROMCS, CPU_RW,
  78:bus_access.c  **** 	PPU_RD, PPU_WR
  79:bus_access.c  **** };
  80:bus_access.c  **** /*PD: IO; databus */
  81:bus_access.c  **** #define DATABUS_DIR IO_DIRECTION(D)
  82:bus_access.c  **** #define DATABUS_OUT IO_OUT(D)
  83:bus_access.c  **** #define DATABUS_IN IO_IN(D)
  84:bus_access.c  **** #endif
  85:bus_access.c  **** 
  86:bus_access.c  **** enum databus_dir{
  87:bus_access.c  **** 	DATABUS_DIR_OUT = 0xff,
  88:bus_access.c  **** 	DATABUS_DIR_IN = 0
  89:bus_access.c  **** };
  90:bus_access.c  **** //when cpu_write_flash, phi2 must be low. when phi2 is high, mmc3 and vrc4 changes bank.
  91:bus_access.c  **** #if PCB_REVISION == 1
  92:bus_access.c  **** enum {
  93:bus_access.c  ****         BUS_CLOSE = (uint8_t)~((1<<ADDRESS_HIGH_LATCH)|(1 << CPU_PHI2)),
  94:bus_access.c  ****         ADDRESS_CLOSE = 0x3fff //CPU and PPU are mapped internal registers, cartridge closes buses
  95:bus_access.c  **** };
  96:bus_access.c  **** #endif
  97:bus_access.c  **** #if PCB_REVISION == 2
  98:bus_access.c  **** enum {
  99:bus_access.c  ****         BUS_CLOSE = (uint8_t)~(1 << CPU_PHI2),
 100:bus_access.c  ****         ADDRESS_CLOSE = 0x3fff //CPU and PPU are mapped internal registers, cartridge closes buses
 101:bus_access.c  **** };
 102:bus_access.c  **** #endif
 103:bus_access.c  **** 
 104:bus_access.c  **** static inline uint8_t bit_get_negative(enum iobit_bus_control bit)
 105:bus_access.c  **** {
 106:bus_access.c  **** 	uint8_t ret = (1 << bit);
 107:bus_access.c  **** 	return ~ret;
 108:bus_access.c  **** }
 109:bus_access.c  **** 
 110:bus_access.c  **** #if PCB_REVISION == 1
 111:bus_access.c  **** /*
 112:bus_access.c  **** address high databus assignment
 113:bus_access.c  **** D0-D5: CPU and PPU A8-A13
 114:bus_access.c  **** D6: CPU A14
 115:bus_access.c  **** D7: PPU /A13
 116:bus_access.c  **** */
 117:bus_access.c  **** static void address_set(uint16_t address)
 118:bus_access.c  **** {
 119:bus_access.c  **** 	ADDRESSBUS_A0_A7_OUT = address & 0xff;
 120:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 121:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 122:bus_access.c  **** 		high |= 0x80; //set /A13
 123:bus_access.c  **** 	}
 124:bus_access.c  **** 	DATABUS_OUT = high;
 125:bus_access.c  **** 	//phi2 pulse is needed mmc1
 126:bus_access.c  **** 	BUS_CONTROL_OUT = ~(0); 
 127:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 128:bus_access.c  **** }
 129:bus_access.c  **** 
 130:bus_access.c  **** void bus_init(void)
 131:bus_access.c  **** {
  15               		.loc 1 131 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 132:bus_access.c  **** 	ADDRESSBUS_A0_A7_DIR = 0xff;
  21               		.loc 1 132 2 view .LVU1
  22               		.loc 1 132 23 is_stmt 0 view .LVU2
  23 0000 8FEF      		ldi r24,lo8(-1)
  24 0002 8ABB      		out 0x1a,r24
 133:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_OUT;
  25               		.loc 1 133 2 is_stmt 1 view .LVU3
  26               		.loc 1 133 14 is_stmt 0 view .LVU4
  27 0004 87BB      		out 0x17,r24
 134:bus_access.c  **** 	BUS_CONTROL_DIR = bit_get_negative(VRAM_CS); //VRAM_CS is input port
  28               		.loc 1 134 2 is_stmt 1 view .LVU5
  29               	.LVL0:
 106:bus_access.c  **** 	return ~ret;
  30               		.loc 1 106 2 view .LVU6
 107:bus_access.c  **** }
  31               		.loc 1 107 2 view .LVU7
  32               		.loc 1 134 18 is_stmt 0 view .LVU8
  33 0006 9FEB      		ldi r25,lo8(-65)
  34 0008 94BB      		out 0x14,r25
 135:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
  35               		.loc 1 135 2 is_stmt 1 view .LVU9
  36               		.loc 1 135 18 is_stmt 0 view .LVU10
  37 000a 9EE7      		ldi r25,lo8(126)
  38 000c 95BB      		out 0x15,r25
 136:bus_access.c  **** 	USB_MISC_DIR = (0b1100 << 4) | 0b0011; //empty pin use OUT
  39               		.loc 1 136 2 is_stmt 1 view .LVU11
  40               		.loc 1 136 15 is_stmt 0 view .LVU12
  41 000e 23EC      		ldi r18,lo8(-61)
  42 0010 21BB      		out 0x11,r18
 137:bus_access.c  **** 	USB_MISC_PULLUP = (1 << CPU_IRQ) | (1 << VRAM_A10);
  43               		.loc 1 137 2 is_stmt 1 view .LVU13
  44               		.loc 1 137 18 is_stmt 0 view .LVU14
  45 0012 28E2      		ldi r18,lo8(40)
  46 0014 22BB      		out 0x12,r18
 138:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
  47               		.loc 1 138 2 is_stmt 1 view .LVU15
  48               	.LVL1:
  49               	.LBB210:
  50               	.LBI210:
 117:bus_access.c  **** {
  51               		.loc 1 117 13 view .LVU16
  52               	.LBB211:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
  53               		.loc 1 119 2 view .LVU17
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
  54               		.loc 1 119 23 is_stmt 0 view .LVU18
  55 0016 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
  56               		.loc 1 120 2 is_stmt 1 view .LVU19
  57               	.LVL2:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
  58               		.loc 1 121 2 view .LVU20
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
  59               		.loc 1 124 2 view .LVU21
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
  60               		.loc 1 124 14 is_stmt 0 view .LVU22
  61 0018 2FE3      		ldi r18,lo8(63)
  62 001a 28BB      		out 0x18,r18
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
  63               		.loc 1 126 2 is_stmt 1 view .LVU23
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
  64               		.loc 1 126 18 is_stmt 0 view .LVU24
  65 001c 85BB      		out 0x15,r24
 127:bus_access.c  **** }
  66               		.loc 1 127 2 is_stmt 1 view .LVU25
 127:bus_access.c  **** }
  67               		.loc 1 127 18 is_stmt 0 view .LVU26
  68 001e 95BB      		out 0x15,r25
  69               	.LVL3:
  70               	/* epilogue start */
 127:bus_access.c  **** }
  71               		.loc 1 127 18 view .LVU27
  72               	.LBE211:
  73               	.LBE210:
 139:bus_access.c  **** }
  74               		.loc 1 139 1 view .LVU28
  75 0020 0895      		ret
  76               		.cfi_endproc
  77               	.LFE11:
  79               	.global	phi2_init
  81               	phi2_init:
  82               	.LFB12:
 140:bus_access.c  **** #endif
 141:bus_access.c  **** #if PCB_REVISION == 2
 142:bus_access.c  **** static void address_set(uint16_t address)
 143:bus_access.c  **** {
 144:bus_access.c  **** 	const uint8_t portb = 0x05;
 145:bus_access.c  **** 	DATABUS_OUT = address & 0xff;
 146:bus_access.c  **** 	asm("sbi %0,%1" : :"M"(portb),"M"(ADDRESS_LOW_LATCH));
 147:bus_access.c  **** 	asm("cbi %0,%1" : :"M"(portb),"M"(ADDRESS_LOW_LATCH));
 148:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 149:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 150:bus_access.c  **** 		high |= 0x80; //set /A13
 151:bus_access.c  **** 	}
 152:bus_access.c  **** 	DATABUS_OUT = high;
 153:bus_access.c  **** 	asm("sbi %0,%1" : :"M"(portb),"M"(ADDRESS_HIGH_LATCH));
 154:bus_access.c  **** 	asm("cbi %0,%1" : :"M"(portb),"M"(ADDRESS_HIGH_LATCH));
 155:bus_access.c  **** 	//phi2 pulse is needed mmc1
 156:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE | (1 << CPU_PHI2);
 157:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 158:bus_access.c  **** }
 159:bus_access.c  **** void bus_init(void)
 160:bus_access.c  **** {
 161:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_OUT;
 162:bus_access.c  **** 	BUS_CONTROL_DIR = (1 << CPU_PHI2) | (1 << CPU_ROMCS) | (1 << CPU_RW) | (1 << PPU_RD) | (1 << PPU_W
 163:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 164:bus_access.c  **** 	USB_MISC_DIR = (1 << ADDRESS_HIGH_LATCH) | (1 << ADDRESS_LOW_LATCH);
 165:bus_access.c  **** 	USB_MISC_PULLUP = (1 << VRAM_A10)| (1 << VRAM_CS);
 166:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
 167:bus_access.c  **** }
 168:bus_access.c  **** #endif
 169:bus_access.c  **** 
 170:bus_access.c  **** /*
 171:bus_access.c  **** make phi2 edge signal, this is needed by namcot mapper and RP2C33.
 172:bus_access.c  **** */
 173:bus_access.c  **** void phi2_init(void)
 174:bus_access.c  **** {
  83               		.loc 1 174 1 is_stmt 1 view -0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 175:bus_access.c  **** 	int i = 0x80;
  89               		.loc 1 175 2 view .LVU30
  90               	.LVL4:
 176:bus_access.c  **** 	while(i != 0){
  91               		.loc 1 176 2 view .LVU31
  92               		.loc 1 176 7 view .LVU32
 174:bus_access.c  **** 	int i = 0x80;
  93               		.loc 1 174 1 is_stmt 0 view .LVU33
  94 0022 80E8      		ldi r24,lo8(-128)
  95 0024 90E0      		ldi r25,0
 177:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
  96               		.loc 1 177 19 view .LVU34
  97 0026 3EE7      		ldi r19,lo8(126)
 178:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE ^ (1 << CPU_PHI2);
  98               		.loc 1 178 19 view .LVU35
  99 0028 2FE7      		ldi r18,lo8(127)
 100               	.LVL5:
 101               	.L4:
 177:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 102               		.loc 1 177 3 is_stmt 1 view .LVU36
 177:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 103               		.loc 1 177 19 is_stmt 0 view .LVU37
 104 002a 35BB      		out 0x15,r19
 105               		.loc 1 178 3 is_stmt 1 view .LVU38
 106               		.loc 1 178 19 is_stmt 0 view .LVU39
 107 002c 25BB      		out 0x15,r18
 179:bus_access.c  **** 		i--;
 108               		.loc 1 179 3 is_stmt 1 view .LVU40
 109               	.LVL6:
 176:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 110               		.loc 1 176 7 view .LVU41
 111 002e 0197      		sbiw r24,1
 112               	.LVL7:
 176:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 113               		.loc 1 176 7 is_stmt 0 view .LVU42
 114 0030 01F4      		brne .L4
 115               	/* epilogue start */
 180:bus_access.c  **** 	}
 181:bus_access.c  **** }
 116               		.loc 1 181 1 view .LVU43
 117 0032 0895      		ret
 118               		.cfi_endproc
 119               	.LFE12:
 121               	.global	phi2_update
 123               	phi2_update:
 124               	.LFB13:
 182:bus_access.c  **** 
 183:bus_access.c  **** //for RAM adapter DRAM refresh
 184:bus_access.c  **** void phi2_update(void)
 185:bus_access.c  **** {
 125               		.loc 1 185 1 is_stmt 1 view -0
 126               		.cfi_startproc
 127               	/* prologue: function */
 128               	/* frame size = 0 */
 129               	/* stack size = 0 */
 130               	.L__stack_usage = 0
 186:bus_access.c  **** 	static uint8_t i = 0;
 131               		.loc 1 186 2 view .LVU45
 187:bus_access.c  **** 	uint8_t c = BUS_CLOSE;
 132               		.loc 1 187 2 view .LVU46
 133               	.LVL8:
 188:bus_access.c  **** 	if(i & 0b100){
 134               		.loc 1 188 2 view .LVU47
 135               		.loc 1 188 4 is_stmt 0 view .LVU48
 136 0034 8091 0000 		lds r24,i.1727
 137 0038 82FF      		sbrs r24,2
 138 003a 00C0      		rjmp .L8
 189:bus_access.c  **** 		c ^= 1 << CPU_PHI2;
 139               		.loc 1 189 5 view .LVU49
 140 003c 8FE7      		ldi r24,lo8(127)
 141               	.LVL9:
 190:bus_access.c  **** 	}
 191:bus_access.c  **** 	BUS_CONTROL_OUT = c;
 142               		.loc 1 191 2 is_stmt 1 view .LVU50
 143               		.loc 1 191 18 is_stmt 0 view .LVU51
 144 003e 85BB      		out 0x15,r24
 192:bus_access.c  **** 	i += 1;
 145               		.loc 1 192 2 is_stmt 1 view .LVU52
 146               		.loc 1 192 4 is_stmt 0 view .LVU53
 147 0040 8091 0000 		lds r24,i.1727
 148               	.LVL10:
 149               		.loc 1 192 4 view .LVU54
 150 0044 8F5F      		subi r24,lo8(-(1))
 151 0046 8093 0000 		sts i.1727,r24
 152               	.LVL11:
 153               	/* epilogue start */
 193:bus_access.c  **** }
 154               		.loc 1 193 1 view .LVU55
 155 004a 0895      		ret
 156               	.LVL12:
 157               	.L8:
 187:bus_access.c  **** 	if(i & 0b100){
 158               		.loc 1 187 10 view .LVU56
 159 004c 8EE7      		ldi r24,lo8(126)
 160               	.LVL13:
 191:bus_access.c  **** 	i += 1;
 161               		.loc 1 191 2 is_stmt 1 view .LVU57
 191:bus_access.c  **** 	i += 1;
 162               		.loc 1 191 18 is_stmt 0 view .LVU58
 163 004e 85BB      		out 0x15,r24
 192:bus_access.c  **** }
 164               		.loc 1 192 2 is_stmt 1 view .LVU59
 192:bus_access.c  **** }
 165               		.loc 1 192 4 is_stmt 0 view .LVU60
 166 0050 8091 0000 		lds r24,i.1727
 167               	.LVL14:
 192:bus_access.c  **** }
 168               		.loc 1 192 4 view .LVU61
 169 0054 8F5F      		subi r24,lo8(-(1))
 170 0056 8093 0000 		sts i.1727,r24
 171               	.LVL15:
 172               	/* epilogue start */
 173               		.loc 1 193 1 view .LVU62
 174 005a 0895      		ret
 175               		.cfi_endproc
 176               	.LFE13:
 178               	.global	cpu_read
 180               	cpu_read:
 181               	.LVL16:
 182               	.LFB16:
 194:bus_access.c  **** static inline void direction_write(void)
 195:bus_access.c  **** {
 196:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_OUT;
 197:bus_access.c  **** 	asm("nop");
 198:bus_access.c  **** 	asm("nop");
 199:bus_access.c  **** 	asm("nop");
 200:bus_access.c  **** }
 201:bus_access.c  **** 
 202:bus_access.c  **** static inline void direction_read(void)
 203:bus_access.c  **** {
 204:bus_access.c  **** 	DATABUS_OUT = 0xff; //when input direction, pullup
 205:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 206:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 207:bus_access.c  **** 	asm("nop");
 208:bus_access.c  **** 	asm("nop");
 209:bus_access.c  **** }
 210:bus_access.c  **** //mmc5 ROM area need that phi2 is high
 211:bus_access.c  **** void cpu_read(uint16_t address, uint16_t length, uint8_t *data)
 212:bus_access.c  **** {
 183               		.loc 1 212 1 is_stmt 1 view -0
 184               		.cfi_startproc
 185               	/* prologue: function */
 186               	/* frame size = 0 */
 187               	/* stack size = 0 */
 188               	.L__stack_usage = 0
 189               		.loc 1 212 1 is_stmt 0 view .LVU64
 190 005c 9C01      		movw r18,r24
 191 005e CB01      		movw r24,r22
 192               	.LVL17:
 193               		.loc 1 212 1 view .LVU65
 194 0060 FA01      		movw r30,r20
 213:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 195               		.loc 1 213 2 is_stmt 1 view .LVU66
 196               		.loc 1 213 18 is_stmt 0 view .LVU67
 197 0062 4EE7      		ldi r20,lo8(126)
 198               	.LVL18:
 199               		.loc 1 213 18 view .LVU68
 200 0064 45BB      		out 0x15,r20
 214:bus_access.c  **** 	while(length != 0){
 201               		.loc 1 214 2 is_stmt 1 view .LVU69
 202               		.loc 1 214 7 view .LVU70
 203 0066 0097      		sbiw r24,0
 204 0068 01F0      		breq .L14
 205 006a B901      		movw r22,r18
 206               	.LVL19:
 207               		.loc 1 214 7 is_stmt 0 view .LVU71
 208 006c 680F      		add r22,r24
 209 006e 791F      		adc r23,r25
 210               	.LBB212:
 211               	.LBB213:
 212               	.LBB214:
 196:bus_access.c  **** 	asm("nop");
 213               		.loc 1 196 14 view .LVU72
 214 0070 8FEF      		ldi r24,lo8(-1)
 215               	.LVL20:
 196:bus_access.c  **** 	asm("nop");
 216               		.loc 1 196 14 view .LVU73
 217               	.LBE214:
 218               	.LBE213:
 219               	.LBB216:
 220               	.LBB217:
 127:bus_access.c  **** }
 221               		.loc 1 127 18 view .LVU74
 222 0072 4EE7      		ldi r20,lo8(126)
 223               	.L13:
 127:bus_access.c  **** }
 224               		.loc 1 127 18 view .LVU75
 225               	.LBE217:
 226               	.LBE216:
 215:bus_access.c  **** 		uint8_t c = BUS_CLOSE;
 227               		.loc 1 215 3 is_stmt 1 view .LVU76
 228               	.LVL21:
 216:bus_access.c  **** 		direction_write();
 229               		.loc 1 216 3 view .LVU77
 230               	.LBB219:
 231               	.LBI213:
 194:bus_access.c  **** {
 232               		.loc 1 194 20 view .LVU78
 233               	.LBB215:
 196:bus_access.c  **** 	asm("nop");
 234               		.loc 1 196 2 view .LVU79
 196:bus_access.c  **** 	asm("nop");
 235               		.loc 1 196 14 is_stmt 0 view .LVU80
 236 0074 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 237               		.loc 1 197 2 is_stmt 1 view .LVU81
 238               	/* #APP */
 239               	 ;  197 "bus_access.c" 1
 240 0076 0000      		nop
 241               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 242               		.loc 1 198 2 view .LVU82
 243               	 ;  198 "bus_access.c" 1
 244 0078 0000      		nop
 245               	 ;  0 "" 2
 199:bus_access.c  **** }
 246               		.loc 1 199 2 view .LVU83
 247               	 ;  199 "bus_access.c" 1
 248 007a 0000      		nop
 249               	 ;  0 "" 2
 250               	/* #NOAPP */
 251               	.LBE215:
 252               	.LBE219:
 217:bus_access.c  **** 		address_set(address);
 253               		.loc 1 217 3 view .LVU84
 254               	.LVL22:
 255               	.LBB220:
 256               	.LBI216:
 117:bus_access.c  **** {
 257               		.loc 1 117 13 view .LVU85
 258               	.LBB218:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 259               		.loc 1 119 2 view .LVU86
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 260               		.loc 1 119 23 is_stmt 0 view .LVU87
 261 007c 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 262               		.loc 1 120 2 is_stmt 1 view .LVU88
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 263               		.loc 1 120 10 is_stmt 0 view .LVU89
 264 007e 932F      		mov r25,r19
 265 0080 9F77      		andi r25,lo8(127)
 266               	.LVL23:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 267               		.loc 1 121 2 is_stmt 1 view .LVU90
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 268               		.loc 1 121 4 is_stmt 0 view .LVU91
 269 0082 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 270               		.loc 1 122 3 is_stmt 1 view .LVU92
 122:bus_access.c  **** 	}
 271               		.loc 1 122 8 is_stmt 0 view .LVU93
 272 0084 9068      		ori r25,lo8(-128)
 273               	.LVL24:
 274               	.L11:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 275               		.loc 1 124 2 is_stmt 1 view .LVU94
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 276               		.loc 1 124 14 is_stmt 0 view .LVU95
 277 0086 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 278               		.loc 1 126 2 is_stmt 1 view .LVU96
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 279               		.loc 1 126 18 is_stmt 0 view .LVU97
 280 0088 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 281               		.loc 1 127 2 is_stmt 1 view .LVU98
 127:bus_access.c  **** }
 282               		.loc 1 127 18 is_stmt 0 view .LVU99
 283 008a 45BB      		out 0x15,r20
 284               	.LVL25:
 127:bus_access.c  **** }
 285               		.loc 1 127 18 view .LVU100
 286               	.LBE218:
 287               	.LBE220:
 218:bus_access.c  **** 		if((address & 0x8000) != 0){
 288               		.loc 1 218 3 is_stmt 1 view .LVU101
 289               		.loc 1 218 5 is_stmt 0 view .LVU102
 290 008c 9DE7      		ldi r25,lo8(125)
 291 008e 37FF      		sbrs r19,7
 292 0090 9FE7      		ldi r25,lo8(127)
 293               	.L12:
 294               	.LVL26:
 219:bus_access.c  **** 			c &= bit_get_negative(CPU_ROMCS);
 220:bus_access.c  **** //			BUS_CONTROL_OUT = c;
 221:bus_access.c  **** //			BUS_CONTROL_OUT = bit_get_negative(CPU_ROMCS);
 222:bus_access.c  **** 		}
 223:bus_access.c  **** 		c |= 1 << CPU_PHI2;
 295               		.loc 1 223 3 is_stmt 1 view .LVU103
 224:bus_access.c  **** 		BUS_CONTROL_OUT = c;
 296               		.loc 1 224 3 view .LVU104
 297               		.loc 1 224 19 is_stmt 0 view .LVU105
 298 0092 95BB      		out 0x15,r25
 225:bus_access.c  **** 		direction_read();
 299               		.loc 1 225 3 is_stmt 1 view .LVU106
 300               	.LBB221:
 301               	.LBI221:
 202:bus_access.c  **** {
 302               		.loc 1 202 20 view .LVU107
 303               	.LBB222:
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 304               		.loc 1 204 2 view .LVU108
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 305               		.loc 1 204 14 is_stmt 0 view .LVU109
 306 0094 88BB      		out 0x18,r24
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 307               		.loc 1 205 2 is_stmt 1 view .LVU110
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 308               		.loc 1 205 14 is_stmt 0 view .LVU111
 309 0096 17BA      		out 0x17,__zero_reg__
 206:bus_access.c  **** 	asm("nop");
 310               		.loc 1 206 2 is_stmt 1 view .LVU112
 311               	/* #APP */
 312               	 ;  206 "bus_access.c" 1
 313 0098 0000      		nop
 314               	 ;  0 "" 2
 207:bus_access.c  **** 	asm("nop");
 315               		.loc 1 207 2 view .LVU113
 316               	 ;  207 "bus_access.c" 1
 317 009a 0000      		nop
 318               	 ;  0 "" 2
 208:bus_access.c  **** }
 319               		.loc 1 208 2 view .LVU114
 320               	 ;  208 "bus_access.c" 1
 321 009c 0000      		nop
 322               	 ;  0 "" 2
 323               	/* #NOAPP */
 324               	.LBE222:
 325               	.LBE221:
 226:bus_access.c  **** 		*data = DATABUS_IN;
 326               		.loc 1 226 3 view .LVU115
 327               		.loc 1 226 11 is_stmt 0 view .LVU116
 328 009e 96B3      		in r25,0x16
 329               		.loc 1 226 9 view .LVU117
 330 00a0 9193      		st Z+,r25
 331               	.LVL27:
 227:bus_access.c  **** 		data += 1;
 332               		.loc 1 227 3 is_stmt 1 view .LVU118
 228:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 333               		.loc 1 228 3 view .LVU119
 334               		.loc 1 228 19 is_stmt 0 view .LVU120
 335 00a2 45BB      		out 0x15,r20
 229:bus_access.c  **** 		address += 1;
 336               		.loc 1 229 3 is_stmt 1 view .LVU121
 337               		.loc 1 229 11 is_stmt 0 view .LVU122
 338 00a4 2F5F      		subi r18,-1
 339 00a6 3F4F      		sbci r19,-1
 340               	.LVL28:
 230:bus_access.c  **** 		length--;
 341               		.loc 1 230 3 is_stmt 1 view .LVU123
 342               		.loc 1 230 3 is_stmt 0 view .LVU124
 343               	.LBE212:
 214:bus_access.c  **** 		uint8_t c = BUS_CLOSE;
 344               		.loc 1 214 7 is_stmt 1 view .LVU125
 345 00a8 2617      		cp r18,r22
 346 00aa 3707      		cpc r19,r23
 347 00ac 01F4      		brne .L13
 348               	.L14:
 231:bus_access.c  **** 	}
 232:bus_access.c  **** 	direction_write();
 349               		.loc 1 232 2 view .LVU126
 350               	.LBB223:
 351               	.LBI223:
 194:bus_access.c  **** {
 352               		.loc 1 194 20 view .LVU127
 353               	.LBB224:
 196:bus_access.c  **** 	asm("nop");
 354               		.loc 1 196 2 view .LVU128
 196:bus_access.c  **** 	asm("nop");
 355               		.loc 1 196 14 is_stmt 0 view .LVU129
 356 00ae 8FEF      		ldi r24,lo8(-1)
 357 00b0 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 358               		.loc 1 197 2 is_stmt 1 view .LVU130
 359               	/* #APP */
 360               	 ;  197 "bus_access.c" 1
 361 00b2 0000      		nop
 362               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 363               		.loc 1 198 2 view .LVU131
 364               	 ;  198 "bus_access.c" 1
 365 00b4 0000      		nop
 366               	 ;  0 "" 2
 199:bus_access.c  **** }
 367               		.loc 1 199 2 view .LVU132
 368               	 ;  199 "bus_access.c" 1
 369 00b6 0000      		nop
 370               	 ;  0 "" 2
 371               	/* #NOAPP */
 372               	/* epilogue start */
 373               	.LBE224:
 374               	.LBE223:
 233:bus_access.c  **** }
 375               		.loc 1 233 1 is_stmt 0 view .LVU133
 376 00b8 0895      		ret
 377               		.cfi_endproc
 378               	.LFE16:
 380               	.global	cpu_read_6502
 382               	cpu_read_6502:
 383               	.LVL29:
 384               	.LFB17:
 234:bus_access.c  **** 
 235:bus_access.c  **** void cpu_read_6502(uint16_t address, uint16_t length, uint8_t *data)
 236:bus_access.c  **** {
 385               		.loc 1 236 1 is_stmt 1 view -0
 386               		.cfi_startproc
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 389               	/* stack size = 0 */
 390               	.L__stack_usage = 0
 391               		.loc 1 236 1 is_stmt 0 view .LVU135
 392 00ba 9C01      		movw r18,r24
 393 00bc CB01      		movw r24,r22
 394               	.LVL30:
 395               		.loc 1 236 1 view .LVU136
 396 00be FA01      		movw r30,r20
 237:bus_access.c  **** 	while(length != 0){
 397               		.loc 1 237 2 is_stmt 1 view .LVU137
 398               		.loc 1 237 7 view .LVU138
 399 00c0 0097      		sbiw r24,0
 400 00c2 01F0      		breq .L19
 401 00c4 B901      		movw r22,r18
 402               	.LVL31:
 403               		.loc 1 237 7 is_stmt 0 view .LVU139
 404 00c6 680F      		add r22,r24
 405 00c8 791F      		adc r23,r25
 406               	.LBB225:
 407               	.LBB226:
 408               	.LBB227:
 196:bus_access.c  **** 	asm("nop");
 409               		.loc 1 196 14 view .LVU140
 410 00ca 9FEF      		ldi r25,lo8(-1)
 411               	.LBE227:
 412               	.LBE226:
 413               	.LBB229:
 414               	.LBB230:
 127:bus_access.c  **** }
 415               		.loc 1 127 18 view .LVU141
 416 00cc 8EE7      		ldi r24,lo8(126)
 417               	.LVL32:
 418               	.L22:
 127:bus_access.c  **** }
 419               		.loc 1 127 18 view .LVU142
 420               	.LBE230:
 421               	.LBE229:
 238:bus_access.c  **** 		//phi2 down
 239:bus_access.c  **** /*		uint8_t c = bit_get_negative(CPU_PHI2);
 240:bus_access.c  **** 		BUS_CONTROL_OUT = c;*/
 241:bus_access.c  **** 		uint8_t c = BUS_CLOSE;
 422               		.loc 1 241 3 is_stmt 1 view .LVU143
 242:bus_access.c  **** 		//down -> up
 243:bus_access.c  **** 		direction_write();
 423               		.loc 1 243 3 view .LVU144
 424               	.LBB232:
 425               	.LBI226:
 194:bus_access.c  **** {
 426               		.loc 1 194 20 view .LVU145
 427               	.LBB228:
 196:bus_access.c  **** 	asm("nop");
 428               		.loc 1 196 2 view .LVU146
 196:bus_access.c  **** 	asm("nop");
 429               		.loc 1 196 14 is_stmt 0 view .LVU147
 430 00ce 97BB      		out 0x17,r25
 197:bus_access.c  **** 	asm("nop");
 431               		.loc 1 197 2 is_stmt 1 view .LVU148
 432               	/* #APP */
 433               	 ;  197 "bus_access.c" 1
 434 00d0 0000      		nop
 435               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 436               		.loc 1 198 2 view .LVU149
 437               	 ;  198 "bus_access.c" 1
 438 00d2 0000      		nop
 439               	 ;  0 "" 2
 199:bus_access.c  **** }
 440               		.loc 1 199 2 view .LVU150
 441               	 ;  199 "bus_access.c" 1
 442 00d4 0000      		nop
 443               	 ;  0 "" 2
 444               	/* #NOAPP */
 445               	.LBE228:
 446               	.LBE232:
 244:bus_access.c  **** 		address_set(address);
 447               		.loc 1 244 3 view .LVU151
 448               	.LVL33:
 449               	.LBB233:
 450               	.LBI229:
 117:bus_access.c  **** {
 451               		.loc 1 117 13 view .LVU152
 452               	.LBB231:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 453               		.loc 1 119 2 view .LVU153
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 454               		.loc 1 119 23 is_stmt 0 view .LVU154
 455 00d6 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 456               		.loc 1 120 2 is_stmt 1 view .LVU155
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 457               		.loc 1 120 10 is_stmt 0 view .LVU156
 458 00d8 432F      		mov r20,r19
 459 00da 4F77      		andi r20,lo8(127)
 460               	.LVL34:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 461               		.loc 1 121 2 is_stmt 1 view .LVU157
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 462               		.loc 1 121 4 is_stmt 0 view .LVU158
 463 00dc 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 464               		.loc 1 122 3 is_stmt 1 view .LVU159
 122:bus_access.c  **** 	}
 465               		.loc 1 122 8 is_stmt 0 view .LVU160
 466 00de 4068      		ori r20,lo8(-128)
 467               	.LVL35:
 468               	.L20:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 469               		.loc 1 124 2 is_stmt 1 view .LVU161
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 470               		.loc 1 124 14 is_stmt 0 view .LVU162
 471 00e0 48BB      		out 0x18,r20
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 472               		.loc 1 126 2 is_stmt 1 view .LVU163
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 473               		.loc 1 126 18 is_stmt 0 view .LVU164
 474 00e2 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 475               		.loc 1 127 2 is_stmt 1 view .LVU165
 127:bus_access.c  **** }
 476               		.loc 1 127 18 is_stmt 0 view .LVU166
 477 00e4 85BB      		out 0x15,r24
 478               	.LVL36:
 127:bus_access.c  **** }
 479               		.loc 1 127 18 view .LVU167
 480               	.LBE231:
 481               	.LBE233:
 245:bus_access.c  **** 		BUS_CONTROL_OUT = c;
 482               		.loc 1 245 3 is_stmt 1 view .LVU168
 483               		.loc 1 245 19 is_stmt 0 view .LVU169
 484 00e6 85BB      		out 0x15,r24
 246:bus_access.c  **** 		clock_wait(1);
 485               		.loc 1 246 3 is_stmt 1 view .LVU170
 486               	.LVL37:
 487               	.LBB234:
 488               	.LBI234:
 489               		.file 2 "bus_access.h"
   1:bus_access.h  **** #ifndef _BUS_ACCESS_H_
   2:bus_access.h  **** #define _BUS_ACCESS_H_
   3:bus_access.h  **** void bus_init(void);
   4:bus_access.h  **** void phi2_init(void);
   5:bus_access.h  **** void phi2_update(void);
   6:bus_access.h  **** void cpu_read(uint16_t address, uint16_t length, uint8_t *data);
   7:bus_access.h  **** void cpu_read_6502(uint16_t address, uint16_t length, uint8_t *data);
   8:bus_access.h  **** void ppu_read(uint16_t address, uint16_t length, uint8_t *data);
   9:bus_access.h  **** void cpu_write_6502(uint16_t address, uint16_t length, const uint8_t *data);
  10:bus_access.h  **** void cpu_write_flash(uint16_t address, uint16_t length, const uint8_t *data);
  11:bus_access.h  **** void ppu_write(uint16_t address, uint16_t length, const uint8_t *data);
  12:bus_access.h  **** 
  13:bus_access.h  **** enum compare_status{
  14:bus_access.h  **** 	OK, NG
  15:bus_access.h  **** };
  16:bus_access.h  **** enum compare_status cpu_compare(uint16_t address, uint16_t length, const uint8_t *data);
  17:bus_access.h  **** enum compare_status ppu_compare(uint16_t address, uint16_t length, const uint8_t *data);
  18:bus_access.h  **** enum{
  19:bus_access.h  **** 	FLASH_PROGRAM_ORDER = 3
  20:bus_access.h  **** };
  21:bus_access.h  **** struct flash_order{
  22:bus_access.h  **** 	uint16_t address;
  23:bus_access.h  **** 	uint8_t data;
  24:bus_access.h  **** };
  25:bus_access.h  **** void cpu_write_flash_order(const struct flash_order *t);
  26:bus_access.h  **** void ppu_write_order(const struct flash_order *t);
  27:bus_access.h  **** uint8_t vram_connection_get(void);
  28:bus_access.h  **** 
  29:bus_access.h  **** void mcu_programdata_read(uint16_t address, uint16_t length, uint8_t *data);
  30:bus_access.h  **** 
  31:bus_access.h  **** #include <util/delay.h>
  32:bus_access.h  **** static inline void clock_wait(double clock)
 490               		.loc 2 32 20 view .LVU171
 491               	.LBE234:
 492               	.LBE225:
  33:bus_access.h  **** {
  34:bus_access.h  **** 	_delay_us(clock * 0.55);
 493               		.loc 2 34 2 view .LVU172
 494               	.LBB244:
 495               	.LBB237:
 496               	.LBB235:
 497               	.LBI235:
 498               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 499               		.loc 3 255 1 view .LVU173
 500               	.LBB236:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 501               		.loc 3 257 2 view .LVU174
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 502               		.loc 3 261 2 view .LVU175
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 503               		.loc 3 262 2 view .LVU176
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 504               		.loc 3 263 2 view .LVU177
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 505               		.loc 3 273 3 view .LVU178
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 506               		.loc 3 276 2 view .LVU179
 507 00e8 43E0      		ldi r20,lo8(3)
 508 00ea 4A95      	1:	dec r20
 509 00ec 01F4      		brne 1b
 510               	.LVL38:
 511               		.loc 3 276 2 is_stmt 0 view .LVU180
 512               	.LBE236:
 513               	.LBE235:
 514               	.LBE237:
 247:bus_access.c  **** 		
 248:bus_access.c  **** 		//phi2 up
 249:bus_access.c  **** 		c |= (1 << CPU_PHI2);
 515               		.loc 1 249 3 is_stmt 1 view .LVU181
 250:bus_access.c  **** 		if((address & 0x8000) != 0){
 516               		.loc 1 250 3 view .LVU182
 251:bus_access.c  **** 			c &= bit_get_negative(CPU_ROMCS);
 517               		.loc 1 251 6 is_stmt 0 view .LVU183
 518 00ee 4DE7      		ldi r20,lo8(125)
 250:bus_access.c  **** 		if((address & 0x8000) != 0){
 519               		.loc 1 250 5 view .LVU184
 520 00f0 37FF      		sbrs r19,7
 249:bus_access.c  **** 		if((address & 0x8000) != 0){
 521               		.loc 1 249 5 view .LVU185
 522 00f2 4FE7      		ldi r20,lo8(127)
 523               	.L21:
 524               	.LVL39:
 252:bus_access.c  **** 		}
 253:bus_access.c  **** 		BUS_CONTROL_OUT = c;
 525               		.loc 1 253 3 is_stmt 1 view .LVU186
 526               		.loc 1 253 19 is_stmt 0 view .LVU187
 527 00f4 45BB      		out 0x15,r20
 254:bus_access.c  **** 		direction_read();
 528               		.loc 1 254 3 is_stmt 1 view .LVU188
 529               	.LBB238:
 530               	.LBI238:
 202:bus_access.c  **** {
 531               		.loc 1 202 20 view .LVU189
 532               	.LBB239:
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 533               		.loc 1 204 2 view .LVU190
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 534               		.loc 1 204 14 is_stmt 0 view .LVU191
 535 00f6 98BB      		out 0x18,r25
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 536               		.loc 1 205 2 is_stmt 1 view .LVU192
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 537               		.loc 1 205 14 is_stmt 0 view .LVU193
 538 00f8 17BA      		out 0x17,__zero_reg__
 206:bus_access.c  **** 	asm("nop");
 539               		.loc 1 206 2 is_stmt 1 view .LVU194
 540               	/* #APP */
 541               	 ;  206 "bus_access.c" 1
 542 00fa 0000      		nop
 543               	 ;  0 "" 2
 207:bus_access.c  **** 	asm("nop");
 544               		.loc 1 207 2 view .LVU195
 545               	 ;  207 "bus_access.c" 1
 546 00fc 0000      		nop
 547               	 ;  0 "" 2
 208:bus_access.c  **** }
 548               		.loc 1 208 2 view .LVU196
 549               	 ;  208 "bus_access.c" 1
 550 00fe 0000      		nop
 551               	 ;  0 "" 2
 552               	/* #NOAPP */
 553               	.LBE239:
 554               	.LBE238:
 255:bus_access.c  **** 		clock_wait(1);
 555               		.loc 1 255 3 view .LVU197
 556               	.LVL40:
 557               	.LBB240:
 558               	.LBI240:
  32:bus_access.h  **** {
 559               		.loc 2 32 20 view .LVU198
 560               	.LBE240:
 561               	.LBE244:
 562               		.loc 2 34 2 view .LVU199
 563               	.LBB245:
 564               	.LBB243:
 565               	.LBB241:
 566               	.LBI241:
 255:/usr/avr/include/util/delay.h **** {
 567               		.loc 3 255 1 view .LVU200
 568               	.LBB242:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 569               		.loc 3 257 2 view .LVU201
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 570               		.loc 3 261 2 view .LVU202
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 571               		.loc 3 262 2 view .LVU203
 263:/usr/avr/include/util/delay.h **** 
 572               		.loc 3 263 2 view .LVU204
 273:/usr/avr/include/util/delay.h **** 	#endif
 573               		.loc 3 273 3 view .LVU205
 574               		.loc 3 276 2 view .LVU206
 575 0100 53E0      		ldi r21,lo8(3)
 576 0102 5A95      	1:	dec r21
 577 0104 01F4      		brne 1b
 578               	.LVL41:
 579               		.loc 3 276 2 is_stmt 0 view .LVU207
 580               	.LBE242:
 581               	.LBE241:
 582               	.LBE243:
 256:bus_access.c  **** 		*data = DATABUS_IN;
 583               		.loc 1 256 3 is_stmt 1 view .LVU208
 584               		.loc 1 256 11 is_stmt 0 view .LVU209
 585 0106 56B3      		in r21,0x16
 586               		.loc 1 256 9 view .LVU210
 587 0108 5193      		st Z+,r21
 588               	.LVL42:
 257:bus_access.c  **** 		data += 1;
 589               		.loc 1 257 3 is_stmt 1 view .LVU211
 258:bus_access.c  **** 
 259:bus_access.c  **** 		BUS_CONTROL_OUT = c;
 590               		.loc 1 259 3 view .LVU212
 591               		.loc 1 259 19 is_stmt 0 view .LVU213
 592 010a 45BB      		out 0x15,r20
 260:bus_access.c  **** 		
 261:bus_access.c  **** 		//phi2 down, bus close
 262:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 593               		.loc 1 262 3 is_stmt 1 view .LVU214
 594               		.loc 1 262 19 is_stmt 0 view .LVU215
 595 010c 85BB      		out 0x15,r24
 263:bus_access.c  **** 		
 264:bus_access.c  **** 		address += 1;
 596               		.loc 1 264 3 is_stmt 1 view .LVU216
 597               		.loc 1 264 11 is_stmt 0 view .LVU217
 598 010e 2F5F      		subi r18,-1
 599 0110 3F4F      		sbci r19,-1
 600               	.LVL43:
 265:bus_access.c  **** 		length--;
 601               		.loc 1 265 3 is_stmt 1 view .LVU218
 602               		.loc 1 265 3 is_stmt 0 view .LVU219
 603               	.LBE245:
 237:bus_access.c  **** 		//phi2 down
 604               		.loc 1 237 7 is_stmt 1 view .LVU220
 605 0112 6217      		cp r22,r18
 606 0114 7307      		cpc r23,r19
 607 0116 01F4      		brne .L22
 608               	.LVL44:
 609               	.L19:
 266:bus_access.c  **** 	}
 267:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
 610               		.loc 1 267 2 view .LVU221
 611               	.LBB246:
 612               	.LBI246:
 117:bus_access.c  **** {
 613               		.loc 1 117 13 view .LVU222
 614               	.LBB247:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 615               		.loc 1 119 2 view .LVU223
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 616               		.loc 1 119 23 is_stmt 0 view .LVU224
 617 0118 8FEF      		ldi r24,lo8(-1)
 618 011a 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 619               		.loc 1 120 2 is_stmt 1 view .LVU225
 620               	.LVL45:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 621               		.loc 1 121 2 view .LVU226
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 622               		.loc 1 124 2 view .LVU227
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 623               		.loc 1 124 14 is_stmt 0 view .LVU228
 624 011c 9FE3      		ldi r25,lo8(63)
 625 011e 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 626               		.loc 1 126 2 is_stmt 1 view .LVU229
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 627               		.loc 1 126 18 is_stmt 0 view .LVU230
 628 0120 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 629               		.loc 1 127 2 is_stmt 1 view .LVU231
 127:bus_access.c  **** }
 630               		.loc 1 127 18 is_stmt 0 view .LVU232
 631 0122 8EE7      		ldi r24,lo8(126)
 632 0124 85BB      		out 0x15,r24
 633               	.LVL46:
 634               	/* epilogue start */
 127:bus_access.c  **** }
 635               		.loc 1 127 18 view .LVU233
 636               	.LBE247:
 637               	.LBE246:
 268:bus_access.c  **** }
 638               		.loc 1 268 1 view .LVU234
 639 0126 0895      		ret
 640               		.cfi_endproc
 641               	.LFE17:
 643               	.global	ppu_read
 645               	ppu_read:
 646               	.LVL47:
 647               	.LFB18:
 269:bus_access.c  **** 
 270:bus_access.c  **** void ppu_read(uint16_t address, uint16_t length, uint8_t *data)
 271:bus_access.c  **** {
 648               		.loc 1 271 1 is_stmt 1 view -0
 649               		.cfi_startproc
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 652               	/* stack size = 0 */
 653               	.L__stack_usage = 0
 654               		.loc 1 271 1 is_stmt 0 view .LVU236
 655 0128 9C01      		movw r18,r24
 656 012a CB01      		movw r24,r22
 657               	.LVL48:
 658               		.loc 1 271 1 view .LVU237
 659 012c FA01      		movw r30,r20
 272:bus_access.c  **** 	//BUS_CONTROL_OUT = BUS_CLOSE;
 273:bus_access.c  **** 	while(length != 0){
 660               		.loc 1 273 2 is_stmt 1 view .LVU238
 661               		.loc 1 273 7 view .LVU239
 662 012e 0097      		sbiw r24,0
 663 0130 01F0      		breq .L29
 664 0132 BA01      		movw r22,r20
 665               	.LVL49:
 666               		.loc 1 273 7 is_stmt 0 view .LVU240
 667 0134 680F      		add r22,r24
 668 0136 791F      		adc r23,r25
 669               	.LBB248:
 670               	.LBB249:
 196:bus_access.c  **** 	asm("nop");
 671               		.loc 1 196 14 view .LVU241
 672 0138 8FEF      		ldi r24,lo8(-1)
 673               	.LVL50:
 196:bus_access.c  **** 	asm("nop");
 674               		.loc 1 196 14 view .LVU242
 675               	.LBE249:
 676               	.LBE248:
 677               	.LBB251:
 678               	.LBB252:
 127:bus_access.c  **** }
 679               		.loc 1 127 18 view .LVU243
 680 013a 4EE7      		ldi r20,lo8(126)
 681               	.LVL51:
 127:bus_access.c  **** }
 682               		.loc 1 127 18 view .LVU244
 683               	.LBE252:
 684               	.LBE251:
 274:bus_access.c  **** 		direction_write();
 275:bus_access.c  **** 		address_set(address);
 276:bus_access.c  **** #if PCB_REVISION == 1
 277:bus_access.c  **** 		BUS_CONTROL_OUT = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(PPU_RD) & bit_get_negat
 685               		.loc 1 277 19 view .LVU245
 686 013c 5EE6      		ldi r21,lo8(110)
 687               	.L31:
 274:bus_access.c  **** 		direction_write();
 688               		.loc 1 274 3 is_stmt 1 view .LVU246
 689               	.LBB254:
 690               	.LBI248:
 194:bus_access.c  **** {
 691               		.loc 1 194 20 view .LVU247
 692               	.LBB250:
 196:bus_access.c  **** 	asm("nop");
 693               		.loc 1 196 2 view .LVU248
 196:bus_access.c  **** 	asm("nop");
 694               		.loc 1 196 14 is_stmt 0 view .LVU249
 695 013e 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 696               		.loc 1 197 2 is_stmt 1 view .LVU250
 697               	/* #APP */
 698               	 ;  197 "bus_access.c" 1
 699 0140 0000      		nop
 700               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 701               		.loc 1 198 2 view .LVU251
 702               	 ;  198 "bus_access.c" 1
 703 0142 0000      		nop
 704               	 ;  0 "" 2
 199:bus_access.c  **** }
 705               		.loc 1 199 2 view .LVU252
 706               	 ;  199 "bus_access.c" 1
 707 0144 0000      		nop
 708               	 ;  0 "" 2
 709               	/* #NOAPP */
 710               	.LBE250:
 711               	.LBE254:
 275:bus_access.c  **** #if PCB_REVISION == 1
 712               		.loc 1 275 3 view .LVU253
 713               	.LVL52:
 714               	.LBB255:
 715               	.LBI251:
 117:bus_access.c  **** {
 716               		.loc 1 117 13 view .LVU254
 717               	.LBB253:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 718               		.loc 1 119 2 view .LVU255
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 719               		.loc 1 119 23 is_stmt 0 view .LVU256
 720 0146 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 721               		.loc 1 120 2 is_stmt 1 view .LVU257
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 722               		.loc 1 120 10 is_stmt 0 view .LVU258
 723 0148 932F      		mov r25,r19
 724 014a 9F77      		andi r25,lo8(127)
 725               	.LVL53:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 726               		.loc 1 121 2 is_stmt 1 view .LVU259
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 727               		.loc 1 121 4 is_stmt 0 view .LVU260
 728 014c 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 729               		.loc 1 122 3 is_stmt 1 view .LVU261
 122:bus_access.c  **** 	}
 730               		.loc 1 122 8 is_stmt 0 view .LVU262
 731 014e 9068      		ori r25,lo8(-128)
 732               	.LVL54:
 733               	.L30:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 734               		.loc 1 124 2 is_stmt 1 view .LVU263
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 735               		.loc 1 124 14 is_stmt 0 view .LVU264
 736 0150 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 737               		.loc 1 126 2 is_stmt 1 view .LVU265
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 738               		.loc 1 126 18 is_stmt 0 view .LVU266
 739 0152 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 740               		.loc 1 127 2 is_stmt 1 view .LVU267
 127:bus_access.c  **** }
 741               		.loc 1 127 18 is_stmt 0 view .LVU268
 742 0154 45BB      		out 0x15,r20
 743               	.LVL55:
 127:bus_access.c  **** }
 744               		.loc 1 127 18 view .LVU269
 745               	.LBE253:
 746               	.LBE255:
 747               		.loc 1 277 3 is_stmt 1 view .LVU270
 106:bus_access.c  **** 	return ~ret;
 748               		.loc 1 106 2 view .LVU271
 107:bus_access.c  **** }
 749               		.loc 1 107 2 view .LVU272
 106:bus_access.c  **** 	return ~ret;
 750               		.loc 1 106 2 view .LVU273
 107:bus_access.c  **** }
 751               		.loc 1 107 2 view .LVU274
 106:bus_access.c  **** 	return ~ret;
 752               		.loc 1 106 2 view .LVU275
 107:bus_access.c  **** }
 753               		.loc 1 107 2 view .LVU276
 754               		.loc 1 277 19 is_stmt 0 view .LVU277
 755 0156 55BB      		out 0x15,r21
 278:bus_access.c  **** #endif
 279:bus_access.c  **** #if PCB_REVISION == 2
 280:bus_access.c  **** 		BUS_CONTROL_OUT = bit_get_negative(PPU_RD) & bit_get_negative(CPU_PHI2);
 281:bus_access.c  **** #endif
 282:bus_access.c  **** 		direction_read();
 756               		.loc 1 282 3 is_stmt 1 view .LVU278
 757               	.LBB256:
 758               	.LBI256:
 202:bus_access.c  **** {
 759               		.loc 1 202 20 view .LVU279
 760               	.LBB257:
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 761               		.loc 1 204 2 view .LVU280
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 762               		.loc 1 204 14 is_stmt 0 view .LVU281
 763 0158 88BB      		out 0x18,r24
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 764               		.loc 1 205 2 is_stmt 1 view .LVU282
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 765               		.loc 1 205 14 is_stmt 0 view .LVU283
 766 015a 17BA      		out 0x17,__zero_reg__
 206:bus_access.c  **** 	asm("nop");
 767               		.loc 1 206 2 is_stmt 1 view .LVU284
 768               	/* #APP */
 769               	 ;  206 "bus_access.c" 1
 770 015c 0000      		nop
 771               	 ;  0 "" 2
 207:bus_access.c  **** 	asm("nop");
 772               		.loc 1 207 2 view .LVU285
 773               	 ;  207 "bus_access.c" 1
 774 015e 0000      		nop
 775               	 ;  0 "" 2
 208:bus_access.c  **** }
 776               		.loc 1 208 2 view .LVU286
 777               	 ;  208 "bus_access.c" 1
 778 0160 0000      		nop
 779               	 ;  0 "" 2
 780               	/* #NOAPP */
 781               	.LBE257:
 782               	.LBE256:
 283:bus_access.c  **** 		*data = DATABUS_IN;
 783               		.loc 1 283 3 view .LVU287
 784               		.loc 1 283 11 is_stmt 0 view .LVU288
 785 0162 96B3      		in r25,0x16
 786               		.loc 1 283 9 view .LVU289
 787 0164 9193      		st Z+,r25
 788               	.LVL56:
 284:bus_access.c  **** 		data += 1;
 789               		.loc 1 284 3 is_stmt 1 view .LVU290
 285:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 790               		.loc 1 285 3 view .LVU291
 791               		.loc 1 285 19 is_stmt 0 view .LVU292
 792 0166 45BB      		out 0x15,r20
 286:bus_access.c  **** 		address += 1;
 793               		.loc 1 286 3 is_stmt 1 view .LVU293
 794               		.loc 1 286 11 is_stmt 0 view .LVU294
 795 0168 2F5F      		subi r18,-1
 796 016a 3F4F      		sbci r19,-1
 797               	.LVL57:
 287:bus_access.c  **** 		length--;
 798               		.loc 1 287 3 is_stmt 1 view .LVU295
 273:bus_access.c  **** 		direction_write();
 799               		.loc 1 273 7 view .LVU296
 800 016c 6E17      		cp r22,r30
 801 016e 7F07      		cpc r23,r31
 802 0170 01F4      		brne .L31
 803               	.L29:
 288:bus_access.c  **** 	}
 289:bus_access.c  **** 	direction_write();
 804               		.loc 1 289 2 view .LVU297
 805               	.LBB258:
 806               	.LBI258:
 194:bus_access.c  **** {
 807               		.loc 1 194 20 view .LVU298
 808               	.LBB259:
 196:bus_access.c  **** 	asm("nop");
 809               		.loc 1 196 2 view .LVU299
 196:bus_access.c  **** 	asm("nop");
 810               		.loc 1 196 14 is_stmt 0 view .LVU300
 811 0172 8FEF      		ldi r24,lo8(-1)
 812 0174 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 813               		.loc 1 197 2 is_stmt 1 view .LVU301
 814               	/* #APP */
 815               	 ;  197 "bus_access.c" 1
 816 0176 0000      		nop
 817               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 818               		.loc 1 198 2 view .LVU302
 819               	 ;  198 "bus_access.c" 1
 820 0178 0000      		nop
 821               	 ;  0 "" 2
 199:bus_access.c  **** }
 822               		.loc 1 199 2 view .LVU303
 823               	 ;  199 "bus_access.c" 1
 824 017a 0000      		nop
 825               	 ;  0 "" 2
 826               	/* #NOAPP */
 827               	/* epilogue start */
 828               	.LBE259:
 829               	.LBE258:
 290:bus_access.c  **** }
 830               		.loc 1 290 1 is_stmt 0 view .LVU304
 831 017c 0895      		ret
 832               		.cfi_endproc
 833               	.LFE18:
 835               	.global	cpu_compare
 837               	cpu_compare:
 838               	.LVL58:
 839               	.LFB19:
 291:bus_access.c  **** 
 292:bus_access.c  **** enum compare_status cpu_compare(uint16_t address, uint16_t length, const uint8_t *data)
 293:bus_access.c  **** {
 840               		.loc 1 293 1 is_stmt 1 view -0
 841               		.cfi_startproc
 842               	/* prologue: function */
 843               	/* frame size = 0 */
 844               	/* stack size = 0 */
 845               	.L__stack_usage = 0
 846               		.loc 1 293 1 is_stmt 0 view .LVU306
 847 017e 9C01      		movw r18,r24
 848 0180 CB01      		movw r24,r22
 849               	.LVL59:
 294:bus_access.c  **** 	while(length != 0){
 850               		.loc 1 294 2 is_stmt 1 view .LVU307
 851               		.loc 1 294 7 view .LVU308
 852 0182 0097      		sbiw r24,0
 853 0184 01F0      		breq .L37
 854 0186 FA01      		movw r30,r20
 855 0188 B901      		movw r22,r18
 856               	.LVL60:
 857               		.loc 1 294 7 is_stmt 0 view .LVU309
 858 018a 680F      		add r22,r24
 859 018c 791F      		adc r23,r25
 295:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 860               		.loc 1 295 19 view .LVU310
 861 018e 4EE7      		ldi r20,lo8(126)
 862               	.LVL61:
 863               	.LBB260:
 864               	.LBB261:
 196:bus_access.c  **** 	asm("nop");
 865               		.loc 1 196 14 view .LVU311
 866 0190 8FEF      		ldi r24,lo8(-1)
 867               	.LVL62:
 196:bus_access.c  **** 	asm("nop");
 868               		.loc 1 196 14 view .LVU312
 869               	.LBE261:
 870               	.LBE260:
 296:bus_access.c  **** 		direction_write();
 297:bus_access.c  **** 		address_set(address);
 298:bus_access.c  **** #if PCB_REVISION == 1
 299:bus_access.c  **** 		BUS_CONTROL_OUT = (bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(CPU_ROMCS)) | (1 << CP
 871               		.loc 1 299 19 view .LVU313
 872 0192 ADE7      		ldi r26,lo8(125)
 873 0194 00C0      		rjmp .L41
 874               	.LVL63:
 875               	.L39:
 300:bus_access.c  **** #endif
 301:bus_access.c  **** #if PCB_REVISION == 2
 302:bus_access.c  **** 		BUS_CONTROL_OUT = (bit_get_negative(CPU_ROMCS) | (1 << CPU_PHI2);
 303:bus_access.c  **** #endif
 304:bus_access.c  **** 		direction_read();
 305:bus_access.c  **** 		if(DATABUS_IN != *data){
 306:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 307:bus_access.c  **** 			direction_write();
 308:bus_access.c  **** 			return NG;
 309:bus_access.c  **** 		}
 310:bus_access.c  **** 		data += 1;
 876               		.loc 1 310 3 is_stmt 1 view .LVU314
 311:bus_access.c  **** 		address += 1;
 877               		.loc 1 311 3 view .LVU315
 878               		.loc 1 311 11 is_stmt 0 view .LVU316
 879 0196 2F5F      		subi r18,-1
 880 0198 3F4F      		sbci r19,-1
 881               	.LVL64:
 312:bus_access.c  **** 		length--;
 882               		.loc 1 312 3 is_stmt 1 view .LVU317
 294:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 883               		.loc 1 294 7 view .LVU318
 884 019a 6217      		cp r22,r18
 885 019c 7307      		cpc r23,r19
 886 019e 01F0      		breq .L37
 887               	.LVL65:
 888               	.L41:
 295:bus_access.c  **** 		direction_write();
 889               		.loc 1 295 3 view .LVU319
 295:bus_access.c  **** 		direction_write();
 890               		.loc 1 295 19 is_stmt 0 view .LVU320
 891 01a0 45BB      		out 0x15,r20
 296:bus_access.c  **** 		address_set(address);
 892               		.loc 1 296 3 is_stmt 1 view .LVU321
 893               	.LBB263:
 894               	.LBI260:
 194:bus_access.c  **** {
 895               		.loc 1 194 20 view .LVU322
 896               	.LBB262:
 196:bus_access.c  **** 	asm("nop");
 897               		.loc 1 196 2 view .LVU323
 196:bus_access.c  **** 	asm("nop");
 898               		.loc 1 196 14 is_stmt 0 view .LVU324
 899 01a2 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 900               		.loc 1 197 2 is_stmt 1 view .LVU325
 901               	/* #APP */
 902               	 ;  197 "bus_access.c" 1
 903 01a4 0000      		nop
 904               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 905               		.loc 1 198 2 view .LVU326
 906               	 ;  198 "bus_access.c" 1
 907 01a6 0000      		nop
 908               	 ;  0 "" 2
 199:bus_access.c  **** }
 909               		.loc 1 199 2 view .LVU327
 910               	 ;  199 "bus_access.c" 1
 911 01a8 0000      		nop
 912               	 ;  0 "" 2
 913               	/* #NOAPP */
 914               	.LBE262:
 915               	.LBE263:
 297:bus_access.c  **** #if PCB_REVISION == 1
 916               		.loc 1 297 3 view .LVU328
 917               	.LVL66:
 918               	.LBB264:
 919               	.LBI264:
 117:bus_access.c  **** {
 920               		.loc 1 117 13 view .LVU329
 921               	.LBB265:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 922               		.loc 1 119 2 view .LVU330
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 923               		.loc 1 119 23 is_stmt 0 view .LVU331
 924 01aa 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 925               		.loc 1 120 2 is_stmt 1 view .LVU332
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 926               		.loc 1 120 10 is_stmt 0 view .LVU333
 927 01ac 932F      		mov r25,r19
 928 01ae 9F77      		andi r25,lo8(127)
 929               	.LVL67:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 930               		.loc 1 121 2 is_stmt 1 view .LVU334
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 931               		.loc 1 121 4 is_stmt 0 view .LVU335
 932 01b0 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 933               		.loc 1 122 3 is_stmt 1 view .LVU336
 122:bus_access.c  **** 	}
 934               		.loc 1 122 8 is_stmt 0 view .LVU337
 935 01b2 9068      		ori r25,lo8(-128)
 936               	.LVL68:
 937               	.L38:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 938               		.loc 1 124 2 is_stmt 1 view .LVU338
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 939               		.loc 1 124 14 is_stmt 0 view .LVU339
 940 01b4 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 941               		.loc 1 126 2 is_stmt 1 view .LVU340
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 942               		.loc 1 126 18 is_stmt 0 view .LVU341
 943 01b6 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 944               		.loc 1 127 2 is_stmt 1 view .LVU342
 127:bus_access.c  **** }
 945               		.loc 1 127 18 is_stmt 0 view .LVU343
 946 01b8 45BB      		out 0x15,r20
 947               	.LVL69:
 127:bus_access.c  **** }
 948               		.loc 1 127 18 view .LVU344
 949               	.LBE265:
 950               	.LBE264:
 299:bus_access.c  **** #endif
 951               		.loc 1 299 3 is_stmt 1 view .LVU345
 106:bus_access.c  **** 	return ~ret;
 952               		.loc 1 106 2 view .LVU346
 107:bus_access.c  **** }
 953               		.loc 1 107 2 view .LVU347
 106:bus_access.c  **** 	return ~ret;
 954               		.loc 1 106 2 view .LVU348
 107:bus_access.c  **** }
 955               		.loc 1 107 2 view .LVU349
 299:bus_access.c  **** #endif
 956               		.loc 1 299 19 is_stmt 0 view .LVU350
 957 01ba A5BB      		out 0x15,r26
 304:bus_access.c  **** 		if(DATABUS_IN != *data){
 958               		.loc 1 304 3 is_stmt 1 view .LVU351
 959               	.LBB266:
 960               	.LBI266:
 202:bus_access.c  **** {
 961               		.loc 1 202 20 view .LVU352
 962               	.LBB267:
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 963               		.loc 1 204 2 view .LVU353
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 964               		.loc 1 204 14 is_stmt 0 view .LVU354
 965 01bc 88BB      		out 0x18,r24
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 966               		.loc 1 205 2 is_stmt 1 view .LVU355
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 967               		.loc 1 205 14 is_stmt 0 view .LVU356
 968 01be 17BA      		out 0x17,__zero_reg__
 206:bus_access.c  **** 	asm("nop");
 969               		.loc 1 206 2 is_stmt 1 view .LVU357
 970               	/* #APP */
 971               	 ;  206 "bus_access.c" 1
 972 01c0 0000      		nop
 973               	 ;  0 "" 2
 207:bus_access.c  **** 	asm("nop");
 974               		.loc 1 207 2 view .LVU358
 975               	 ;  207 "bus_access.c" 1
 976 01c2 0000      		nop
 977               	 ;  0 "" 2
 208:bus_access.c  **** }
 978               		.loc 1 208 2 view .LVU359
 979               	 ;  208 "bus_access.c" 1
 980 01c4 0000      		nop
 981               	 ;  0 "" 2
 982               	/* #NOAPP */
 983               	.LBE267:
 984               	.LBE266:
 305:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 985               		.loc 1 305 3 view .LVU360
 305:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 986               		.loc 1 305 6 is_stmt 0 view .LVU361
 987 01c6 56B3      		in r21,0x16
 305:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 988               		.loc 1 305 17 view .LVU362
 989 01c8 9191      		ld r25,Z+
 305:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 990               		.loc 1 305 5 view .LVU363
 991 01ca 5917      		cp r21,r25
 992 01cc 01F0      		breq .L39
 306:bus_access.c  **** 			direction_write();
 993               		.loc 1 306 4 is_stmt 1 view .LVU364
 306:bus_access.c  **** 			direction_write();
 994               		.loc 1 306 20 is_stmt 0 view .LVU365
 995 01ce 45BB      		out 0x15,r20
 307:bus_access.c  **** 			return NG;
 996               		.loc 1 307 4 is_stmt 1 view .LVU366
 997               	.LBB268:
 998               	.LBI268:
 194:bus_access.c  **** {
 999               		.loc 1 194 20 view .LVU367
 1000               	.LBB269:
 196:bus_access.c  **** 	asm("nop");
 1001               		.loc 1 196 2 view .LVU368
 196:bus_access.c  **** 	asm("nop");
 1002               		.loc 1 196 14 is_stmt 0 view .LVU369
 1003 01d0 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 1004               		.loc 1 197 2 is_stmt 1 view .LVU370
 1005               	/* #APP */
 1006               	 ;  197 "bus_access.c" 1
 1007 01d2 0000      		nop
 1008               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1009               		.loc 1 198 2 view .LVU371
 1010               	 ;  198 "bus_access.c" 1
 1011 01d4 0000      		nop
 1012               	 ;  0 "" 2
 199:bus_access.c  **** }
 1013               		.loc 1 199 2 view .LVU372
 1014               	 ;  199 "bus_access.c" 1
 1015 01d6 0000      		nop
 1016               	 ;  0 "" 2
 1017               	/* #NOAPP */
 1018               	.LBE269:
 1019               	.LBE268:
 308:bus_access.c  **** 		}
 1020               		.loc 1 308 4 view .LVU373
 308:bus_access.c  **** 		}
 1021               		.loc 1 308 11 is_stmt 0 view .LVU374
 1022 01d8 81E0      		ldi r24,lo8(1)
 1023 01da 0895      		ret
 1024               	.LVL70:
 1025               	.L37:
 313:bus_access.c  **** 	}
 314:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1026               		.loc 1 314 2 is_stmt 1 view .LVU375
 1027               		.loc 1 314 18 is_stmt 0 view .LVU376
 1028 01dc 8EE7      		ldi r24,lo8(126)
 1029 01de 85BB      		out 0x15,r24
 315:bus_access.c  **** 	direction_write();
 1030               		.loc 1 315 2 is_stmt 1 view .LVU377
 1031               	.LBB270:
 1032               	.LBI270:
 194:bus_access.c  **** {
 1033               		.loc 1 194 20 view .LVU378
 1034               	.LBB271:
 196:bus_access.c  **** 	asm("nop");
 1035               		.loc 1 196 2 view .LVU379
 196:bus_access.c  **** 	asm("nop");
 1036               		.loc 1 196 14 is_stmt 0 view .LVU380
 1037 01e0 8FEF      		ldi r24,lo8(-1)
 1038 01e2 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 1039               		.loc 1 197 2 is_stmt 1 view .LVU381
 1040               	/* #APP */
 1041               	 ;  197 "bus_access.c" 1
 1042 01e4 0000      		nop
 1043               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1044               		.loc 1 198 2 view .LVU382
 1045               	 ;  198 "bus_access.c" 1
 1046 01e6 0000      		nop
 1047               	 ;  0 "" 2
 199:bus_access.c  **** }
 1048               		.loc 1 199 2 view .LVU383
 1049               	 ;  199 "bus_access.c" 1
 1050 01e8 0000      		nop
 1051               	 ;  0 "" 2
 1052               	/* #NOAPP */
 1053               	.LBE271:
 1054               	.LBE270:
 316:bus_access.c  **** 	return OK;
 1055               		.loc 1 316 2 view .LVU384
 1056               		.loc 1 316 9 is_stmt 0 view .LVU385
 1057 01ea 80E0      		ldi r24,0
 1058               	/* epilogue start */
 317:bus_access.c  **** }
 1059               		.loc 1 317 1 view .LVU386
 1060 01ec 0895      		ret
 1061               		.cfi_endproc
 1062               	.LFE19:
 1064               	.global	ppu_compare
 1066               	ppu_compare:
 1067               	.LVL71:
 1068               	.LFB20:
 318:bus_access.c  **** enum compare_status ppu_compare(uint16_t address, uint16_t length, const uint8_t *data)
 319:bus_access.c  **** {
 1069               		.loc 1 319 1 is_stmt 1 view -0
 1070               		.cfi_startproc
 1071               	/* prologue: function */
 1072               	/* frame size = 0 */
 1073               	/* stack size = 0 */
 1074               	.L__stack_usage = 0
 1075               		.loc 1 319 1 is_stmt 0 view .LVU388
 1076 01ee 9C01      		movw r18,r24
 1077 01f0 CB01      		movw r24,r22
 1078               	.LVL72:
 320:bus_access.c  **** 	while(length != 0){
 1079               		.loc 1 320 2 is_stmt 1 view .LVU389
 1080               		.loc 1 320 7 view .LVU390
 1081 01f2 0097      		sbiw r24,0
 1082 01f4 01F0      		breq .L47
 1083 01f6 FA01      		movw r30,r20
 1084 01f8 B901      		movw r22,r18
 1085               	.LVL73:
 1086               		.loc 1 320 7 is_stmt 0 view .LVU391
 1087 01fa 680F      		add r22,r24
 1088 01fc 791F      		adc r23,r25
 1089               	.LBB272:
 1090               	.LBB273:
 196:bus_access.c  **** 	asm("nop");
 1091               		.loc 1 196 14 view .LVU392
 1092 01fe 8FEF      		ldi r24,lo8(-1)
 1093               	.LVL74:
 196:bus_access.c  **** 	asm("nop");
 1094               		.loc 1 196 14 view .LVU393
 1095               	.LBE273:
 1096               	.LBE272:
 1097               	.LBB275:
 1098               	.LBB276:
 127:bus_access.c  **** }
 1099               		.loc 1 127 18 view .LVU394
 1100 0200 4EE7      		ldi r20,lo8(126)
 1101               	.LVL75:
 127:bus_access.c  **** }
 1102               		.loc 1 127 18 view .LVU395
 1103               	.LBE276:
 1104               	.LBE275:
 321:bus_access.c  **** 		direction_write();
 322:bus_access.c  **** 		address_set(address);
 323:bus_access.c  **** #if PCB_REVISION == 1
 324:bus_access.c  **** 		BUS_CONTROL_OUT = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(PPU_RD) & bit_get_negat
 1105               		.loc 1 324 19 view .LVU396
 1106 0202 AEE6      		ldi r26,lo8(110)
 1107 0204 00C0      		rjmp .L51
 1108               	.LVL76:
 1109               	.L49:
 325:bus_access.c  **** #endif
 326:bus_access.c  **** #if PCB_REVISION == 2
 327:bus_access.c  **** 		BUS_CONTROL_OUT = bit_get_negative(PPU_RD) & bit_get_negative(CPU_PHI2);;
 328:bus_access.c  **** #endif
 329:bus_access.c  **** 		direction_read();
 330:bus_access.c  **** 		if(DATABUS_IN != *data){
 331:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 332:bus_access.c  **** 			direction_write();
 333:bus_access.c  **** 			return NG;
 334:bus_access.c  **** 		}
 335:bus_access.c  **** 		data += 1;
 1110               		.loc 1 335 3 is_stmt 1 view .LVU397
 336:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 1111               		.loc 1 336 3 view .LVU398
 337:bus_access.c  **** 		address += 1;
 1112               		.loc 1 337 3 view .LVU399
 1113               		.loc 1 337 11 is_stmt 0 view .LVU400
 1114 0206 2F5F      		subi r18,-1
 1115 0208 3F4F      		sbci r19,-1
 1116               	.LVL77:
 338:bus_access.c  **** 		length--;
 1117               		.loc 1 338 3 is_stmt 1 view .LVU401
 320:bus_access.c  **** 		direction_write();
 1118               		.loc 1 320 7 view .LVU402
 1119 020a 6217      		cp r22,r18
 1120 020c 7307      		cpc r23,r19
 1121 020e 01F0      		breq .L47
 1122               	.LVL78:
 1123               	.L51:
 321:bus_access.c  **** 		address_set(address);
 1124               		.loc 1 321 3 view .LVU403
 1125               	.LBB278:
 1126               	.LBI272:
 194:bus_access.c  **** {
 1127               		.loc 1 194 20 view .LVU404
 1128               	.LBB274:
 196:bus_access.c  **** 	asm("nop");
 1129               		.loc 1 196 2 view .LVU405
 196:bus_access.c  **** 	asm("nop");
 1130               		.loc 1 196 14 is_stmt 0 view .LVU406
 1131 0210 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 1132               		.loc 1 197 2 is_stmt 1 view .LVU407
 1133               	/* #APP */
 1134               	 ;  197 "bus_access.c" 1
 1135 0212 0000      		nop
 1136               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1137               		.loc 1 198 2 view .LVU408
 1138               	 ;  198 "bus_access.c" 1
 1139 0214 0000      		nop
 1140               	 ;  0 "" 2
 199:bus_access.c  **** }
 1141               		.loc 1 199 2 view .LVU409
 1142               	 ;  199 "bus_access.c" 1
 1143 0216 0000      		nop
 1144               	 ;  0 "" 2
 1145               	/* #NOAPP */
 1146               	.LBE274:
 1147               	.LBE278:
 322:bus_access.c  **** #if PCB_REVISION == 1
 1148               		.loc 1 322 3 view .LVU410
 1149               	.LVL79:
 1150               	.LBB279:
 1151               	.LBI275:
 117:bus_access.c  **** {
 1152               		.loc 1 117 13 view .LVU411
 1153               	.LBB277:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1154               		.loc 1 119 2 view .LVU412
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1155               		.loc 1 119 23 is_stmt 0 view .LVU413
 1156 0218 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1157               		.loc 1 120 2 is_stmt 1 view .LVU414
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1158               		.loc 1 120 10 is_stmt 0 view .LVU415
 1159 021a 932F      		mov r25,r19
 1160 021c 9F77      		andi r25,lo8(127)
 1161               	.LVL80:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1162               		.loc 1 121 2 is_stmt 1 view .LVU416
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1163               		.loc 1 121 4 is_stmt 0 view .LVU417
 1164 021e 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 1165               		.loc 1 122 3 is_stmt 1 view .LVU418
 122:bus_access.c  **** 	}
 1166               		.loc 1 122 8 is_stmt 0 view .LVU419
 1167 0220 9068      		ori r25,lo8(-128)
 1168               	.LVL81:
 1169               	.L48:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1170               		.loc 1 124 2 is_stmt 1 view .LVU420
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1171               		.loc 1 124 14 is_stmt 0 view .LVU421
 1172 0222 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1173               		.loc 1 126 2 is_stmt 1 view .LVU422
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1174               		.loc 1 126 18 is_stmt 0 view .LVU423
 1175 0224 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 1176               		.loc 1 127 2 is_stmt 1 view .LVU424
 127:bus_access.c  **** }
 1177               		.loc 1 127 18 is_stmt 0 view .LVU425
 1178 0226 45BB      		out 0x15,r20
 1179               	.LVL82:
 127:bus_access.c  **** }
 1180               		.loc 1 127 18 view .LVU426
 1181               	.LBE277:
 1182               	.LBE279:
 324:bus_access.c  **** #endif
 1183               		.loc 1 324 3 is_stmt 1 view .LVU427
 106:bus_access.c  **** 	return ~ret;
 1184               		.loc 1 106 2 view .LVU428
 107:bus_access.c  **** }
 1185               		.loc 1 107 2 view .LVU429
 106:bus_access.c  **** 	return ~ret;
 1186               		.loc 1 106 2 view .LVU430
 107:bus_access.c  **** }
 1187               		.loc 1 107 2 view .LVU431
 106:bus_access.c  **** 	return ~ret;
 1188               		.loc 1 106 2 view .LVU432
 107:bus_access.c  **** }
 1189               		.loc 1 107 2 view .LVU433
 324:bus_access.c  **** #endif
 1190               		.loc 1 324 19 is_stmt 0 view .LVU434
 1191 0228 A5BB      		out 0x15,r26
 324:bus_access.c  **** #endif
 1192               		.loc 1 324 114 is_stmt 1 view .LVU435
 329:bus_access.c  **** 		if(DATABUS_IN != *data){
 1193               		.loc 1 329 3 view .LVU436
 1194               	.LBB280:
 1195               	.LBI280:
 202:bus_access.c  **** {
 1196               		.loc 1 202 20 view .LVU437
 1197               	.LBB281:
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 1198               		.loc 1 204 2 view .LVU438
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 1199               		.loc 1 204 14 is_stmt 0 view .LVU439
 1200 022a 88BB      		out 0x18,r24
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 1201               		.loc 1 205 2 is_stmt 1 view .LVU440
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 1202               		.loc 1 205 14 is_stmt 0 view .LVU441
 1203 022c 17BA      		out 0x17,__zero_reg__
 206:bus_access.c  **** 	asm("nop");
 1204               		.loc 1 206 2 is_stmt 1 view .LVU442
 1205               	/* #APP */
 1206               	 ;  206 "bus_access.c" 1
 1207 022e 0000      		nop
 1208               	 ;  0 "" 2
 207:bus_access.c  **** 	asm("nop");
 1209               		.loc 1 207 2 view .LVU443
 1210               	 ;  207 "bus_access.c" 1
 1211 0230 0000      		nop
 1212               	 ;  0 "" 2
 208:bus_access.c  **** }
 1213               		.loc 1 208 2 view .LVU444
 1214               	 ;  208 "bus_access.c" 1
 1215 0232 0000      		nop
 1216               	 ;  0 "" 2
 1217               	/* #NOAPP */
 1218               	.LBE281:
 1219               	.LBE280:
 330:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 1220               		.loc 1 330 3 view .LVU445
 330:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 1221               		.loc 1 330 6 is_stmt 0 view .LVU446
 1222 0234 56B3      		in r21,0x16
 330:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 1223               		.loc 1 330 17 view .LVU447
 1224 0236 9191      		ld r25,Z+
 331:bus_access.c  **** 			direction_write();
 1225               		.loc 1 331 20 view .LVU448
 1226 0238 45BB      		out 0x15,r20
 330:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE;
 1227               		.loc 1 330 5 view .LVU449
 1228 023a 5917      		cp r21,r25
 1229 023c 01F0      		breq .L49
 331:bus_access.c  **** 			direction_write();
 1230               		.loc 1 331 4 is_stmt 1 view .LVU450
 332:bus_access.c  **** 			return NG;
 1231               		.loc 1 332 4 view .LVU451
 1232               	.LBB282:
 1233               	.LBI282:
 194:bus_access.c  **** {
 1234               		.loc 1 194 20 view .LVU452
 1235               	.LBB283:
 196:bus_access.c  **** 	asm("nop");
 1236               		.loc 1 196 2 view .LVU453
 196:bus_access.c  **** 	asm("nop");
 1237               		.loc 1 196 14 is_stmt 0 view .LVU454
 1238 023e 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 1239               		.loc 1 197 2 is_stmt 1 view .LVU455
 1240               	/* #APP */
 1241               	 ;  197 "bus_access.c" 1
 1242 0240 0000      		nop
 1243               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1244               		.loc 1 198 2 view .LVU456
 1245               	 ;  198 "bus_access.c" 1
 1246 0242 0000      		nop
 1247               	 ;  0 "" 2
 199:bus_access.c  **** }
 1248               		.loc 1 199 2 view .LVU457
 1249               	 ;  199 "bus_access.c" 1
 1250 0244 0000      		nop
 1251               	 ;  0 "" 2
 1252               	/* #NOAPP */
 1253               	.LBE283:
 1254               	.LBE282:
 333:bus_access.c  **** 		}
 1255               		.loc 1 333 4 view .LVU458
 333:bus_access.c  **** 		}
 1256               		.loc 1 333 11 is_stmt 0 view .LVU459
 1257 0246 81E0      		ldi r24,lo8(1)
 1258 0248 0895      		ret
 1259               	.LVL83:
 1260               	.L47:
 339:bus_access.c  **** 	}
 340:bus_access.c  **** 	direction_write();
 1261               		.loc 1 340 2 is_stmt 1 view .LVU460
 1262               	.LBB284:
 1263               	.LBI284:
 194:bus_access.c  **** {
 1264               		.loc 1 194 20 view .LVU461
 1265               	.LBB285:
 196:bus_access.c  **** 	asm("nop");
 1266               		.loc 1 196 2 view .LVU462
 196:bus_access.c  **** 	asm("nop");
 1267               		.loc 1 196 14 is_stmt 0 view .LVU463
 1268 024a 8FEF      		ldi r24,lo8(-1)
 1269 024c 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 1270               		.loc 1 197 2 is_stmt 1 view .LVU464
 1271               	/* #APP */
 1272               	 ;  197 "bus_access.c" 1
 1273 024e 0000      		nop
 1274               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1275               		.loc 1 198 2 view .LVU465
 1276               	 ;  198 "bus_access.c" 1
 1277 0250 0000      		nop
 1278               	 ;  0 "" 2
 199:bus_access.c  **** }
 1279               		.loc 1 199 2 view .LVU466
 1280               	 ;  199 "bus_access.c" 1
 1281 0252 0000      		nop
 1282               	 ;  0 "" 2
 1283               	/* #NOAPP */
 1284               	.LBE285:
 1285               	.LBE284:
 341:bus_access.c  **** 	return OK;
 1286               		.loc 1 341 2 view .LVU467
 1287               		.loc 1 341 9 is_stmt 0 view .LVU468
 1288 0254 80E0      		ldi r24,0
 1289               	/* epilogue start */
 342:bus_access.c  **** }
 1290               		.loc 1 342 1 view .LVU469
 1291 0256 0895      		ret
 1292               		.cfi_endproc
 1293               	.LFE20:
 1295               	.global	cpu_write_6502_nowait
 1297               	cpu_write_6502_nowait:
 1298               	.LVL84:
 1299               	.LFB21:
 343:bus_access.c  **** 
 344:bus_access.c  **** void cpu_write_6502_nowait(uint16_t address, uint16_t length, const uint8_t *data)
 345:bus_access.c  **** {
 1300               		.loc 1 345 1 is_stmt 1 view -0
 1301               		.cfi_startproc
 1302               	/* prologue: function */
 1303               	/* frame size = 0 */
 1304               	/* stack size = 0 */
 1305               	.L__stack_usage = 0
 1306               		.loc 1 345 1 is_stmt 0 view .LVU471
 1307 0258 9C01      		movw r18,r24
 1308 025a CB01      		movw r24,r22
 1309               	.LVL85:
 1310               		.loc 1 345 1 view .LVU472
 1311 025c FA01      		movw r30,r20
 346:bus_access.c  **** 	while(length != 0){
 1312               		.loc 1 346 2 is_stmt 1 view .LVU473
 1313               		.loc 1 346 7 view .LVU474
 1314 025e 0097      		sbiw r24,0
 1315 0260 01F0      		breq .L61
 1316 0262 B901      		movw r22,r18
 1317               	.LVL86:
 1318               		.loc 1 346 7 is_stmt 0 view .LVU475
 1319 0264 680F      		add r22,r24
 1320 0266 791F      		adc r23,r25
 1321               	.LBB286:
 1322               	.LBB287:
 1323               	.LBB288:
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1324               		.loc 1 126 18 view .LVU476
 1325 0268 AFEF      		ldi r26,lo8(-1)
 127:bus_access.c  **** }
 1326               		.loc 1 127 18 view .LVU477
 1327 026a 9EE7      		ldi r25,lo8(126)
 1328               	.LBE288:
 1329               	.LBE287:
 347:bus_access.c  **** 		uint8_t control;
 348:bus_access.c  **** 		address_set(address);
 349:bus_access.c  **** 		
 350:bus_access.c  **** 		//phi2 down
 351:bus_access.c  **** #if PCB_REVISION == 1
 352:bus_access.c  **** 		control = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(CPU_RW) & bit_get_negative(CPU_
 353:bus_access.c  **** #endif
 354:bus_access.c  **** #if PCB_REVISION == 2
 355:bus_access.c  **** 		control = bit_get_negative(CPU_RW) & bit_get_negative(CPU_PHI2);
 356:bus_access.c  **** #endif
 357:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1330               		.loc 1 357 19 view .LVU478
 1331 026c 5AE7      		ldi r21,lo8(122)
 1332               	.LVL87:
 1333               	.L60:
 347:bus_access.c  **** 		uint8_t control;
 1334               		.loc 1 347 3 is_stmt 1 view .LVU479
 348:bus_access.c  **** 		
 1335               		.loc 1 348 3 view .LVU480
 1336               	.LBB290:
 1337               	.LBI287:
 117:bus_access.c  **** {
 1338               		.loc 1 117 13 view .LVU481
 1339               	.LBB289:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1340               		.loc 1 119 2 view .LVU482
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1341               		.loc 1 119 23 is_stmt 0 view .LVU483
 1342 026e 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1343               		.loc 1 120 2 is_stmt 1 view .LVU484
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1344               		.loc 1 120 10 is_stmt 0 view .LVU485
 1345 0270 832F      		mov r24,r19
 1346 0272 8F77      		andi r24,lo8(127)
 1347               	.LVL88:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1348               		.loc 1 121 2 is_stmt 1 view .LVU486
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1349               		.loc 1 121 4 is_stmt 0 view .LVU487
 1350 0274 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 1351               		.loc 1 122 3 is_stmt 1 view .LVU488
 122:bus_access.c  **** 	}
 1352               		.loc 1 122 8 is_stmt 0 view .LVU489
 1353 0276 8068      		ori r24,lo8(-128)
 1354               	.LVL89:
 1355               	.L58:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1356               		.loc 1 124 2 is_stmt 1 view .LVU490
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1357               		.loc 1 124 14 is_stmt 0 view .LVU491
 1358 0278 88BB      		out 0x18,r24
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1359               		.loc 1 126 2 is_stmt 1 view .LVU492
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1360               		.loc 1 126 18 is_stmt 0 view .LVU493
 1361 027a A5BB      		out 0x15,r26
 127:bus_access.c  **** }
 1362               		.loc 1 127 2 is_stmt 1 view .LVU494
 127:bus_access.c  **** }
 1363               		.loc 1 127 18 is_stmt 0 view .LVU495
 1364 027c 95BB      		out 0x15,r25
 1365               	.LVL90:
 127:bus_access.c  **** }
 1366               		.loc 1 127 18 view .LVU496
 1367               	.LBE289:
 1368               	.LBE290:
 352:bus_access.c  **** #endif
 1369               		.loc 1 352 3 is_stmt 1 view .LVU497
 352:bus_access.c  **** #endif
 1370               		.loc 1 352 3 is_stmt 0 view .LVU498
 1371               	.LBE286:
 106:bus_access.c  **** 	return ~ret;
 1372               		.loc 1 106 2 is_stmt 1 view .LVU499
 107:bus_access.c  **** }
 1373               		.loc 1 107 2 view .LVU500
 106:bus_access.c  **** 	return ~ret;
 1374               		.loc 1 106 2 view .LVU501
 107:bus_access.c  **** }
 1375               		.loc 1 107 2 view .LVU502
 106:bus_access.c  **** 	return ~ret;
 1376               		.loc 1 106 2 view .LVU503
 107:bus_access.c  **** }
 1377               		.loc 1 107 2 view .LVU504
 1378               	.LBB291:
 1379               		.loc 1 357 3 view .LVU505
 1380               		.loc 1 357 19 is_stmt 0 view .LVU506
 1381 027e 55BB      		out 0x15,r21
 358:bus_access.c  **** 		
 359:bus_access.c  **** 		//phi2 up
 360:bus_access.c  **** 		control |= (1 << CPU_PHI2);
 1382               		.loc 1 360 3 is_stmt 1 view .LVU507
 1383               	.LVL91:
 361:bus_access.c  **** 		if((address & 0x8000) != 0){
 1384               		.loc 1 361 3 view .LVU508
 1385               		.loc 1 361 5 is_stmt 0 view .LVU509
 1386 0280 48E7      		ldi r20,lo8(120)
 362:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 1387               		.loc 1 362 12 view .LVU510
 1388 0282 89E7      		ldi r24,lo8(121)
 361:bus_access.c  **** 		if((address & 0x8000) != 0){
 1389               		.loc 1 361 5 view .LVU511
 1390 0284 37FD      		sbrc r19,7
 1391 0286 00C0      		rjmp .L59
 1392 0288 4AE7      		ldi r20,lo8(122)
 360:bus_access.c  **** 		if((address & 0x8000) != 0){
 1393               		.loc 1 360 11 view .LVU512
 1394 028a 8BE7      		ldi r24,lo8(123)
 1395               	.L59:
 1396               	.LVL92:
 363:bus_access.c  **** 		}
 364:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1397               		.loc 1 364 3 is_stmt 1 view .LVU513
 1398               		.loc 1 364 19 is_stmt 0 view .LVU514
 1399 028c 85BB      		out 0x15,r24
 365:bus_access.c  **** 		
 366:bus_access.c  **** 		//data set
 367:bus_access.c  **** 		DATABUS_OUT = *data;
 1400               		.loc 1 367 3 is_stmt 1 view .LVU515
 1401               		.loc 1 367 17 is_stmt 0 view .LVU516
 1402 028e 8191      		ld r24,Z+
 1403               	.LVL93:
 1404               		.loc 1 367 15 view .LVU517
 1405 0290 88BB      		out 0x18,r24
 368:bus_access.c  **** 		data++;
 1406               		.loc 1 368 3 is_stmt 1 view .LVU518
 1407               	.LVL94:
 369:bus_access.c  **** 		
 370:bus_access.c  **** 		//phi2 down
 371:bus_access.c  **** 		control &= bit_get_negative(CPU_PHI2);
 1408               		.loc 1 371 3 view .LVU519
 1409               		.loc 1 371 3 is_stmt 0 view .LVU520
 1410               	.LBE291:
 106:bus_access.c  **** 	return ~ret;
 1411               		.loc 1 106 2 is_stmt 1 view .LVU521
 107:bus_access.c  **** }
 1412               		.loc 1 107 2 view .LVU522
 1413               	.LBB292:
 372:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1414               		.loc 1 372 3 view .LVU523
 1415               		.loc 1 372 19 is_stmt 0 view .LVU524
 1416 0292 45BB      		out 0x15,r20
 373:bus_access.c  **** 		
 374:bus_access.c  **** 		//bus close
 375:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 1417               		.loc 1 375 3 is_stmt 1 view .LVU525
 1418               		.loc 1 375 19 is_stmt 0 view .LVU526
 1419 0294 95BB      		out 0x15,r25
 376:bus_access.c  **** 		
 377:bus_access.c  **** 		address += 1;
 1420               		.loc 1 377 3 is_stmt 1 view .LVU527
 1421               		.loc 1 377 11 is_stmt 0 view .LVU528
 1422 0296 2F5F      		subi r18,-1
 1423 0298 3F4F      		sbci r19,-1
 1424               	.LVL95:
 378:bus_access.c  **** 		length--;
 1425               		.loc 1 378 3 is_stmt 1 view .LVU529
 1426               		.loc 1 378 3 is_stmt 0 view .LVU530
 1427               	.LBE292:
 346:bus_access.c  **** 		uint8_t control;
 1428               		.loc 1 346 7 is_stmt 1 view .LVU531
 1429 029a 6217      		cp r22,r18
 1430 029c 7307      		cpc r23,r19
 1431 029e 01F4      		brne .L60
 1432               	.L61:
 379:bus_access.c  **** 	}
 380:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
 1433               		.loc 1 380 2 view .LVU532
 1434               	.LVL96:
 1435               	.LBB293:
 1436               	.LBI293:
 117:bus_access.c  **** {
 1437               		.loc 1 117 13 view .LVU533
 1438               	.LBB294:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1439               		.loc 1 119 2 view .LVU534
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1440               		.loc 1 119 23 is_stmt 0 view .LVU535
 1441 02a0 8FEF      		ldi r24,lo8(-1)
 1442 02a2 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1443               		.loc 1 120 2 is_stmt 1 view .LVU536
 1444               	.LVL97:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1445               		.loc 1 121 2 view .LVU537
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1446               		.loc 1 124 2 view .LVU538
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1447               		.loc 1 124 14 is_stmt 0 view .LVU539
 1448 02a4 9FE3      		ldi r25,lo8(63)
 1449 02a6 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1450               		.loc 1 126 2 is_stmt 1 view .LVU540
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1451               		.loc 1 126 18 is_stmt 0 view .LVU541
 1452 02a8 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 1453               		.loc 1 127 2 is_stmt 1 view .LVU542
 127:bus_access.c  **** }
 1454               		.loc 1 127 18 is_stmt 0 view .LVU543
 1455 02aa 8EE7      		ldi r24,lo8(126)
 1456 02ac 85BB      		out 0x15,r24
 1457               	.LVL98:
 1458               	/* epilogue start */
 127:bus_access.c  **** }
 1459               		.loc 1 127 18 view .LVU544
 1460               	.LBE294:
 1461               	.LBE293:
 381:bus_access.c  **** }
 1462               		.loc 1 381 1 view .LVU545
 1463 02ae 0895      		ret
 1464               		.cfi_endproc
 1465               	.LFE21:
 1467               	.global	cpu_write_flash
 1469               	cpu_write_flash:
 1470               	.LVL99:
 1471               	.LFB23:
 382:bus_access.c  **** 
 383:bus_access.c  **** /*
 384:bus_access.c  **** /WE controlled write operation has busconflict
 385:bus_access.c  **** PHI2  |-__________-
 386:bus_access.c  **** R/W   |----___-----
 387:bus_access.c  **** /ROMCS|--_______---
 388:bus_access.c  **** A0-A14|-<vaild address>-
 389:bus_access.c  **** D0-D7 |--oo<i>**---
 390:bus_access.c  **** o is dataout, i is datain, * is bus-confilict
 391:bus_access.c  **** 
 392:bus_access.c  **** /CS controlled write operation is clean write cycle for flash memory
 393:bus_access.c  **** PHI2  |-__________-
 394:bus_access.c  **** R/W   |--_______---
 395:bus_access.c  **** /ROMCS|----___-----
 396:bus_access.c  **** A0-A14|-<vaild address>-
 397:bus_access.c  **** D0-D7 |----<iii>---
 398:bus_access.c  **** */
 399:bus_access.c  **** static inline void cpu_write_flash_waveform(uint16_t address, uint8_t data)
 400:bus_access.c  **** {
 401:bus_access.c  **** #if PCB_REVISION == 1
 402:bus_access.c  ****         uint8_t control = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(CPU_PHI2);
 403:bus_access.c  **** #endif
 404:bus_access.c  **** #if PCB_REVISION == 2
 405:bus_access.c  ****         uint8_t control = bit_get_negative(CPU_PHI2);
 406:bus_access.c  **** #endif
 407:bus_access.c  **** 	address_set(address);
 408:bus_access.c  **** 	if(0){ //R/W = /WE controlled write operation
 409:bus_access.c  **** 		if((address & 0x8000) != 0){
 410:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 411:bus_access.c  **** 			BUS_CONTROL_OUT = control;
 412:bus_access.c  **** 		}
 413:bus_access.c  **** 		control &= bit_get_negative(CPU_RW);
 414:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 415:bus_access.c  **** 		DATABUS_OUT = data;
 416:bus_access.c  **** 		control |= 1 << CPU_RW; //R/W close
 417:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 418:bus_access.c  **** 	}else{ ///ROMCS = /CS controlled write operation
 419:bus_access.c  **** 		control &= bit_get_negative(CPU_RW);
 420:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 421:bus_access.c  **** 		if((address & 0x8000) != 0){
 422:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 423:bus_access.c  **** 			BUS_CONTROL_OUT = control;
 424:bus_access.c  **** 		}
 425:bus_access.c  **** 		DATABUS_OUT = data;
 426:bus_access.c  **** 		control |= 1 << CPU_ROMCS;
 427:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 428:bus_access.c  **** 	}
 429:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 430:bus_access.c  **** }
 431:bus_access.c  **** void cpu_write_flash(uint16_t address, uint16_t length, const uint8_t *data)
 432:bus_access.c  **** {
 1472               		.loc 1 432 1 is_stmt 1 view -0
 1473               		.cfi_startproc
 1474               	/* prologue: function */
 1475               	/* frame size = 0 */
 1476               	/* stack size = 0 */
 1477               	.L__stack_usage = 0
 1478               		.loc 1 432 1 is_stmt 0 view .LVU547
 1479 02b0 9C01      		movw r18,r24
 1480 02b2 CB01      		movw r24,r22
 1481               	.LVL100:
 433:bus_access.c  **** 	direction_write();
 1482               		.loc 1 433 2 is_stmt 1 view .LVU548
 1483               	.LBB295:
 1484               	.LBI295:
 194:bus_access.c  **** {
 1485               		.loc 1 194 20 view .LVU549
 1486               	.LBB296:
 196:bus_access.c  **** 	asm("nop");
 1487               		.loc 1 196 2 view .LVU550
 196:bus_access.c  **** 	asm("nop");
 1488               		.loc 1 196 14 is_stmt 0 view .LVU551
 1489 02b4 6FEF      		ldi r22,lo8(-1)
 1490               	.LVL101:
 196:bus_access.c  **** 	asm("nop");
 1491               		.loc 1 196 14 view .LVU552
 1492 02b6 67BB      		out 0x17,r22
 197:bus_access.c  **** 	asm("nop");
 1493               		.loc 1 197 2 is_stmt 1 view .LVU553
 1494               	/* #APP */
 1495               	 ;  197 "bus_access.c" 1
 1496 02b8 0000      		nop
 1497               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1498               		.loc 1 198 2 view .LVU554
 1499               	 ;  198 "bus_access.c" 1
 1500 02ba 0000      		nop
 1501               	 ;  0 "" 2
 199:bus_access.c  **** }
 1502               		.loc 1 199 2 view .LVU555
 1503               	 ;  199 "bus_access.c" 1
 1504 02bc 0000      		nop
 1505               	 ;  0 "" 2
 199:bus_access.c  **** }
 1506               		.loc 1 199 2 is_stmt 0 view .LVU556
 1507               	/* #NOAPP */
 1508               	.LBE296:
 1509               	.LBE295:
 434:bus_access.c  **** 	while(length != 0){
 1510               		.loc 1 434 7 is_stmt 1 view .LVU557
 1511 02be 0097      		sbiw r24,0
 1512 02c0 01F0      		breq .L66
 1513 02c2 FA01      		movw r30,r20
 1514 02c4 B901      		movw r22,r18
 1515 02c6 680F      		add r22,r24
 1516 02c8 791F      		adc r23,r25
 1517               	.LBB297:
 1518               	.LBB298:
 1519               	.LBB299:
 1520               	.LBB300:
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1521               		.loc 1 126 18 is_stmt 0 view .LVU558
 1522 02ca AFEF      		ldi r26,lo8(-1)
 127:bus_access.c  **** }
 1523               		.loc 1 127 18 view .LVU559
 1524 02cc 4EE7      		ldi r20,lo8(126)
 1525               	.LVL102:
 127:bus_access.c  **** }
 1526               		.loc 1 127 18 view .LVU560
 1527               	.LBE300:
 1528               	.LBE299:
 420:bus_access.c  **** 		if((address & 0x8000) != 0){
 1529               		.loc 1 420 19 view .LVU561
 1530 02ce 9AE7      		ldi r25,lo8(122)
 423:bus_access.c  **** 		}
 1531               		.loc 1 423 20 view .LVU562
 1532 02d0 B8E7      		ldi r27,lo8(120)
 1533               	.LVL103:
 1534               	.L69:
 423:bus_access.c  **** 		}
 1535               		.loc 1 423 20 view .LVU563
 1536               	.LBE298:
 1537               	.LBE297:
 435:bus_access.c  **** 		cpu_write_flash_waveform(address, *data);
 1538               		.loc 1 435 3 is_stmt 1 view .LVU564
 1539 02d2 5191      		ld r21,Z+
 1540               	.LVL104:
 1541               	.LBB307:
 1542               	.LBI297:
 399:bus_access.c  **** {
 1543               		.loc 1 399 20 view .LVU565
 1544               	.LBB303:
 402:bus_access.c  **** #endif
 1545               		.loc 1 402 9 view .LVU566
 402:bus_access.c  **** #endif
 1546               		.loc 1 402 9 is_stmt 0 view .LVU567
 1547               	.LBE303:
 1548               	.LBE307:
 106:bus_access.c  **** 	return ~ret;
 1549               		.loc 1 106 2 is_stmt 1 view .LVU568
 107:bus_access.c  **** }
 1550               		.loc 1 107 2 view .LVU569
 106:bus_access.c  **** 	return ~ret;
 1551               		.loc 1 106 2 view .LVU570
 107:bus_access.c  **** }
 1552               		.loc 1 107 2 view .LVU571
 1553               	.LBB308:
 1554               	.LBB304:
 407:bus_access.c  **** 	if(0){ //R/W = /WE controlled write operation
 1555               		.loc 1 407 2 view .LVU572
 1556               	.LBB302:
 1557               	.LBI299:
 117:bus_access.c  **** {
 1558               		.loc 1 117 13 view .LVU573
 1559               	.LBB301:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1560               		.loc 1 119 2 view .LVU574
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1561               		.loc 1 119 23 is_stmt 0 view .LVU575
 1562 02d4 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1563               		.loc 1 120 2 is_stmt 1 view .LVU576
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1564               		.loc 1 120 10 is_stmt 0 view .LVU577
 1565 02d6 832F      		mov r24,r19
 1566 02d8 8F77      		andi r24,lo8(127)
 1567               	.LVL105:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1568               		.loc 1 121 2 is_stmt 1 view .LVU578
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1569               		.loc 1 121 4 is_stmt 0 view .LVU579
 1570 02da 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 1571               		.loc 1 122 3 is_stmt 1 view .LVU580
 122:bus_access.c  **** 	}
 1572               		.loc 1 122 8 is_stmt 0 view .LVU581
 1573 02dc 8068      		ori r24,lo8(-128)
 1574               	.LVL106:
 1575               	.L67:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1576               		.loc 1 124 2 is_stmt 1 view .LVU582
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1577               		.loc 1 124 14 is_stmt 0 view .LVU583
 1578 02de 88BB      		out 0x18,r24
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1579               		.loc 1 126 2 is_stmt 1 view .LVU584
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1580               		.loc 1 126 18 is_stmt 0 view .LVU585
 1581 02e0 A5BB      		out 0x15,r26
 127:bus_access.c  **** }
 1582               		.loc 1 127 2 is_stmt 1 view .LVU586
 127:bus_access.c  **** }
 1583               		.loc 1 127 18 is_stmt 0 view .LVU587
 1584 02e2 45BB      		out 0x15,r20
 1585               	.LVL107:
 127:bus_access.c  **** }
 1586               		.loc 1 127 18 view .LVU588
 1587               	.LBE301:
 1588               	.LBE302:
 408:bus_access.c  **** 		if((address & 0x8000) != 0){
 1589               		.loc 1 408 2 is_stmt 1 view .LVU589
 419:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1590               		.loc 1 419 3 view .LVU590
 419:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1591               		.loc 1 419 3 is_stmt 0 view .LVU591
 1592               	.LBE304:
 1593               	.LBE308:
 106:bus_access.c  **** 	return ~ret;
 1594               		.loc 1 106 2 is_stmt 1 view .LVU592
 107:bus_access.c  **** }
 1595               		.loc 1 107 2 view .LVU593
 1596               	.LBB309:
 1597               	.LBB305:
 420:bus_access.c  **** 		if((address & 0x8000) != 0){
 1598               		.loc 1 420 3 view .LVU594
 420:bus_access.c  **** 		if((address & 0x8000) != 0){
 1599               		.loc 1 420 19 is_stmt 0 view .LVU595
 1600 02e4 95BB      		out 0x15,r25
 421:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 1601               		.loc 1 421 3 is_stmt 1 view .LVU596
 421:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 1602               		.loc 1 421 5 is_stmt 0 view .LVU597
 1603 02e6 37FD      		sbrc r19,7
 422:bus_access.c  **** 			BUS_CONTROL_OUT = control;
 1604               		.loc 1 422 4 is_stmt 1 view .LVU598
 1605               	.LVL108:
 422:bus_access.c  **** 			BUS_CONTROL_OUT = control;
 1606               		.loc 1 422 4 is_stmt 0 view .LVU599
 1607               	.LBE305:
 1608               	.LBE309:
 106:bus_access.c  **** 	return ~ret;
 1609               		.loc 1 106 2 is_stmt 1 view .LVU600
 107:bus_access.c  **** }
 1610               		.loc 1 107 2 view .LVU601
 1611               	.LBB310:
 1612               	.LBB306:
 423:bus_access.c  **** 		}
 1613               		.loc 1 423 4 view .LVU602
 423:bus_access.c  **** 		}
 1614               		.loc 1 423 20 is_stmt 0 view .LVU603
 1615 02e8 B5BB      		out 0x15,r27
 1616               	.LVL109:
 1617               	.L68:
 425:bus_access.c  **** 		control |= 1 << CPU_ROMCS;
 1618               		.loc 1 425 3 is_stmt 1 view .LVU604
 425:bus_access.c  **** 		control |= 1 << CPU_ROMCS;
 1619               		.loc 1 425 15 is_stmt 0 view .LVU605
 1620 02ea 58BB      		out 0x18,r21
 426:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1621               		.loc 1 426 3 is_stmt 1 view .LVU606
 1622               	.LVL110:
 427:bus_access.c  **** 	}
 1623               		.loc 1 427 3 view .LVU607
 427:bus_access.c  **** 	}
 1624               		.loc 1 427 19 is_stmt 0 view .LVU608
 1625 02ec 95BB      		out 0x15,r25
 429:bus_access.c  **** }
 1626               		.loc 1 429 2 is_stmt 1 view .LVU609
 429:bus_access.c  **** }
 1627               		.loc 1 429 18 is_stmt 0 view .LVU610
 1628 02ee 45BB      		out 0x15,r20
 1629               	.LVL111:
 429:bus_access.c  **** }
 1630               		.loc 1 429 18 view .LVU611
 1631               	.LBE306:
 1632               	.LBE310:
 436:bus_access.c  **** 		data++;
 1633               		.loc 1 436 3 is_stmt 1 view .LVU612
 437:bus_access.c  **** 		address += 1;
 1634               		.loc 1 437 3 view .LVU613
 1635               		.loc 1 437 11 is_stmt 0 view .LVU614
 1636 02f0 2F5F      		subi r18,-1
 1637 02f2 3F4F      		sbci r19,-1
 1638               	.LVL112:
 438:bus_access.c  **** 		length--;
 1639               		.loc 1 438 3 is_stmt 1 view .LVU615
 434:bus_access.c  **** 		cpu_write_flash_waveform(address, *data);
 1640               		.loc 1 434 7 view .LVU616
 1641 02f4 2617      		cp r18,r22
 1642 02f6 3707      		cpc r19,r23
 1643 02f8 01F4      		brne .L69
 1644               	.LVL113:
 1645               	.L66:
 439:bus_access.c  **** 	}
 440:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
 1646               		.loc 1 440 2 view .LVU617
 1647               	.LBB311:
 1648               	.LBI311:
 117:bus_access.c  **** {
 1649               		.loc 1 117 13 view .LVU618
 1650               	.LBB312:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1651               		.loc 1 119 2 view .LVU619
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1652               		.loc 1 119 23 is_stmt 0 view .LVU620
 1653 02fa 8FEF      		ldi r24,lo8(-1)
 1654 02fc 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1655               		.loc 1 120 2 is_stmt 1 view .LVU621
 1656               	.LVL114:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1657               		.loc 1 121 2 view .LVU622
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1658               		.loc 1 124 2 view .LVU623
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1659               		.loc 1 124 14 is_stmt 0 view .LVU624
 1660 02fe 9FE3      		ldi r25,lo8(63)
 1661 0300 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1662               		.loc 1 126 2 is_stmt 1 view .LVU625
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1663               		.loc 1 126 18 is_stmt 0 view .LVU626
 1664 0302 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 1665               		.loc 1 127 2 is_stmt 1 view .LVU627
 127:bus_access.c  **** }
 1666               		.loc 1 127 18 is_stmt 0 view .LVU628
 1667 0304 8EE7      		ldi r24,lo8(126)
 1668 0306 85BB      		out 0x15,r24
 1669               	.LVL115:
 1670               	/* epilogue start */
 127:bus_access.c  **** }
 1671               		.loc 1 127 18 view .LVU629
 1672               	.LBE312:
 1673               	.LBE311:
 441:bus_access.c  **** }
 1674               		.loc 1 441 1 view .LVU630
 1675 0308 0895      		ret
 1676               		.cfi_endproc
 1677               	.LFE23:
 1679               	.global	cpu_write_flash_order
 1681               	cpu_write_flash_order:
 1682               	.LVL116:
 1683               	.LFB24:
 442:bus_access.c  **** 
 443:bus_access.c  **** void cpu_write_flash_order(const struct flash_order *t)
 444:bus_access.c  **** {
 1684               		.loc 1 444 1 is_stmt 1 view -0
 1685               		.cfi_startproc
 1686               	/* prologue: function */
 1687               	/* frame size = 0 */
 1688               	/* stack size = 0 */
 1689               	.L__stack_usage = 0
 1690               		.loc 1 444 1 is_stmt 0 view .LVU632
 1691 030a FC01      		movw r30,r24
 445:bus_access.c  **** 	int length = FLASH_PROGRAM_ORDER;
 1692               		.loc 1 445 2 is_stmt 1 view .LVU633
 1693               	.LVL117:
 446:bus_access.c  **** 	direction_write();
 1694               		.loc 1 446 2 view .LVU634
 1695               	.LBB313:
 1696               	.LBI313:
 194:bus_access.c  **** {
 1697               		.loc 1 194 20 view .LVU635
 1698               	.LBB314:
 196:bus_access.c  **** 	asm("nop");
 1699               		.loc 1 196 2 view .LVU636
 196:bus_access.c  **** 	asm("nop");
 1700               		.loc 1 196 14 is_stmt 0 view .LVU637
 1701 030c 8FEF      		ldi r24,lo8(-1)
 1702               	.LVL118:
 196:bus_access.c  **** 	asm("nop");
 1703               		.loc 1 196 14 view .LVU638
 1704 030e 87BB      		out 0x17,r24
 197:bus_access.c  **** 	asm("nop");
 1705               		.loc 1 197 2 is_stmt 1 view .LVU639
 1706               	/* #APP */
 1707               	 ;  197 "bus_access.c" 1
 1708 0310 0000      		nop
 1709               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 1710               		.loc 1 198 2 view .LVU640
 1711               	 ;  198 "bus_access.c" 1
 1712 0312 0000      		nop
 1713               	 ;  0 "" 2
 199:bus_access.c  **** }
 1714               		.loc 1 199 2 view .LVU641
 1715               	 ;  199 "bus_access.c" 1
 1716 0314 0000      		nop
 1717               	 ;  0 "" 2
 199:bus_access.c  **** }
 1718               		.loc 1 199 2 is_stmt 0 view .LVU642
 1719               	/* #NOAPP */
 1720               	.LBE314:
 1721               	.LBE313:
 447:bus_access.c  **** 	while(length != 0){
 1722               		.loc 1 447 7 is_stmt 1 view .LVU643
 1723 0316 DF01      		movw r26,r30
 1724 0318 1996      		adiw r26,9
 1725               	.LBB315:
 1726               	.LBB316:
 1727               	.LBB317:
 1728               	.LBB318:
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1729               		.loc 1 126 18 is_stmt 0 view .LVU644
 1730 031a 6FEF      		ldi r22,lo8(-1)
 127:bus_access.c  **** }
 1731               		.loc 1 127 18 view .LVU645
 1732 031c 3EE7      		ldi r19,lo8(126)
 1733               	.LBE318:
 1734               	.LBE317:
 420:bus_access.c  **** 		if((address & 0x8000) != 0){
 1735               		.loc 1 420 19 view .LVU646
 1736 031e 4AE7      		ldi r20,lo8(122)
 423:bus_access.c  **** 		}
 1737               		.loc 1 423 20 view .LVU647
 1738 0320 78E7      		ldi r23,lo8(120)
 1739               	.LVL119:
 1740               	.L77:
 423:bus_access.c  **** 		}
 1741               		.loc 1 423 20 view .LVU648
 1742               	.LBE316:
 1743               	.LBE315:
 448:bus_access.c  **** 		cpu_write_flash_waveform(t->address, t->data);
 1744               		.loc 1 448 3 is_stmt 1 view .LVU649
 1745 0322 5281      		ldd r21,Z+2
 1746 0324 8081      		ld r24,Z
 1747 0326 9181      		ldd r25,Z+1
 1748               	.LVL120:
 1749               	.LBB325:
 1750               	.LBI315:
 399:bus_access.c  **** {
 1751               		.loc 1 399 20 view .LVU650
 1752               	.LBB321:
 402:bus_access.c  **** #endif
 1753               		.loc 1 402 9 view .LVU651
 402:bus_access.c  **** #endif
 1754               		.loc 1 402 9 is_stmt 0 view .LVU652
 1755               	.LBE321:
 1756               	.LBE325:
 106:bus_access.c  **** 	return ~ret;
 1757               		.loc 1 106 2 is_stmt 1 view .LVU653
 107:bus_access.c  **** }
 1758               		.loc 1 107 2 view .LVU654
 106:bus_access.c  **** 	return ~ret;
 1759               		.loc 1 106 2 view .LVU655
 107:bus_access.c  **** }
 1760               		.loc 1 107 2 view .LVU656
 1761               	.LBB326:
 1762               	.LBB322:
 407:bus_access.c  **** 	if(0){ //R/W = /WE controlled write operation
 1763               		.loc 1 407 2 view .LVU657
 1764               	.LBB320:
 1765               	.LBI317:
 117:bus_access.c  **** {
 1766               		.loc 1 117 13 view .LVU658
 1767               	.LBB319:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1768               		.loc 1 119 2 view .LVU659
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1769               		.loc 1 119 23 is_stmt 0 view .LVU660
 1770 0328 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1771               		.loc 1 120 2 is_stmt 1 view .LVU661
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1772               		.loc 1 120 10 is_stmt 0 view .LVU662
 1773 032a 292F      		mov r18,r25
 1774 032c 2F77      		andi r18,lo8(127)
 1775               	.LVL121:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1776               		.loc 1 121 2 is_stmt 1 view .LVU663
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1777               		.loc 1 121 4 is_stmt 0 view .LVU664
 1778 032e 95FF      		sbrs r25,5
 122:bus_access.c  **** 	}
 1779               		.loc 1 122 3 is_stmt 1 view .LVU665
 122:bus_access.c  **** 	}
 1780               		.loc 1 122 8 is_stmt 0 view .LVU666
 1781 0330 2068      		ori r18,lo8(-128)
 1782               	.LVL122:
 1783               	.L75:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1784               		.loc 1 124 2 is_stmt 1 view .LVU667
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1785               		.loc 1 124 14 is_stmt 0 view .LVU668
 1786 0332 28BB      		out 0x18,r18
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1787               		.loc 1 126 2 is_stmt 1 view .LVU669
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1788               		.loc 1 126 18 is_stmt 0 view .LVU670
 1789 0334 65BB      		out 0x15,r22
 127:bus_access.c  **** }
 1790               		.loc 1 127 2 is_stmt 1 view .LVU671
 127:bus_access.c  **** }
 1791               		.loc 1 127 18 is_stmt 0 view .LVU672
 1792 0336 35BB      		out 0x15,r19
 1793               	.LVL123:
 127:bus_access.c  **** }
 1794               		.loc 1 127 18 view .LVU673
 1795               	.LBE319:
 1796               	.LBE320:
 408:bus_access.c  **** 		if((address & 0x8000) != 0){
 1797               		.loc 1 408 2 is_stmt 1 view .LVU674
 419:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1798               		.loc 1 419 3 view .LVU675
 419:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1799               		.loc 1 419 3 is_stmt 0 view .LVU676
 1800               	.LBE322:
 1801               	.LBE326:
 106:bus_access.c  **** 	return ~ret;
 1802               		.loc 1 106 2 is_stmt 1 view .LVU677
 107:bus_access.c  **** }
 1803               		.loc 1 107 2 view .LVU678
 1804               	.LBB327:
 1805               	.LBB323:
 420:bus_access.c  **** 		if((address & 0x8000) != 0){
 1806               		.loc 1 420 3 view .LVU679
 420:bus_access.c  **** 		if((address & 0x8000) != 0){
 1807               		.loc 1 420 19 is_stmt 0 view .LVU680
 1808 0338 45BB      		out 0x15,r20
 421:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 1809               		.loc 1 421 3 is_stmt 1 view .LVU681
 421:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 1810               		.loc 1 421 5 is_stmt 0 view .LVU682
 1811 033a 97FD      		sbrc r25,7
 422:bus_access.c  **** 			BUS_CONTROL_OUT = control;
 1812               		.loc 1 422 4 is_stmt 1 view .LVU683
 1813               	.LVL124:
 422:bus_access.c  **** 			BUS_CONTROL_OUT = control;
 1814               		.loc 1 422 4 is_stmt 0 view .LVU684
 1815               	.LBE323:
 1816               	.LBE327:
 106:bus_access.c  **** 	return ~ret;
 1817               		.loc 1 106 2 is_stmt 1 view .LVU685
 107:bus_access.c  **** }
 1818               		.loc 1 107 2 view .LVU686
 1819               	.LBB328:
 1820               	.LBB324:
 423:bus_access.c  **** 		}
 1821               		.loc 1 423 4 view .LVU687
 423:bus_access.c  **** 		}
 1822               		.loc 1 423 20 is_stmt 0 view .LVU688
 1823 033c 75BB      		out 0x15,r23
 1824               	.LVL125:
 1825               	.L76:
 425:bus_access.c  **** 		control |= 1 << CPU_ROMCS;
 1826               		.loc 1 425 3 is_stmt 1 view .LVU689
 425:bus_access.c  **** 		control |= 1 << CPU_ROMCS;
 1827               		.loc 1 425 15 is_stmt 0 view .LVU690
 1828 033e 58BB      		out 0x18,r21
 426:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1829               		.loc 1 426 3 is_stmt 1 view .LVU691
 1830               	.LVL126:
 427:bus_access.c  **** 	}
 1831               		.loc 1 427 3 view .LVU692
 427:bus_access.c  **** 	}
 1832               		.loc 1 427 19 is_stmt 0 view .LVU693
 1833 0340 45BB      		out 0x15,r20
 429:bus_access.c  **** }
 1834               		.loc 1 429 2 is_stmt 1 view .LVU694
 429:bus_access.c  **** }
 1835               		.loc 1 429 18 is_stmt 0 view .LVU695
 1836 0342 35BB      		out 0x15,r19
 1837               	.LVL127:
 429:bus_access.c  **** }
 1838               		.loc 1 429 18 view .LVU696
 1839               	.LBE324:
 1840               	.LBE328:
 449:bus_access.c  **** 		t++;
 1841               		.loc 1 449 3 is_stmt 1 view .LVU697
 1842               		.loc 1 449 4 is_stmt 0 view .LVU698
 1843 0344 3396      		adiw r30,3
 1844               	.LVL128:
 450:bus_access.c  **** 		length--;
 1845               		.loc 1 450 3 is_stmt 1 view .LVU699
 447:bus_access.c  **** 		cpu_write_flash_waveform(t->address, t->data);
 1846               		.loc 1 447 7 view .LVU700
 1847 0346 EA17      		cp r30,r26
 1848 0348 FB07      		cpc r31,r27
 1849 034a 01F4      		brne .L77
 451:bus_access.c  **** 	}
 452:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
 1850               		.loc 1 452 2 view .LVU701
 1851               	.LVL129:
 1852               	.LBB329:
 1853               	.LBI329:
 117:bus_access.c  **** {
 1854               		.loc 1 117 13 view .LVU702
 1855               	.LBB330:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1856               		.loc 1 119 2 view .LVU703
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 1857               		.loc 1 119 23 is_stmt 0 view .LVU704
 1858 034c 8FEF      		ldi r24,lo8(-1)
 1859 034e 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 1860               		.loc 1 120 2 is_stmt 1 view .LVU705
 1861               	.LVL130:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 1862               		.loc 1 121 2 view .LVU706
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1863               		.loc 1 124 2 view .LVU707
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 1864               		.loc 1 124 14 is_stmt 0 view .LVU708
 1865 0350 9FE3      		ldi r25,lo8(63)
 1866 0352 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1867               		.loc 1 126 2 is_stmt 1 view .LVU709
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1868               		.loc 1 126 18 is_stmt 0 view .LVU710
 1869 0354 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 1870               		.loc 1 127 2 is_stmt 1 view .LVU711
 127:bus_access.c  **** }
 1871               		.loc 1 127 18 is_stmt 0 view .LVU712
 1872 0356 35BB      		out 0x15,r19
 1873               	.LVL131:
 1874               	/* epilogue start */
 127:bus_access.c  **** }
 1875               		.loc 1 127 18 view .LVU713
 1876               	.LBE330:
 1877               	.LBE329:
 453:bus_access.c  **** }
 1878               		.loc 1 453 1 view .LVU714
 1879 0358 0895      		ret
 1880               		.cfi_endproc
 1881               	.LFE24:
 1883               	.global	cpu_write_6502
 1885               	cpu_write_6502:
 1886               	.LVL132:
 1887               	.LFB25:
 454:bus_access.c  **** /*
 455:bus_access.c  **** NTSC hardware timing
 456:bus_access.c  **** Master clock fsc: 21.4772272 MHz
 457:bus_access.c  **** CPU clock fsc/12: 1.789773MHz
 458:bus_access.c  **** clock per second 12/fsc: 5.58*10**-7 sec, 0.55 us
 459:bus_access.c  **** */
 460:bus_access.c  **** void cpu_write_6502(uint16_t address, uint16_t length, const uint8_t *data)
 461:bus_access.c  **** {
 1888               		.loc 1 461 1 is_stmt 1 view -0
 1889               		.cfi_startproc
 1890               		.loc 1 461 1 is_stmt 0 view .LVU716
 1891 035a 1F93      		push r17
 1892               	.LCFI0:
 1893               		.cfi_def_cfa_offset 3
 1894               		.cfi_offset 17, -2
 1895 035c CF93      		push r28
 1896               	.LCFI1:
 1897               		.cfi_def_cfa_offset 4
 1898               		.cfi_offset 28, -3
 1899 035e DF93      		push r29
 1900               	.LCFI2:
 1901               		.cfi_def_cfa_offset 5
 1902               		.cfi_offset 29, -4
 1903               	/* prologue: function */
 1904               	/* frame size = 0 */
 1905               	/* stack size = 3 */
 1906               	.L__stack_usage = 3
 1907 0360 9C01      		movw r18,r24
 1908 0362 CB01      		movw r24,r22
 1909               	.LVL133:
 1910               		.loc 1 461 1 view .LVU717
 1911 0364 FA01      		movw r30,r20
 462:bus_access.c  **** 	while(length != 0){
 1912               		.loc 1 462 2 is_stmt 1 view .LVU718
 1913               		.loc 1 462 7 view .LVU719
 1914 0366 0097      		sbiw r24,0
 1915 0368 01F0      		breq .L85
 1916 036a B901      		movw r22,r18
 1917               	.LVL134:
 1918               		.loc 1 462 7 is_stmt 0 view .LVU720
 1919 036c 680F      		add r22,r24
 1920 036e 791F      		adc r23,r25
 1921               	.LBB331:
 1922               	.LBB332:
 1923               	.LBB333:
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 1924               		.loc 1 126 18 view .LVU721
 1925 0370 BFEF      		ldi r27,lo8(-1)
 127:bus_access.c  **** }
 1926               		.loc 1 127 18 view .LVU722
 1927 0372 9EE7      		ldi r25,lo8(126)
 1928               	.LBE333:
 1929               	.LBE332:
 463:bus_access.c  **** 		uint8_t control;
 464:bus_access.c  **** 		address_set(address);
 465:bus_access.c  **** 		
 466:bus_access.c  **** 		//phi2 down
 467:bus_access.c  **** #if PCB_REVISION == 1
 468:bus_access.c  **** 		control = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(CPU_RW) & bit_get_negative(CPU_
 469:bus_access.c  **** #endif
 470:bus_access.c  **** #if PCB_REVISION == 2
 471:bus_access.c  **** 		control = bit_get_negative(CPU_RW) & bit_get_negative(CPU_PHI2);
 472:bus_access.c  **** #endif
 473:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1930               		.loc 1 473 19 view .LVU723
 1931 0374 AAE7      		ldi r26,lo8(122)
 474:bus_access.c  **** 		clock_wait(1);
 475:bus_access.c  **** 
 476:bus_access.c  **** 		//phi2 up
 477:bus_access.c  **** 		if((address & 0x8000) != 0){
 478:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 479:bus_access.c  **** 		}
 480:bus_access.c  **** 
 481:bus_access.c  **** 		control |= (1 << CPU_PHI2);
 482:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1932               		.loc 1 482 19 view .LVU724
 1933 0376 19E7      		ldi r17,lo8(121)
 483:bus_access.c  **** 		//data set
 484:bus_access.c  **** 		DATABUS_OUT = *data;
 485:bus_access.c  **** 		data++;
 486:bus_access.c  **** 		clock_wait(1);
 487:bus_access.c  **** 		
 488:bus_access.c  **** 		//phi2 down
 489:bus_access.c  **** 		control &= bit_get_negative(CPU_PHI2);
 490:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1934               		.loc 1 490 19 view .LVU725
 1935 0378 D8E7      		ldi r29,lo8(120)
 482:bus_access.c  **** 		//data set
 1936               		.loc 1 482 19 view .LVU726
 1937 037a CBE7      		ldi r28,lo8(123)
 1938 037c 00C0      		rjmp .L84
 1939               	.LVL135:
 1940               	.L89:
 481:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1941               		.loc 1 481 3 is_stmt 1 view .LVU727
 482:bus_access.c  **** 		//data set
 1942               		.loc 1 482 3 view .LVU728
 482:bus_access.c  **** 		//data set
 1943               		.loc 1 482 19 is_stmt 0 view .LVU729
 1944 037e C5BB      		out 0x15,r28
 484:bus_access.c  **** 		data++;
 1945               		.loc 1 484 3 is_stmt 1 view .LVU730
 484:bus_access.c  **** 		data++;
 1946               		.loc 1 484 17 is_stmt 0 view .LVU731
 1947 0380 8081      		ld r24,Z
 484:bus_access.c  **** 		data++;
 1948               		.loc 1 484 15 view .LVU732
 1949 0382 88BB      		out 0x18,r24
 485:bus_access.c  **** 		clock_wait(1);
 1950               		.loc 1 485 3 is_stmt 1 view .LVU733
 1951               	.LVL136:
 486:bus_access.c  **** 		
 1952               		.loc 1 486 3 view .LVU734
 1953               	.LBB335:
 1954               	.LBI335:
  32:bus_access.h  **** {
 1955               		.loc 2 32 20 view .LVU735
 1956               	.LBE335:
 1957               	.LBE331:
 1958               		.loc 2 34 2 view .LVU736
 1959               	.LBB352:
 1960               	.LBB340:
 1961               	.LBB336:
 1962               	.LBI336:
 255:/usr/avr/include/util/delay.h **** {
 1963               		.loc 3 255 1 view .LVU737
 1964               	.LBB337:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1965               		.loc 3 257 2 view .LVU738
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1966               		.loc 3 261 2 view .LVU739
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 1967               		.loc 3 262 2 view .LVU740
 263:/usr/avr/include/util/delay.h **** 
 1968               		.loc 3 263 2 view .LVU741
 273:/usr/avr/include/util/delay.h **** 	#endif
 1969               		.loc 3 273 3 view .LVU742
 1970               		.loc 3 276 2 view .LVU743
 1971 0384 83E0      		ldi r24,lo8(3)
 1972 0386 8A95      	1:	dec r24
 1973 0388 01F4      		brne 1b
 1974               	.LVL137:
 1975               		.loc 3 276 2 is_stmt 0 view .LVU744
 1976               	.LBE337:
 1977               	.LBE336:
 1978               	.LBE340:
 489:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1979               		.loc 1 489 3 is_stmt 1 view .LVU745
 489:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1980               		.loc 1 489 3 is_stmt 0 view .LVU746
 1981               	.LBE352:
 106:bus_access.c  **** 	return ~ret;
 1982               		.loc 1 106 2 is_stmt 1 view .LVU747
 107:bus_access.c  **** }
 1983               		.loc 1 107 2 view .LVU748
 1984               	.LBB353:
 1985               		.loc 1 490 3 view .LVU749
 1986               		.loc 1 490 19 is_stmt 0 view .LVU750
 1987 038a A5BB      		out 0x15,r26
 491:bus_access.c  **** 		if((address & 0x8000) != 0){
 1988               		.loc 1 491 3 is_stmt 1 view .LVU751
 468:bus_access.c  **** #endif
 1989               		.loc 1 468 11 is_stmt 0 view .LVU752
 1990 038c 8AE7      		ldi r24,lo8(122)
 1991               	.LVL138:
 1992               	.L86:
 492:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 493:bus_access.c  **** 		}
 494:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 1993               		.loc 1 494 3 is_stmt 1 view .LVU753
 1994               		.loc 1 494 19 is_stmt 0 view .LVU754
 1995 038e 85BB      		out 0x15,r24
 495:bus_access.c  **** 		
 496:bus_access.c  **** 		//bus close
 497:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 1996               		.loc 1 497 3 is_stmt 1 view .LVU755
 1997               		.loc 1 497 19 is_stmt 0 view .LVU756
 1998 0390 95BB      		out 0x15,r25
 498:bus_access.c  **** 		clock_wait(1);
 1999               		.loc 1 498 3 is_stmt 1 view .LVU757
 2000               	.LVL139:
 2001               	.LBB341:
 2002               	.LBI341:
  32:bus_access.h  **** {
 2003               		.loc 2 32 20 view .LVU758
 2004               	.LBE341:
 2005               	.LBE353:
 2006               		.loc 2 34 2 view .LVU759
 2007               	.LBB354:
 2008               	.LBB344:
 2009               	.LBB342:
 2010               	.LBI342:
 255:/usr/avr/include/util/delay.h **** {
 2011               		.loc 3 255 1 view .LVU760
 2012               	.LBB343:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2013               		.loc 3 257 2 view .LVU761
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2014               		.loc 3 261 2 view .LVU762
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2015               		.loc 3 262 2 view .LVU763
 263:/usr/avr/include/util/delay.h **** 
 2016               		.loc 3 263 2 view .LVU764
 273:/usr/avr/include/util/delay.h **** 	#endif
 2017               		.loc 3 273 3 view .LVU765
 2018               		.loc 3 276 2 view .LVU766
 2019 0392 83E0      		ldi r24,lo8(3)
 2020 0394 8A95      	1:	dec r24
 2021 0396 01F4      		brne 1b
 2022               	.LVL140:
 2023               		.loc 3 276 2 is_stmt 0 view .LVU767
 2024               	.LBE343:
 2025               	.LBE342:
 2026               	.LBE344:
 499:bus_access.c  **** 		
 500:bus_access.c  **** 		address += 1;
 2027               		.loc 1 500 3 is_stmt 1 view .LVU768
 2028               		.loc 1 500 11 is_stmt 0 view .LVU769
 2029 0398 2F5F      		subi r18,-1
 2030 039a 3F4F      		sbci r19,-1
 2031               	.LVL141:
 501:bus_access.c  **** 		length--;
 2032               		.loc 1 501 3 is_stmt 1 view .LVU770
 2033               		.loc 1 501 3 is_stmt 0 view .LVU771
 2034               	.LBE354:
 462:bus_access.c  **** 		uint8_t control;
 2035               		.loc 1 462 7 is_stmt 1 view .LVU772
 2036 039c 2617      		cp r18,r22
 2037 039e 3707      		cpc r19,r23
 2038 03a0 01F0      		breq .L85
 462:bus_access.c  **** 		uint8_t control;
 2039               		.loc 1 462 7 is_stmt 0 view .LVU773
 2040 03a2 FA01      		movw r30,r20
 2041               	.LVL142:
 2042               	.L84:
 2043               	.LBB355:
 463:bus_access.c  **** 		address_set(address);
 2044               		.loc 1 463 3 is_stmt 1 view .LVU774
 464:bus_access.c  **** 		
 2045               		.loc 1 464 3 view .LVU775
 2046               	.LBB345:
 2047               	.LBI332:
 117:bus_access.c  **** {
 2048               		.loc 1 117 13 view .LVU776
 2049               	.LBB334:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2050               		.loc 1 119 2 view .LVU777
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2051               		.loc 1 119 23 is_stmt 0 view .LVU778
 2052 03a4 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2053               		.loc 1 120 2 is_stmt 1 view .LVU779
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2054               		.loc 1 120 10 is_stmt 0 view .LVU780
 2055 03a6 832F      		mov r24,r19
 2056 03a8 8F77      		andi r24,lo8(127)
 2057               	.LVL143:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2058               		.loc 1 121 2 is_stmt 1 view .LVU781
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2059               		.loc 1 121 4 is_stmt 0 view .LVU782
 2060 03aa 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 2061               		.loc 1 122 3 is_stmt 1 view .LVU783
 122:bus_access.c  **** 	}
 2062               		.loc 1 122 8 is_stmt 0 view .LVU784
 2063 03ac 8068      		ori r24,lo8(-128)
 2064               	.LVL144:
 2065               	.L81:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2066               		.loc 1 124 2 is_stmt 1 view .LVU785
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2067               		.loc 1 124 14 is_stmt 0 view .LVU786
 2068 03ae 88BB      		out 0x18,r24
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2069               		.loc 1 126 2 is_stmt 1 view .LVU787
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2070               		.loc 1 126 18 is_stmt 0 view .LVU788
 2071 03b0 B5BB      		out 0x15,r27
 127:bus_access.c  **** }
 2072               		.loc 1 127 2 is_stmt 1 view .LVU789
 127:bus_access.c  **** }
 2073               		.loc 1 127 18 is_stmt 0 view .LVU790
 2074 03b2 95BB      		out 0x15,r25
 2075               	.LVL145:
 127:bus_access.c  **** }
 2076               		.loc 1 127 18 view .LVU791
 2077               	.LBE334:
 2078               	.LBE345:
 468:bus_access.c  **** #endif
 2079               		.loc 1 468 3 is_stmt 1 view .LVU792
 468:bus_access.c  **** #endif
 2080               		.loc 1 468 3 is_stmt 0 view .LVU793
 2081               	.LBE355:
 106:bus_access.c  **** 	return ~ret;
 2082               		.loc 1 106 2 is_stmt 1 view .LVU794
 107:bus_access.c  **** }
 2083               		.loc 1 107 2 view .LVU795
 106:bus_access.c  **** 	return ~ret;
 2084               		.loc 1 106 2 view .LVU796
 107:bus_access.c  **** }
 2085               		.loc 1 107 2 view .LVU797
 106:bus_access.c  **** 	return ~ret;
 2086               		.loc 1 106 2 view .LVU798
 107:bus_access.c  **** }
 2087               		.loc 1 107 2 view .LVU799
 2088               	.LBB356:
 473:bus_access.c  **** 		clock_wait(1);
 2089               		.loc 1 473 3 view .LVU800
 473:bus_access.c  **** 		clock_wait(1);
 2090               		.loc 1 473 19 is_stmt 0 view .LVU801
 2091 03b4 A5BB      		out 0x15,r26
 474:bus_access.c  **** 
 2092               		.loc 1 474 3 is_stmt 1 view .LVU802
 2093               	.LVL146:
 2094               	.LBB346:
 2095               	.LBI346:
  32:bus_access.h  **** {
 2096               		.loc 2 32 20 view .LVU803
 2097               	.LBE346:
 2098               	.LBE356:
 2099               		.loc 2 34 2 view .LVU804
 2100               	.LBB357:
 2101               	.LBB349:
 2102               	.LBB347:
 2103               	.LBI347:
 255:/usr/avr/include/util/delay.h **** {
 2104               		.loc 3 255 1 view .LVU805
 2105               	.LBB348:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2106               		.loc 3 257 2 view .LVU806
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2107               		.loc 3 261 2 view .LVU807
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2108               		.loc 3 262 2 view .LVU808
 263:/usr/avr/include/util/delay.h **** 
 2109               		.loc 3 263 2 view .LVU809
 273:/usr/avr/include/util/delay.h **** 	#endif
 2110               		.loc 3 273 3 view .LVU810
 2111               		.loc 3 276 2 view .LVU811
 2112 03b6 83E0      		ldi r24,lo8(3)
 2113 03b8 8A95      	1:	dec r24
 2114 03ba 01F4      		brne 1b
 2115               	.LVL147:
 2116               		.loc 3 276 2 is_stmt 0 view .LVU812
 2117               	.LBE348:
 2118               	.LBE347:
 2119               	.LBE349:
 477:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 2120               		.loc 1 477 3 is_stmt 1 view .LVU813
 2121 03bc AF01      		movw r20,r30
 2122               	.LVL148:
 477:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 2123               		.loc 1 477 3 is_stmt 0 view .LVU814
 2124 03be 4F5F      		subi r20,-1
 2125 03c0 5F4F      		sbci r21,-1
 477:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 2126               		.loc 1 477 5 view .LVU815
 2127 03c2 37FF      		sbrs r19,7
 2128 03c4 00C0      		rjmp .L89
 478:bus_access.c  **** 		}
 2129               		.loc 1 478 4 is_stmt 1 view .LVU816
 2130               	.LVL149:
 478:bus_access.c  **** 		}
 2131               		.loc 1 478 4 is_stmt 0 view .LVU817
 2132               	.LBE357:
 106:bus_access.c  **** 	return ~ret;
 2133               		.loc 1 106 2 is_stmt 1 view .LVU818
 107:bus_access.c  **** }
 2134               		.loc 1 107 2 view .LVU819
 2135               	.LBB358:
 481:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 2136               		.loc 1 481 3 view .LVU820
 482:bus_access.c  **** 		//data set
 2137               		.loc 1 482 3 view .LVU821
 482:bus_access.c  **** 		//data set
 2138               		.loc 1 482 19 is_stmt 0 view .LVU822
 2139 03c6 15BB      		out 0x15,r17
 484:bus_access.c  **** 		data++;
 2140               		.loc 1 484 3 is_stmt 1 view .LVU823
 484:bus_access.c  **** 		data++;
 2141               		.loc 1 484 17 is_stmt 0 view .LVU824
 2142 03c8 8081      		ld r24,Z
 484:bus_access.c  **** 		data++;
 2143               		.loc 1 484 15 view .LVU825
 2144 03ca 88BB      		out 0x18,r24
 485:bus_access.c  **** 		clock_wait(1);
 2145               		.loc 1 485 3 is_stmt 1 view .LVU826
 2146               	.LVL150:
 486:bus_access.c  **** 		
 2147               		.loc 1 486 3 view .LVU827
 2148               	.LBB350:
  32:bus_access.h  **** {
 2149               		.loc 2 32 20 view .LVU828
 2150               	.LBE350:
 2151               	.LBE358:
 2152               		.loc 2 34 2 view .LVU829
 2153               	.LBB359:
 2154               	.LBB351:
 2155               	.LBB339:
 255:/usr/avr/include/util/delay.h **** {
 2156               		.loc 3 255 1 view .LVU830
 2157               	.LBB338:
 257:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2158               		.loc 3 257 2 view .LVU831
 261:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2159               		.loc 3 261 2 view .LVU832
 262:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2160               		.loc 3 262 2 view .LVU833
 263:/usr/avr/include/util/delay.h **** 
 2161               		.loc 3 263 2 view .LVU834
 273:/usr/avr/include/util/delay.h **** 	#endif
 2162               		.loc 3 273 3 view .LVU835
 2163               		.loc 3 276 2 view .LVU836
 2164 03cc 83E0      		ldi r24,lo8(3)
 2165 03ce 8A95      	1:	dec r24
 2166 03d0 01F4      		brne 1b
 2167               	.LVL151:
 2168               		.loc 3 276 2 is_stmt 0 view .LVU837
 2169               	.LBE338:
 2170               	.LBE339:
 2171               	.LBE351:
 489:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 2172               		.loc 1 489 3 is_stmt 1 view .LVU838
 489:bus_access.c  **** 		BUS_CONTROL_OUT = control;
 2173               		.loc 1 489 3 is_stmt 0 view .LVU839
 2174               	.LBE359:
 106:bus_access.c  **** 	return ~ret;
 2175               		.loc 1 106 2 is_stmt 1 view .LVU840
 107:bus_access.c  **** }
 2176               		.loc 1 107 2 view .LVU841
 2177               	.LBB360:
 490:bus_access.c  **** 		if((address & 0x8000) != 0){
 2178               		.loc 1 490 3 view .LVU842
 490:bus_access.c  **** 		if((address & 0x8000) != 0){
 2179               		.loc 1 490 19 is_stmt 0 view .LVU843
 2180 03d2 D5BB      		out 0x15,r29
 491:bus_access.c  **** 			control &= bit_get_negative(CPU_ROMCS);
 2181               		.loc 1 491 3 is_stmt 1 view .LVU844
 492:bus_access.c  **** 		}
 2182               		.loc 1 492 12 is_stmt 0 view .LVU845
 2183 03d4 88E7      		ldi r24,lo8(120)
 2184 03d6 00C0      		rjmp .L86
 2185               	.LVL152:
 2186               	.L85:
 492:bus_access.c  **** 		}
 2187               		.loc 1 492 12 view .LVU846
 2188               	.LBE360:
 502:bus_access.c  **** 	}
 503:bus_access.c  **** 	address_set(ADDRESS_CLOSE);
 2189               		.loc 1 503 2 is_stmt 1 view .LVU847
 2190               	.LBB361:
 2191               	.LBI361:
 117:bus_access.c  **** {
 2192               		.loc 1 117 13 view .LVU848
 2193               	.LBB362:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2194               		.loc 1 119 2 view .LVU849
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2195               		.loc 1 119 23 is_stmt 0 view .LVU850
 2196 03d8 8FEF      		ldi r24,lo8(-1)
 2197 03da 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2198               		.loc 1 120 2 is_stmt 1 view .LVU851
 2199               	.LVL153:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2200               		.loc 1 121 2 view .LVU852
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2201               		.loc 1 124 2 view .LVU853
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2202               		.loc 1 124 14 is_stmt 0 view .LVU854
 2203 03dc 9FE3      		ldi r25,lo8(63)
 2204 03de 98BB      		out 0x18,r25
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2205               		.loc 1 126 2 is_stmt 1 view .LVU855
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2206               		.loc 1 126 18 is_stmt 0 view .LVU856
 2207 03e0 85BB      		out 0x15,r24
 127:bus_access.c  **** }
 2208               		.loc 1 127 2 is_stmt 1 view .LVU857
 127:bus_access.c  **** }
 2209               		.loc 1 127 18 is_stmt 0 view .LVU858
 2210 03e2 8EE7      		ldi r24,lo8(126)
 2211 03e4 85BB      		out 0x15,r24
 2212               	.LVL154:
 2213               	/* epilogue start */
 127:bus_access.c  **** }
 2214               		.loc 1 127 18 view .LVU859
 2215               	.LBE362:
 2216               	.LBE361:
 504:bus_access.c  **** }
 2217               		.loc 1 504 1 view .LVU860
 2218 03e6 DF91      		pop r29
 2219 03e8 CF91      		pop r28
 2220 03ea 1F91      		pop r17
 2221 03ec 0895      		ret
 2222               		.cfi_endproc
 2223               	.LFE25:
 2225               	.global	ppu_write
 2227               	ppu_write:
 2228               	.LVL155:
 2229               	.LFB27:
 505:bus_access.c  **** 
 506:bus_access.c  **** static inline void ppu_write_waveform(uint16_t address, uint8_t data)
 507:bus_access.c  **** {
 508:bus_access.c  **** 	address_set(address);//PPU charcter memory /CS open
 509:bus_access.c  **** #if PCB_REVISION == 1
 510:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(PPU_WR) & bit_get_negati
 511:bus_access.c  **** #endif
 512:bus_access.c  **** #if PCB_REVISION == 2
 513:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(PPU_WR) & bit_get_negative(CPU_PHI2);
 514:bus_access.c  **** #endif
 515:bus_access.c  **** 	DATABUS_OUT = data;
 516:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 517:bus_access.c  **** 	address_set(0x3fff); ///CS close, use pallete area. When address bus is 0x2000-0x2fff, some cartri
 518:bus_access.c  **** }
 519:bus_access.c  **** void ppu_write(uint16_t address, uint16_t length, const uint8_t *data)
 520:bus_access.c  **** {
 2230               		.loc 1 520 1 is_stmt 1 view -0
 2231               		.cfi_startproc
 2232               	/* prologue: function */
 2233               	/* frame size = 0 */
 2234               	/* stack size = 0 */
 2235               	.L__stack_usage = 0
 2236               		.loc 1 520 1 is_stmt 0 view .LVU862
 2237 03ee 9C01      		movw r18,r24
 2238 03f0 CB01      		movw r24,r22
 2239               	.LVL156:
 521:bus_access.c  **** 	while(length != 0){
 2240               		.loc 1 521 2 is_stmt 1 view .LVU863
 2241               		.loc 1 521 7 view .LVU864
 2242 03f2 0097      		sbiw r24,0
 2243 03f4 01F0      		breq .L90
 2244 03f6 FA01      		movw r30,r20
 2245 03f8 B901      		movw r22,r18
 2246               	.LVL157:
 2247               		.loc 1 521 7 is_stmt 0 view .LVU865
 2248 03fa 680F      		add r22,r24
 2249 03fc 791F      		adc r23,r25
 2250               	.LBB363:
 2251               	.LBB364:
 2252               	.LBB365:
 2253               	.LBB366:
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2254               		.loc 1 126 18 view .LVU866
 2255 03fe 9FEF      		ldi r25,lo8(-1)
 127:bus_access.c  **** }
 2256               		.loc 1 127 18 view .LVU867
 2257 0400 8EE7      		ldi r24,lo8(126)
 2258               	.LVL158:
 127:bus_access.c  **** }
 2259               		.loc 1 127 18 view .LVU868
 2260               	.LBE366:
 2261               	.LBE365:
 510:bus_access.c  **** #endif
 2262               		.loc 1 510 18 view .LVU869
 2263 0402 BEE5      		ldi r27,lo8(94)
 2264               	.LBB368:
 2265               	.LBB369:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2266               		.loc 1 124 14 view .LVU870
 2267 0404 AFE3      		ldi r26,lo8(63)
 2268               	.LVL159:
 2269               	.L93:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2270               		.loc 1 124 14 view .LVU871
 2271               	.LBE369:
 2272               	.LBE368:
 2273               	.LBE364:
 2274               	.LBE363:
 522:bus_access.c  **** 		ppu_write_waveform(address, *data);
 2275               		.loc 1 522 3 is_stmt 1 view .LVU872
 2276 0406 5191      		ld r21,Z+
 2277               	.LVL160:
 2278               	.LBB375:
 2279               	.LBI363:
 506:bus_access.c  **** {
 2280               		.loc 1 506 20 view .LVU873
 2281               	.LBB373:
 508:bus_access.c  **** #if PCB_REVISION == 1
 2282               		.loc 1 508 2 view .LVU874
 2283               	.LBB371:
 2284               	.LBI365:
 117:bus_access.c  **** {
 2285               		.loc 1 117 13 view .LVU875
 2286               	.LBB367:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2287               		.loc 1 119 2 view .LVU876
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2288               		.loc 1 119 23 is_stmt 0 view .LVU877
 2289 0408 2BBB      		out 0x1b,r18
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2290               		.loc 1 120 2 is_stmt 1 view .LVU878
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2291               		.loc 1 120 10 is_stmt 0 view .LVU879
 2292 040a 432F      		mov r20,r19
 2293 040c 4F77      		andi r20,lo8(127)
 2294               	.LVL161:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2295               		.loc 1 121 2 is_stmt 1 view .LVU880
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2296               		.loc 1 121 4 is_stmt 0 view .LVU881
 2297 040e 35FF      		sbrs r19,5
 122:bus_access.c  **** 	}
 2298               		.loc 1 122 3 is_stmt 1 view .LVU882
 122:bus_access.c  **** 	}
 2299               		.loc 1 122 8 is_stmt 0 view .LVU883
 2300 0410 4068      		ori r20,lo8(-128)
 2301               	.LVL162:
 2302               	.L92:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2303               		.loc 1 124 2 is_stmt 1 view .LVU884
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2304               		.loc 1 124 14 is_stmt 0 view .LVU885
 2305 0412 48BB      		out 0x18,r20
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2306               		.loc 1 126 2 is_stmt 1 view .LVU886
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2307               		.loc 1 126 18 is_stmt 0 view .LVU887
 2308 0414 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 2309               		.loc 1 127 2 is_stmt 1 view .LVU888
 127:bus_access.c  **** }
 2310               		.loc 1 127 18 is_stmt 0 view .LVU889
 2311 0416 85BB      		out 0x15,r24
 2312               	.LVL163:
 127:bus_access.c  **** }
 2313               		.loc 1 127 18 view .LVU890
 2314               	.LBE367:
 2315               	.LBE371:
 510:bus_access.c  **** #endif
 2316               		.loc 1 510 2 is_stmt 1 view .LVU891
 510:bus_access.c  **** #endif
 2317               		.loc 1 510 2 is_stmt 0 view .LVU892
 2318               	.LBE373:
 2319               	.LBE375:
 106:bus_access.c  **** 	return ~ret;
 2320               		.loc 1 106 2 is_stmt 1 view .LVU893
 107:bus_access.c  **** }
 2321               		.loc 1 107 2 view .LVU894
 106:bus_access.c  **** 	return ~ret;
 2322               		.loc 1 106 2 view .LVU895
 107:bus_access.c  **** }
 2323               		.loc 1 107 2 view .LVU896
 106:bus_access.c  **** 	return ~ret;
 2324               		.loc 1 106 2 view .LVU897
 107:bus_access.c  **** }
 2325               		.loc 1 107 2 view .LVU898
 2326               	.LBB376:
 2327               	.LBB374:
 510:bus_access.c  **** #endif
 2328               		.loc 1 510 18 is_stmt 0 view .LVU899
 2329 0418 B5BB      		out 0x15,r27
 515:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2330               		.loc 1 515 2 is_stmt 1 view .LVU900
 515:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2331               		.loc 1 515 14 is_stmt 0 view .LVU901
 2332 041a 58BB      		out 0x18,r21
 516:bus_access.c  **** 	address_set(0x3fff); ///CS close, use pallete area. When address bus is 0x2000-0x2fff, some cartri
 2333               		.loc 1 516 2 is_stmt 1 view .LVU902
 516:bus_access.c  **** 	address_set(0x3fff); ///CS close, use pallete area. When address bus is 0x2000-0x2fff, some cartri
 2334               		.loc 1 516 18 is_stmt 0 view .LVU903
 2335 041c 85BB      		out 0x15,r24
 517:bus_access.c  **** }
 2336               		.loc 1 517 2 is_stmt 1 view .LVU904
 2337               	.LVL164:
 2338               	.LBB372:
 2339               	.LBI368:
 117:bus_access.c  **** {
 2340               		.loc 1 117 13 view .LVU905
 2341               	.LBB370:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2342               		.loc 1 119 2 view .LVU906
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2343               		.loc 1 119 23 is_stmt 0 view .LVU907
 2344 041e 9BBB      		out 0x1b,r25
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2345               		.loc 1 120 2 is_stmt 1 view .LVU908
 2346               	.LVL165:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2347               		.loc 1 121 2 view .LVU909
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2348               		.loc 1 124 2 view .LVU910
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2349               		.loc 1 124 14 is_stmt 0 view .LVU911
 2350 0420 A8BB      		out 0x18,r26
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2351               		.loc 1 126 2 is_stmt 1 view .LVU912
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2352               		.loc 1 126 18 is_stmt 0 view .LVU913
 2353 0422 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 2354               		.loc 1 127 2 is_stmt 1 view .LVU914
 127:bus_access.c  **** }
 2355               		.loc 1 127 18 is_stmt 0 view .LVU915
 2356 0424 85BB      		out 0x15,r24
 2357               	.LVL166:
 127:bus_access.c  **** }
 2358               		.loc 1 127 18 view .LVU916
 2359               	.LBE370:
 2360               	.LBE372:
 2361               	.LBE374:
 2362               	.LBE376:
 523:bus_access.c  **** 		data++;
 2363               		.loc 1 523 3 is_stmt 1 view .LVU917
 524:bus_access.c  **** 		address += 1;
 2364               		.loc 1 524 3 view .LVU918
 2365               		.loc 1 524 11 is_stmt 0 view .LVU919
 2366 0426 2F5F      		subi r18,-1
 2367 0428 3F4F      		sbci r19,-1
 2368               	.LVL167:
 525:bus_access.c  **** 		length--;
 2369               		.loc 1 525 3 is_stmt 1 view .LVU920
 521:bus_access.c  **** 		ppu_write_waveform(address, *data);
 2370               		.loc 1 521 7 view .LVU921
 2371 042a 2617      		cp r18,r22
 2372 042c 3707      		cpc r19,r23
 2373 042e 01F4      		brne .L93
 2374               	.LVL168:
 2375               	.L90:
 2376               	/* epilogue start */
 526:bus_access.c  **** 	}
 527:bus_access.c  **** }
 2377               		.loc 1 527 1 is_stmt 0 view .LVU922
 2378 0430 0895      		ret
 2379               		.cfi_endproc
 2380               	.LFE27:
 2382               	.global	ppu_write_order
 2384               	ppu_write_order:
 2385               	.LVL169:
 2386               	.LFB28:
 528:bus_access.c  **** 
 529:bus_access.c  **** void ppu_write_order(const struct flash_order *t)
 530:bus_access.c  **** {
 2387               		.loc 1 530 1 is_stmt 1 view -0
 2388               		.cfi_startproc
 2389               	/* prologue: function */
 2390               	/* frame size = 0 */
 2391               	/* stack size = 0 */
 2392               	.L__stack_usage = 0
 2393               		.loc 1 530 1 is_stmt 0 view .LVU924
 2394 0432 FC01      		movw r30,r24
 531:bus_access.c  **** 	int length = FLASH_PROGRAM_ORDER;
 2395               		.loc 1 531 2 is_stmt 1 view .LVU925
 2396               	.LVL170:
 532:bus_access.c  **** 	while(length != 0){
 2397               		.loc 1 532 2 view .LVU926
 2398               		.loc 1 532 7 view .LVU927
 2399 0434 DC01      		movw r26,r24
 2400 0436 1996      		adiw r26,9
 2401               	.LBB377:
 2402               	.LBB378:
 2403               	.LBB379:
 2404               	.LBB380:
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2405               		.loc 1 126 18 is_stmt 0 view .LVU928
 2406 0438 3FEF      		ldi r19,lo8(-1)
 127:bus_access.c  **** }
 2407               		.loc 1 127 18 view .LVU929
 2408 043a 2EE7      		ldi r18,lo8(126)
 2409               	.LBE380:
 2410               	.LBE379:
 510:bus_access.c  **** #endif
 2411               		.loc 1 510 18 view .LVU930
 2412 043c 7EE5      		ldi r23,lo8(94)
 2413               	.LBB382:
 2414               	.LBB383:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2415               		.loc 1 124 14 view .LVU931
 2416 043e 6FE3      		ldi r22,lo8(63)
 2417               	.LVL171:
 2418               	.L100:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2419               		.loc 1 124 14 view .LVU932
 2420               	.LBE383:
 2421               	.LBE382:
 2422               	.LBE378:
 2423               	.LBE377:
 533:bus_access.c  **** 		ppu_write_waveform(t->address, t->data);
 2424               		.loc 1 533 3 is_stmt 1 view .LVU933
 2425 0440 5281      		ldd r21,Z+2
 2426 0442 8081      		ld r24,Z
 2427 0444 9181      		ldd r25,Z+1
 2428               	.LVL172:
 2429               	.LBB389:
 2430               	.LBI377:
 506:bus_access.c  **** {
 2431               		.loc 1 506 20 view .LVU934
 2432               	.LBB387:
 508:bus_access.c  **** #if PCB_REVISION == 1
 2433               		.loc 1 508 2 view .LVU935
 2434               	.LBB385:
 2435               	.LBI379:
 117:bus_access.c  **** {
 2436               		.loc 1 117 13 view .LVU936
 2437               	.LBB381:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2438               		.loc 1 119 2 view .LVU937
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2439               		.loc 1 119 23 is_stmt 0 view .LVU938
 2440 0446 8BBB      		out 0x1b,r24
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2441               		.loc 1 120 2 is_stmt 1 view .LVU939
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2442               		.loc 1 120 10 is_stmt 0 view .LVU940
 2443 0448 492F      		mov r20,r25
 2444 044a 4F77      		andi r20,lo8(127)
 2445               	.LVL173:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2446               		.loc 1 121 2 is_stmt 1 view .LVU941
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2447               		.loc 1 121 4 is_stmt 0 view .LVU942
 2448 044c 95FF      		sbrs r25,5
 122:bus_access.c  **** 	}
 2449               		.loc 1 122 3 is_stmt 1 view .LVU943
 122:bus_access.c  **** 	}
 2450               		.loc 1 122 8 is_stmt 0 view .LVU944
 2451 044e 4068      		ori r20,lo8(-128)
 2452               	.LVL174:
 2453               	.L99:
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2454               		.loc 1 124 2 is_stmt 1 view .LVU945
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2455               		.loc 1 124 14 is_stmt 0 view .LVU946
 2456 0450 48BB      		out 0x18,r20
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2457               		.loc 1 126 2 is_stmt 1 view .LVU947
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2458               		.loc 1 126 18 is_stmt 0 view .LVU948
 2459 0452 35BB      		out 0x15,r19
 127:bus_access.c  **** }
 2460               		.loc 1 127 2 is_stmt 1 view .LVU949
 127:bus_access.c  **** }
 2461               		.loc 1 127 18 is_stmt 0 view .LVU950
 2462 0454 25BB      		out 0x15,r18
 2463               	.LVL175:
 127:bus_access.c  **** }
 2464               		.loc 1 127 18 view .LVU951
 2465               	.LBE381:
 2466               	.LBE385:
 510:bus_access.c  **** #endif
 2467               		.loc 1 510 2 is_stmt 1 view .LVU952
 510:bus_access.c  **** #endif
 2468               		.loc 1 510 2 is_stmt 0 view .LVU953
 2469               	.LBE387:
 2470               	.LBE389:
 106:bus_access.c  **** 	return ~ret;
 2471               		.loc 1 106 2 is_stmt 1 view .LVU954
 107:bus_access.c  **** }
 2472               		.loc 1 107 2 view .LVU955
 106:bus_access.c  **** 	return ~ret;
 2473               		.loc 1 106 2 view .LVU956
 107:bus_access.c  **** }
 2474               		.loc 1 107 2 view .LVU957
 106:bus_access.c  **** 	return ~ret;
 2475               		.loc 1 106 2 view .LVU958
 107:bus_access.c  **** }
 2476               		.loc 1 107 2 view .LVU959
 2477               	.LBB390:
 2478               	.LBB388:
 510:bus_access.c  **** #endif
 2479               		.loc 1 510 18 is_stmt 0 view .LVU960
 2480 0456 75BB      		out 0x15,r23
 515:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2481               		.loc 1 515 2 is_stmt 1 view .LVU961
 515:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2482               		.loc 1 515 14 is_stmt 0 view .LVU962
 2483 0458 58BB      		out 0x18,r21
 516:bus_access.c  **** 	address_set(0x3fff); ///CS close, use pallete area. When address bus is 0x2000-0x2fff, some cartri
 2484               		.loc 1 516 2 is_stmt 1 view .LVU963
 516:bus_access.c  **** 	address_set(0x3fff); ///CS close, use pallete area. When address bus is 0x2000-0x2fff, some cartri
 2485               		.loc 1 516 18 is_stmt 0 view .LVU964
 2486 045a 25BB      		out 0x15,r18
 517:bus_access.c  **** }
 2487               		.loc 1 517 2 is_stmt 1 view .LVU965
 2488               	.LVL176:
 2489               	.LBB386:
 2490               	.LBI382:
 117:bus_access.c  **** {
 2491               		.loc 1 117 13 view .LVU966
 2492               	.LBB384:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2493               		.loc 1 119 2 view .LVU967
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2494               		.loc 1 119 23 is_stmt 0 view .LVU968
 2495 045c 3BBB      		out 0x1b,r19
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2496               		.loc 1 120 2 is_stmt 1 view .LVU969
 2497               	.LVL177:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2498               		.loc 1 121 2 view .LVU970
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2499               		.loc 1 124 2 view .LVU971
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2500               		.loc 1 124 14 is_stmt 0 view .LVU972
 2501 045e 68BB      		out 0x18,r22
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2502               		.loc 1 126 2 is_stmt 1 view .LVU973
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2503               		.loc 1 126 18 is_stmt 0 view .LVU974
 2504 0460 35BB      		out 0x15,r19
 127:bus_access.c  **** }
 2505               		.loc 1 127 2 is_stmt 1 view .LVU975
 127:bus_access.c  **** }
 2506               		.loc 1 127 18 is_stmt 0 view .LVU976
 2507 0462 25BB      		out 0x15,r18
 2508               	.LVL178:
 127:bus_access.c  **** }
 2509               		.loc 1 127 18 view .LVU977
 2510               	.LBE384:
 2511               	.LBE386:
 2512               	.LBE388:
 2513               	.LBE390:
 534:bus_access.c  **** 		t++;
 2514               		.loc 1 534 3 is_stmt 1 view .LVU978
 2515               		.loc 1 534 4 is_stmt 0 view .LVU979
 2516 0464 3396      		adiw r30,3
 2517               	.LVL179:
 535:bus_access.c  **** 		length--;
 2518               		.loc 1 535 3 is_stmt 1 view .LVU980
 532:bus_access.c  **** 		ppu_write_waveform(t->address, t->data);
 2519               		.loc 1 532 7 view .LVU981
 2520 0466 EA17      		cp r30,r26
 2521 0468 FB07      		cpc r31,r27
 2522 046a 01F4      		brne .L100
 2523               	/* epilogue start */
 536:bus_access.c  **** 	}
 537:bus_access.c  **** }
 2524               		.loc 1 537 1 is_stmt 0 view .LVU982
 2525 046c 0895      		ret
 2526               		.cfi_endproc
 2527               	.LFE28:
 2529               	.global	vram_connection_get
 2531               	vram_connection_get:
 2532               	.LFB29:
 538:bus_access.c  **** 
 539:bus_access.c  **** uint8_t vram_connection_get(void)
 540:bus_access.c  **** {
 2533               		.loc 1 540 1 is_stmt 1 view -0
 2534               		.cfi_startproc
 2535               	/* prologue: function */
 2536               	/* frame size = 0 */
 2537               	/* stack size = 0 */
 2538               	.L__stack_usage = 0
 541:bus_access.c  **** 	uint8_t ret;
 2539               		.loc 1 541 2 view .LVU984
 542:bus_access.c  **** 	uint16_t address = 0x2000;
 2540               		.loc 1 542 2 view .LVU985
 2541               	.LVL180:
 543:bus_access.c  **** 	direction_write();
 2542               		.loc 1 543 2 view .LVU986
 2543               	.LBB391:
 2544               	.LBI391:
 194:bus_access.c  **** {
 2545               		.loc 1 194 20 view .LVU987
 2546               	.LBB392:
 196:bus_access.c  **** 	asm("nop");
 2547               		.loc 1 196 2 view .LVU988
 196:bus_access.c  **** 	asm("nop");
 2548               		.loc 1 196 14 is_stmt 0 view .LVU989
 2549 046e 9FEF      		ldi r25,lo8(-1)
 2550 0470 97BB      		out 0x17,r25
 197:bus_access.c  **** 	asm("nop");
 2551               		.loc 1 197 2 is_stmt 1 view .LVU990
 2552               	/* #APP */
 2553               	 ;  197 "bus_access.c" 1
 2554 0472 0000      		nop
 2555               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 2556               		.loc 1 198 2 view .LVU991
 2557               	 ;  198 "bus_access.c" 1
 2558 0474 0000      		nop
 2559               	 ;  0 "" 2
 199:bus_access.c  **** }
 2560               		.loc 1 199 2 view .LVU992
 2561               	 ;  199 "bus_access.c" 1
 2562 0476 0000      		nop
 2563               	 ;  0 "" 2
 2564               	/* #NOAPP */
 2565               	.LBE392:
 2566               	.LBE391:
 544:bus_access.c  **** 	address_set(address);
 2567               		.loc 1 544 2 view .LVU993
 2568               	.LVL181:
 2569               	.LBB393:
 2570               	.LBI393:
 117:bus_access.c  **** {
 2571               		.loc 1 117 13 view .LVU994
 2572               	.LBB394:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2573               		.loc 1 119 2 view .LVU995
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2574               		.loc 1 119 23 is_stmt 0 view .LVU996
 2575 0478 1BBA      		out 0x1b,__zero_reg__
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2576               		.loc 1 120 2 is_stmt 1 view .LVU997
 2577               	.LVL182:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2578               		.loc 1 121 2 view .LVU998
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2579               		.loc 1 124 2 view .LVU999
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2580               		.loc 1 124 14 is_stmt 0 view .LVU1000
 2581 047a 80E2      		ldi r24,lo8(32)
 2582 047c 88BB      		out 0x18,r24
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2583               		.loc 1 126 2 is_stmt 1 view .LVU1001
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2584               		.loc 1 126 18 is_stmt 0 view .LVU1002
 2585 047e 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 2586               		.loc 1 127 2 is_stmt 1 view .LVU1003
 127:bus_access.c  **** }
 2587               		.loc 1 127 18 is_stmt 0 view .LVU1004
 2588 0480 EEE7      		ldi r30,lo8(126)
 2589 0482 E5BB      		out 0x15,r30
 2590               	.LVL183:
 127:bus_access.c  **** }
 2591               		.loc 1 127 18 view .LVU1005
 2592               	.LBE394:
 2593               	.LBE393:
 545:bus_access.c  **** 	ret = bit_get(USB_MISC_IN, VRAM_A10);
 2594               		.loc 1 545 2 is_stmt 1 view .LVU1006
 2595               		.loc 1 545 8 is_stmt 0 view .LVU1007
 2596 0484 80B3      		in r24,0x10
 2597               	.LVL184:
 2598               	.LBB395:
 2599               	.LBI395:
 2600               		.file 4 "type.h"
   1:type.h        **** #ifndef _TYPE_H_
   2:type.h        **** #define _TYPE_H_
   3:type.h        **** static inline uint8_t bit_to_data(uint8_t data, int bit)
   4:type.h        **** {
   5:type.h        **** 	data &= 1;
   6:type.h        **** 	return data << bit;
   7:type.h        **** }
   8:type.h        **** static inline uint8_t bit_get(uint8_t data, int bit)
 2601               		.loc 4 8 23 is_stmt 1 view .LVU1008
 2602               	.LBB396:
   9:type.h        **** {
  10:type.h        **** 	data >>= bit;
 2603               		.loc 4 10 2 view .LVU1009
  11:type.h        **** 	return data & 1;
 2604               		.loc 4 11 2 view .LVU1010
 2605               		.loc 4 11 2 is_stmt 0 view .LVU1011
 2606               	.LBE396:
 2607               	.LBE395:
 546:bus_access.c  **** 	address += 1 << 10;
 2608               		.loc 1 546 2 is_stmt 1 view .LVU1012
 547:bus_access.c  **** 
 548:bus_access.c  **** 	address_set(address);
 2609               		.loc 1 548 2 view .LVU1013
 2610               	.LBB398:
 2611               	.LBI398:
 117:bus_access.c  **** {
 2612               		.loc 1 117 13 view .LVU1014
 2613               	.LBB399:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2614               		.loc 1 119 2 view .LVU1015
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2615               		.loc 1 119 23 is_stmt 0 view .LVU1016
 2616 0486 1BBA      		out 0x1b,__zero_reg__
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2617               		.loc 1 120 2 is_stmt 1 view .LVU1017
 2618               	.LVL185:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2619               		.loc 1 121 2 view .LVU1018
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2620               		.loc 1 124 2 view .LVU1019
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2621               		.loc 1 124 14 is_stmt 0 view .LVU1020
 2622 0488 F4E2      		ldi r31,lo8(36)
 2623 048a F8BB      		out 0x18,r31
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2624               		.loc 1 126 2 is_stmt 1 view .LVU1021
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2625               		.loc 1 126 18 is_stmt 0 view .LVU1022
 2626 048c 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 2627               		.loc 1 127 2 is_stmt 1 view .LVU1023
 127:bus_access.c  **** }
 2628               		.loc 1 127 18 is_stmt 0 view .LVU1024
 2629 048e E5BB      		out 0x15,r30
 2630               	.LVL186:
 127:bus_access.c  **** }
 2631               		.loc 1 127 18 view .LVU1025
 2632               	.LBE399:
 2633               	.LBE398:
 549:bus_access.c  **** 	ret |= bit_get(USB_MISC_IN, VRAM_A10) << 1;
 2634               		.loc 1 549 2 is_stmt 1 view .LVU1026
 2635               		.loc 1 549 9 is_stmt 0 view .LVU1027
 2636 0490 A0B3      		in r26,0x10
 2637               	.LVL187:
 2638               	.LBB400:
 2639               	.LBI400:
   8:type.h        **** {
 2640               		.loc 4 8 23 is_stmt 1 view .LVU1028
 2641               	.LBB401:
  10:type.h        **** 	return data & 1;
 2642               		.loc 4 10 2 view .LVU1029
 2643               		.loc 4 11 2 view .LVU1030
 2644               		.loc 4 11 2 is_stmt 0 view .LVU1031
 2645               	.LBE401:
 2646               	.LBE400:
 550:bus_access.c  **** 	address += 1 << 10;
 2647               		.loc 1 550 2 is_stmt 1 view .LVU1032
 551:bus_access.c  **** 	
 552:bus_access.c  **** 	address_set(address);
 2648               		.loc 1 552 2 view .LVU1033
 2649               	.LBB402:
 2650               	.LBI402:
 117:bus_access.c  **** {
 2651               		.loc 1 117 13 view .LVU1034
 2652               	.LBB403:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2653               		.loc 1 119 2 view .LVU1035
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2654               		.loc 1 119 23 is_stmt 0 view .LVU1036
 2655 0492 1BBA      		out 0x1b,__zero_reg__
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2656               		.loc 1 120 2 is_stmt 1 view .LVU1037
 2657               	.LVL188:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2658               		.loc 1 121 2 view .LVU1038
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2659               		.loc 1 124 2 view .LVU1039
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2660               		.loc 1 124 14 is_stmt 0 view .LVU1040
 2661 0494 F8E2      		ldi r31,lo8(40)
 2662 0496 F8BB      		out 0x18,r31
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2663               		.loc 1 126 2 is_stmt 1 view .LVU1041
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2664               		.loc 1 126 18 is_stmt 0 view .LVU1042
 2665 0498 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 2666               		.loc 1 127 2 is_stmt 1 view .LVU1043
 127:bus_access.c  **** }
 2667               		.loc 1 127 18 is_stmt 0 view .LVU1044
 2668 049a E5BB      		out 0x15,r30
 2669               	.LVL189:
 127:bus_access.c  **** }
 2670               		.loc 1 127 18 view .LVU1045
 2671               	.LBE403:
 2672               	.LBE402:
 553:bus_access.c  **** 	ret |= bit_get(USB_MISC_IN, VRAM_A10) << 2;
 2673               		.loc 1 553 2 is_stmt 1 view .LVU1046
 2674               		.loc 1 553 9 is_stmt 0 view .LVU1047
 2675 049c F0B3      		in r31,0x10
 2676               	.LVL190:
 2677               	.LBB404:
 2678               	.LBI404:
   8:type.h        **** {
 2679               		.loc 4 8 23 is_stmt 1 view .LVU1048
 2680               	.LBB405:
  10:type.h        **** 	return data & 1;
 2681               		.loc 4 10 2 view .LVU1049
 2682               		.loc 4 11 2 view .LVU1050
 2683               		.loc 4 11 2 is_stmt 0 view .LVU1051
 2684               	.LBE405:
 2685               	.LBE404:
 554:bus_access.c  **** 	address += 1 << 10;
 2686               		.loc 1 554 2 is_stmt 1 view .LVU1052
 555:bus_access.c  **** 
 556:bus_access.c  **** 	address_set(address);
 2687               		.loc 1 556 2 view .LVU1053
 2688               	.LBB406:
 2689               	.LBI406:
 117:bus_access.c  **** {
 2690               		.loc 1 117 13 view .LVU1054
 2691               	.LBB407:
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2692               		.loc 1 119 2 view .LVU1055
 119:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2693               		.loc 1 119 23 is_stmt 0 view .LVU1056
 2694 049e 1BBA      		out 0x1b,__zero_reg__
 120:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2695               		.loc 1 120 2 is_stmt 1 view .LVU1057
 2696               	.LVL191:
 121:bus_access.c  **** 		high |= 0x80; //set /A13
 2697               		.loc 1 121 2 view .LVU1058
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2698               		.loc 1 124 2 view .LVU1059
 124:bus_access.c  **** 	//phi2 pulse is needed mmc1
 2699               		.loc 1 124 14 is_stmt 0 view .LVU1060
 2700 04a0 BCE2      		ldi r27,lo8(44)
 2701 04a2 B8BB      		out 0x18,r27
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2702               		.loc 1 126 2 is_stmt 1 view .LVU1061
 126:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2703               		.loc 1 126 18 is_stmt 0 view .LVU1062
 2704 04a4 95BB      		out 0x15,r25
 127:bus_access.c  **** }
 2705               		.loc 1 127 2 is_stmt 1 view .LVU1063
 127:bus_access.c  **** }
 2706               		.loc 1 127 18 is_stmt 0 view .LVU1064
 2707 04a6 E5BB      		out 0x15,r30
 2708               	.LVL192:
 127:bus_access.c  **** }
 2709               		.loc 1 127 18 view .LVU1065
 2710               	.LBE407:
 2711               	.LBE406:
 557:bus_access.c  **** 	ret |= bit_get(USB_MISC_IN, VRAM_A10) << 3;
 2712               		.loc 1 557 2 is_stmt 1 view .LVU1066
 2713               		.loc 1 557 9 is_stmt 0 view .LVU1067
 2714 04a8 90B3      		in r25,0x10
 2715               	.LVL193:
 2716               	.LBB408:
 2717               	.LBI408:
   8:type.h        **** {
 2718               		.loc 4 8 23 is_stmt 1 view .LVU1068
 2719               	.LBB409:
  10:type.h        **** 	return data & 1;
 2720               		.loc 4 10 2 view .LVU1069
 2721               		.loc 4 11 2 view .LVU1070
 2722               		.loc 4 11 2 is_stmt 0 view .LVU1071
 2723               	.LBE409:
 2724               	.LBE408:
 558:bus_access.c  **** 	address += 1 << 10;
 2725               		.loc 1 558 2 is_stmt 1 view .LVU1072
 559:bus_access.c  **** 	
 560:bus_access.c  **** 	return ret;
 2726               		.loc 1 560 2 view .LVU1073
 549:bus_access.c  **** 	address += 1 << 10;
 2727               		.loc 1 549 9 is_stmt 0 view .LVU1074
 2728 04aa A5FB      		bst r26,5
 2729 04ac 2227      		clr r18
 2730 04ae 20F9      		bld r18,0
 2731 04b0 30E0      		ldi r19,0
 549:bus_access.c  **** 	address += 1 << 10;
 2732               		.loc 1 549 40 view .LVU1075
 2733 04b2 220F      		lsl r18
 2734 04b4 331F      		rol r19
 553:bus_access.c  **** 	address += 1 << 10;
 2735               		.loc 1 553 9 view .LVU1076
 2736 04b6 F5FB      		bst r31,5
 2737 04b8 6627      		clr r22
 2738 04ba 60F9      		bld r22,0
 2739 04bc 70E0      		ldi r23,0
 553:bus_access.c  **** 	address += 1 << 10;
 2740               		.loc 1 553 40 view .LVU1077
 2741 04be 660F      		lsl r22
 2742 04c0 771F      		rol r23
 2743 04c2 660F      		lsl r22
 2744 04c4 771F      		rol r23
 553:bus_access.c  **** 	address += 1 << 10;
 2745               		.loc 1 553 6 view .LVU1078
 2746 04c6 262B      		or r18,r22
 2747               	.LBB410:
 2748               	.LBB397:
  10:type.h        **** 	return data & 1;
 2749               		.loc 4 10 7 view .LVU1079
 2750 04c8 85FB      		bst r24,5
 2751 04ca 8827      		clr r24
 2752 04cc 80F9      		bld r24,0
 2753               	.LVL194:
  10:type.h        **** 	return data & 1;
 2754               		.loc 4 10 7 view .LVU1080
 2755               	.LBE397:
 2756               	.LBE410:
 553:bus_access.c  **** 	address += 1 << 10;
 2757               		.loc 1 553 6 view .LVU1081
 2758 04ce 282B      		or r18,r24
 557:bus_access.c  **** 	address += 1 << 10;
 2759               		.loc 1 557 9 view .LVU1082
 2760 04d0 95FB      		bst r25,5
 2761 04d2 4427      		clr r20
 2762 04d4 40F9      		bld r20,0
 2763 04d6 50E0      		ldi r21,0
 557:bus_access.c  **** 	address += 1 << 10;
 2764               		.loc 1 557 40 view .LVU1083
 2765 04d8 CA01      		movw r24,r20
 2766 04da 880F      		lsl r24
 2767 04dc 991F      		rol r25
 2768 04de 880F      		lsl r24
 2769 04e0 991F      		rol r25
 2770 04e2 880F      		lsl r24
 2771 04e4 991F      		rol r25
 561:bus_access.c  **** }
 2772               		.loc 1 561 1 view .LVU1084
 2773 04e6 822B      		or r24,r18
 2774               	/* epilogue start */
 2775 04e8 0895      		ret
 2776               		.cfi_endproc
 2777               	.LFE29:
 2779               		.section	.bootloader.bus,"ax",@progbits
 2780               	.global	mcu_programdata_read
 2782               	mcu_programdata_read:
 2783               	.LVL195:
 2784               	.LFB31:
 562:bus_access.c  **** 
 563:bus_access.c  **** __attribute__ ((section(".bootloader.bus")))
 564:bus_access.c  **** static void boot_address_set(uint16_t address)
 565:bus_access.c  **** {
 566:bus_access.c  **** #if PCB_REVISION == 1
 567:bus_access.c  **** 	ADDRESSBUS_A0_A7_OUT = address & 0xff;
 568:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 569:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 570:bus_access.c  **** 		high |= 0x80; //set /A13
 571:bus_access.c  **** 	}
 572:bus_access.c  **** 	DATABUS_OUT = high;
 573:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 574:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 575:bus_access.c  **** #endif
 576:bus_access.c  **** #if PCB_REVISION == 2
 577:bus_access.c  **** 	const uint8_t portb = 0x05;
 578:bus_access.c  **** 	DATABUS_OUT = address & 0xff;
 579:bus_access.c  **** 	asm("sbi %0,%1" : :"M"(portb),"M"(ADDRESS_LOW_LATCH));
 580:bus_access.c  **** 	asm("cbi %0,%1" : :"M"(portb),"M"(ADDRESS_LOW_LATCH));
 581:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 582:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 583:bus_access.c  **** 		high |= 0x80; //set /A13
 584:bus_access.c  **** 	}
 585:bus_access.c  **** 	DATABUS_OUT = high;
 586:bus_access.c  **** 	asm("sbi %0,%1" : :"M"(portb),"M"(ADDRESS_HIGH_LATCH));
 587:bus_access.c  **** 	asm("cbi %0,%1" : :"M"(portb),"M"(ADDRESS_HIGH_LATCH));
 588:bus_access.c  **** #endif
 589:bus_access.c  **** }
 590:bus_access.c  **** 
 591:bus_access.c  **** __attribute__ ((section(".bootloader.bus")))
 592:bus_access.c  **** void mcu_programdata_read(uint16_t address, uint16_t length, uint8_t *data)
 593:bus_access.c  **** {
 2785               		.loc 1 593 1 is_stmt 1 view -0
 2786               		.cfi_startproc
 2787               	/* prologue: function */
 2788               	/* frame size = 0 */
 2789               	/* stack size = 0 */
 2790               	.L__stack_usage = 0
 2791               		.loc 1 593 1 is_stmt 0 view .LVU1086
 2792 0000 9C01      		movw r18,r24
 2793 0002 CB01      		movw r24,r22
 2794               	.LVL196:
 2795               		.loc 1 593 1 view .LVU1087
 2796 0004 FA01      		movw r30,r20
 594:bus_access.c  **** 	while(length != 0){
 2797               		.loc 1 594 2 is_stmt 1 view .LVU1088
 2798               		.loc 1 594 7 view .LVU1089
 2799 0006 0097      		sbiw r24,0
 2800 0008 01F0      		breq .L104
 2801 000a BA01      		movw r22,r20
 2802               	.LVL197:
 2803               		.loc 1 594 7 is_stmt 0 view .LVU1090
 2804 000c 680F      		add r22,r24
 2805 000e 791F      		adc r23,r25
 2806               	.LBB411:
 2807               	.LBB412:
 196:bus_access.c  **** 	asm("nop");
 2808               		.loc 1 196 14 view .LVU1091
 2809 0010 9FEF      		ldi r25,lo8(-1)
 2810               	.LBE412:
 2811               	.LBE411:
 2812               	.LBB414:
 2813               	.LBB415:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2814               		.loc 1 573 18 view .LVU1092
 2815 0012 5EEF      		ldi r21,lo8(-2)
 574:bus_access.c  **** #endif
 2816               		.loc 1 574 18 view .LVU1093
 2817 0014 8EE7      		ldi r24,lo8(126)
 2818               	.LVL198:
 574:bus_access.c  **** #endif
 2819               		.loc 1 574 18 view .LVU1094
 2820               	.LBE415:
 2821               	.LBE414:
 595:bus_access.c  **** 		direction_write();
 596:bus_access.c  **** 		if(address < 0x2000){ //PPU CHR-RAM
 597:bus_access.c  **** 			boot_address_set(address);
 598:bus_access.c  **** #if PCB_REVISION == 1
 599:bus_access.c  **** 			BUS_CONTROL_OUT = bit_get_negative(ADDRESS_HIGH_LATCH) & bit_get_negative(PPU_RD) & bit_get_nega
 600:bus_access.c  **** #endif
 601:bus_access.c  **** #if PCB_REVISION == 2
 602:bus_access.c  **** 			BUS_CONTROL_OUT = bit_get_negative(PPU_RD) & bit_get_negative(CPU_PHI2);
 603:bus_access.c  **** #endif
 604:bus_access.c  **** 		}else{ //CPU W-RAM
 605:bus_access.c  **** 			address &= 0x1fff;
 606:bus_access.c  **** 			address |= 0x6000;
 607:bus_access.c  **** 			boot_address_set(address);
 608:bus_access.c  **** /*			if((address & 0x8000) != 0){
 609:bus_access.c  **** 				BUS_CONTROL_OUT = bit_get_negative(CPU_ROMCS);
 610:bus_access.c  **** 			}*/
 611:bus_access.c  **** 			BUS_CONTROL_OUT = BUS_CLOSE | (1 << CPU_PHI2);
 2822               		.loc 1 611 20 view .LVU1095
 2823 0016 BFE7      		ldi r27,lo8(127)
 599:bus_access.c  **** #endif
 2824               		.loc 1 599 20 view .LVU1096
 2825 0018 AEE6      		ldi r26,lo8(110)
 2826 001a 00C0      		rjmp .L107
 2827               	.LVL199:
 2828               	.L112:
 597:bus_access.c  **** #if PCB_REVISION == 1
 2829               		.loc 1 597 4 is_stmt 1 view .LVU1097
 2830               	.LBB418:
 2831               	.LBI418:
 564:bus_access.c  **** {
 2832               		.loc 1 564 13 view .LVU1098
 2833               	.LBB419:
 567:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2834               		.loc 1 567 2 view .LVU1099
 567:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2835               		.loc 1 567 23 is_stmt 0 view .LVU1100
 2836 001c 2BBB      		out 0x1b,r18
 568:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2837               		.loc 1 568 2 is_stmt 1 view .LVU1101
 2838               	.LVL200:
 569:bus_access.c  **** 		high |= 0x80; //set /A13
 2839               		.loc 1 569 2 view .LVU1102
 570:bus_access.c  **** 	}
 2840               		.loc 1 570 3 view .LVU1103
 570:bus_access.c  **** 	}
 2841               		.loc 1 570 8 is_stmt 0 view .LVU1104
 2842 001e 432F      		mov r20,r19
 2843 0020 4068      		ori r20,lo8(-128)
 2844               	.LVL201:
 572:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 2845               		.loc 1 572 2 is_stmt 1 view .LVU1105
 572:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 2846               		.loc 1 572 14 is_stmt 0 view .LVU1106
 2847 0022 48BB      		out 0x18,r20
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2848               		.loc 1 573 2 is_stmt 1 view .LVU1107
 2849               	.LVL202:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2850               		.loc 1 573 2 is_stmt 0 view .LVU1108
 2851               	.LBE419:
 2852               	.LBE418:
 106:bus_access.c  **** 	return ~ret;
 2853               		.loc 1 106 2 is_stmt 1 view .LVU1109
 107:bus_access.c  **** }
 2854               		.loc 1 107 2 view .LVU1110
 2855               	.LBB421:
 2856               	.LBB420:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2857               		.loc 1 573 18 is_stmt 0 view .LVU1111
 2858 0024 55BB      		out 0x15,r21
 574:bus_access.c  **** #endif
 2859               		.loc 1 574 2 is_stmt 1 view .LVU1112
 574:bus_access.c  **** #endif
 2860               		.loc 1 574 18 is_stmt 0 view .LVU1113
 2861 0026 85BB      		out 0x15,r24
 2862               	.LVL203:
 574:bus_access.c  **** #endif
 2863               		.loc 1 574 18 view .LVU1114
 2864               	.LBE420:
 2865               	.LBE421:
 599:bus_access.c  **** #endif
 2866               		.loc 1 599 4 is_stmt 1 view .LVU1115
 106:bus_access.c  **** 	return ~ret;
 2867               		.loc 1 106 2 view .LVU1116
 107:bus_access.c  **** }
 2868               		.loc 1 107 2 view .LVU1117
 106:bus_access.c  **** 	return ~ret;
 2869               		.loc 1 106 2 view .LVU1118
 107:bus_access.c  **** }
 2870               		.loc 1 107 2 view .LVU1119
 106:bus_access.c  **** 	return ~ret;
 2871               		.loc 1 106 2 view .LVU1120
 107:bus_access.c  **** }
 2872               		.loc 1 107 2 view .LVU1121
 599:bus_access.c  **** #endif
 2873               		.loc 1 599 20 is_stmt 0 view .LVU1122
 2874 0028 A5BB      		out 0x15,r26
 2875               	.L106:
 612:bus_access.c  **** 		}
 613:bus_access.c  **** 		direction_read();
 2876               		.loc 1 613 3 is_stmt 1 view .LVU1123
 2877               	.LBB422:
 2878               	.LBI422:
 202:bus_access.c  **** {
 2879               		.loc 1 202 20 view .LVU1124
 2880               	.LBB423:
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 2881               		.loc 1 204 2 view .LVU1125
 204:bus_access.c  **** 	DATABUS_DIR = DATABUS_DIR_IN;
 2882               		.loc 1 204 14 is_stmt 0 view .LVU1126
 2883 002a 98BB      		out 0x18,r25
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 2884               		.loc 1 205 2 is_stmt 1 view .LVU1127
 205:bus_access.c  **** 	asm("nop"); //wait for chaging port direction. do not remove.
 2885               		.loc 1 205 14 is_stmt 0 view .LVU1128
 2886 002c 17BA      		out 0x17,__zero_reg__
 206:bus_access.c  **** 	asm("nop");
 2887               		.loc 1 206 2 is_stmt 1 view .LVU1129
 2888               	/* #APP */
 2889               	 ;  206 "bus_access.c" 1
 2890 002e 0000      		nop
 2891               	 ;  0 "" 2
 207:bus_access.c  **** 	asm("nop");
 2892               		.loc 1 207 2 view .LVU1130
 2893               	 ;  207 "bus_access.c" 1
 2894 0030 0000      		nop
 2895               	 ;  0 "" 2
 208:bus_access.c  **** }
 2896               		.loc 1 208 2 view .LVU1131
 2897               	 ;  208 "bus_access.c" 1
 2898 0032 0000      		nop
 2899               	 ;  0 "" 2
 2900               	/* #NOAPP */
 2901               	.LBE423:
 2902               	.LBE422:
 614:bus_access.c  **** 		*data = DATABUS_IN;
 2903               		.loc 1 614 3 view .LVU1132
 2904               		.loc 1 614 11 is_stmt 0 view .LVU1133
 2905 0034 46B3      		in r20,0x16
 2906               		.loc 1 614 9 view .LVU1134
 2907 0036 4193      		st Z+,r20
 2908               	.LVL204:
 615:bus_access.c  **** 		data += 1;
 2909               		.loc 1 615 3 is_stmt 1 view .LVU1135
 616:bus_access.c  **** 		BUS_CONTROL_OUT = BUS_CLOSE;
 2910               		.loc 1 616 3 view .LVU1136
 2911               		.loc 1 616 19 is_stmt 0 view .LVU1137
 2912 0038 85BB      		out 0x15,r24
 617:bus_access.c  **** 		address += 1;
 2913               		.loc 1 617 3 is_stmt 1 view .LVU1138
 2914               		.loc 1 617 11 is_stmt 0 view .LVU1139
 2915 003a 2F5F      		subi r18,-1
 2916 003c 3F4F      		sbci r19,-1
 2917               	.LVL205:
 618:bus_access.c  **** 		length--;
 2918               		.loc 1 618 3 is_stmt 1 view .LVU1140
 594:bus_access.c  **** 		direction_write();
 2919               		.loc 1 594 7 view .LVU1141
 2920 003e E617      		cp r30,r22
 2921 0040 F707      		cpc r31,r23
 2922 0042 01F0      		breq .L104
 2923               	.L107:
 595:bus_access.c  **** 		if(address < 0x2000){ //PPU CHR-RAM
 2924               		.loc 1 595 3 view .LVU1142
 2925               	.LBB424:
 2926               	.LBI411:
 194:bus_access.c  **** {
 2927               		.loc 1 194 20 view .LVU1143
 2928               	.LBB413:
 196:bus_access.c  **** 	asm("nop");
 2929               		.loc 1 196 2 view .LVU1144
 196:bus_access.c  **** 	asm("nop");
 2930               		.loc 1 196 14 is_stmt 0 view .LVU1145
 2931 0044 97BB      		out 0x17,r25
 197:bus_access.c  **** 	asm("nop");
 2932               		.loc 1 197 2 is_stmt 1 view .LVU1146
 2933               	/* #APP */
 2934               	 ;  197 "bus_access.c" 1
 2935 0046 0000      		nop
 2936               	 ;  0 "" 2
 198:bus_access.c  **** 	asm("nop");
 2937               		.loc 1 198 2 view .LVU1147
 2938               	 ;  198 "bus_access.c" 1
 2939 0048 0000      		nop
 2940               	 ;  0 "" 2
 199:bus_access.c  **** }
 2941               		.loc 1 199 2 view .LVU1148
 2942               	 ;  199 "bus_access.c" 1
 2943 004a 0000      		nop
 2944               	 ;  0 "" 2
 2945               	/* #NOAPP */
 2946               	.LBE413:
 2947               	.LBE424:
 596:bus_access.c  **** 			boot_address_set(address);
 2948               		.loc 1 596 3 view .LVU1149
 596:bus_access.c  **** 			boot_address_set(address);
 2949               		.loc 1 596 5 is_stmt 0 view .LVU1150
 2950 004c 2115      		cp r18,__zero_reg__
 2951 004e 40E2      		ldi r20,32
 2952 0050 3407      		cpc r19,r20
 2953 0052 00F0      		brlo .L112
 605:bus_access.c  **** 			address |= 0x6000;
 2954               		.loc 1 605 4 is_stmt 1 view .LVU1151
 605:bus_access.c  **** 			address |= 0x6000;
 2955               		.loc 1 605 12 is_stmt 0 view .LVU1152
 2956 0054 3F71      		andi r19,31
 2957               	.LVL206:
 606:bus_access.c  **** 			boot_address_set(address);
 2958               		.loc 1 606 4 is_stmt 1 view .LVU1153
 606:bus_access.c  **** 			boot_address_set(address);
 2959               		.loc 1 606 12 is_stmt 0 view .LVU1154
 2960 0056 3066      		ori r19,96
 2961               	.LVL207:
 607:bus_access.c  **** /*			if((address & 0x8000) != 0){
 2962               		.loc 1 607 4 is_stmt 1 view .LVU1155
 2963               	.LBB425:
 2964               	.LBI414:
 564:bus_access.c  **** {
 2965               		.loc 1 564 13 view .LVU1156
 2966               	.LBB416:
 567:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2967               		.loc 1 567 2 view .LVU1157
 567:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 2968               		.loc 1 567 23 is_stmt 0 view .LVU1158
 2969 0058 2BBB      		out 0x1b,r18
 568:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 2970               		.loc 1 568 2 is_stmt 1 view .LVU1159
 2971               	.LVL208:
 569:bus_access.c  **** 		high |= 0x80; //set /A13
 2972               		.loc 1 569 2 view .LVU1160
 572:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 2973               		.loc 1 572 2 view .LVU1161
 572:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 2974               		.loc 1 572 14 is_stmt 0 view .LVU1162
 2975 005a 38BB      		out 0x18,r19
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2976               		.loc 1 573 2 is_stmt 1 view .LVU1163
 2977               	.LVL209:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2978               		.loc 1 573 2 is_stmt 0 view .LVU1164
 2979               	.LBE416:
 2980               	.LBE425:
 106:bus_access.c  **** 	return ~ret;
 2981               		.loc 1 106 2 is_stmt 1 view .LVU1165
 107:bus_access.c  **** }
 2982               		.loc 1 107 2 view .LVU1166
 2983               	.LBB426:
 2984               	.LBB417:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 2985               		.loc 1 573 18 is_stmt 0 view .LVU1167
 2986 005c 55BB      		out 0x15,r21
 574:bus_access.c  **** #endif
 2987               		.loc 1 574 2 is_stmt 1 view .LVU1168
 574:bus_access.c  **** #endif
 2988               		.loc 1 574 18 is_stmt 0 view .LVU1169
 2989 005e 85BB      		out 0x15,r24
 2990               	.LVL210:
 574:bus_access.c  **** #endif
 2991               		.loc 1 574 18 view .LVU1170
 2992               	.LBE417:
 2993               	.LBE426:
 611:bus_access.c  **** 		}
 2994               		.loc 1 611 4 is_stmt 1 view .LVU1171
 611:bus_access.c  **** 		}
 2995               		.loc 1 611 20 is_stmt 0 view .LVU1172
 2996 0060 B5BB      		out 0x15,r27
 2997 0062 00C0      		rjmp .L106
 2998               	.L104:
 619:bus_access.c  **** 	}
 620:bus_access.c  **** 	boot_address_set(ADDRESS_CLOSE);
 2999               		.loc 1 620 2 is_stmt 1 view .LVU1173
 3000               	.LVL211:
 3001               	.LBB427:
 3002               	.LBI427:
 564:bus_access.c  **** {
 3003               		.loc 1 564 13 view .LVU1174
 3004               	.LBB428:
 567:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 3005               		.loc 1 567 2 view .LVU1175
 567:bus_access.c  **** 	uint8_t high = (address & 0x7fff) >> 8; //mask A0-A14
 3006               		.loc 1 567 23 is_stmt 0 view .LVU1176
 3007 0064 8FEF      		ldi r24,lo8(-1)
 3008 0066 8BBB      		out 0x1b,r24
 568:bus_access.c  **** 	if((address & (1 << 13)) == 0){ //if A13 == 0
 3009               		.loc 1 568 2 is_stmt 1 view .LVU1177
 3010               	.LVL212:
 569:bus_access.c  **** 		high |= 0x80; //set /A13
 3011               		.loc 1 569 2 view .LVU1178
 572:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 3012               		.loc 1 572 2 view .LVU1179
 572:bus_access.c  **** 	BUS_CONTROL_OUT = bit_get_negative(CPU_PHI2);
 3013               		.loc 1 572 14 is_stmt 0 view .LVU1180
 3014 0068 8FE3      		ldi r24,lo8(63)
 3015 006a 88BB      		out 0x18,r24
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 3016               		.loc 1 573 2 is_stmt 1 view .LVU1181
 3017               	.LVL213:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 3018               		.loc 1 573 2 is_stmt 0 view .LVU1182
 3019               	.LBE428:
 3020               	.LBE427:
 106:bus_access.c  **** 	return ~ret;
 3021               		.loc 1 106 2 is_stmt 1 view .LVU1183
 107:bus_access.c  **** }
 3022               		.loc 1 107 2 view .LVU1184
 3023               	.LBB430:
 3024               	.LBB429:
 573:bus_access.c  **** 	BUS_CONTROL_OUT = BUS_CLOSE;
 3025               		.loc 1 573 18 is_stmt 0 view .LVU1185
 3026 006c 8EEF      		ldi r24,lo8(-2)
 3027 006e 85BB      		out 0x15,r24
 574:bus_access.c  **** #endif
 3028               		.loc 1 574 2 is_stmt 1 view .LVU1186
 574:bus_access.c  **** #endif
 3029               		.loc 1 574 18 is_stmt 0 view .LVU1187
 3030 0070 8EE7      		ldi r24,lo8(126)
 3031 0072 85BB      		out 0x15,r24
 3032               	.LVL214:
 3033               	/* epilogue start */
 574:bus_access.c  **** #endif
 3034               		.loc 1 574 18 view .LVU1188
 3035               	.LBE429:
 3036               	.LBE430:
 621:bus_access.c  **** }
 3037               		.loc 1 621 1 view .LVU1189
 3038 0074 0895      		ret
 3039               		.cfi_endproc
 3040               	.LFE31:
 3042               		.local	i.1727
 3043               		.comm	i.1727,1,1
 3044               		.text
 3045               	.Letext0:
 3046               		.file 5 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 bus_access.c
     /tmp/ccHj94yi.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccHj94yi.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccHj94yi.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccHj94yi.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccHj94yi.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccHj94yi.s:12     .text:0000000000000000 bus_init
     /tmp/ccHj94yi.s:81     .text:0000000000000022 phi2_init
     /tmp/ccHj94yi.s:123    .text:0000000000000034 phi2_update
                             .bss:0000000000000000 i.1727
     /tmp/ccHj94yi.s:180    .text:000000000000005c cpu_read
     /tmp/ccHj94yi.s:382    .text:00000000000000ba cpu_read_6502
     /tmp/ccHj94yi.s:645    .text:0000000000000128 ppu_read
     /tmp/ccHj94yi.s:837    .text:000000000000017e cpu_compare
     /tmp/ccHj94yi.s:1066   .text:00000000000001ee ppu_compare
     /tmp/ccHj94yi.s:1297   .text:0000000000000258 cpu_write_6502_nowait
     /tmp/ccHj94yi.s:1469   .text:00000000000002b0 cpu_write_flash
     /tmp/ccHj94yi.s:1681   .text:000000000000030a cpu_write_flash_order
     /tmp/ccHj94yi.s:1885   .text:000000000000035a cpu_write_6502
     /tmp/ccHj94yi.s:2227   .text:00000000000003ee ppu_write
     /tmp/ccHj94yi.s:2384   .text:0000000000000432 ppu_write_order
     /tmp/ccHj94yi.s:2531   .text:000000000000046e vram_connection_get
     /tmp/ccHj94yi.s:2782   .bootloader.bus:0000000000000000 mcu_programdata_read

UNDEFINED SYMBOLS
__do_clear_bss
