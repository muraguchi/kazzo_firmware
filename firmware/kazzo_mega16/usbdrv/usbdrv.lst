   1               		.file	"usbdrv.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	usbPoll
  12               	usbPoll:
  13               	.LFB9:
  14               		.file 1 "usbdrv/usbdrv.c"
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 763 2009-08-22 10:27:24Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "usbportability.h"
  12:usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:usbdrv/usbdrv.c **** #include "oddebug.h"
  14:usbdrv/usbdrv.c **** 
  15:usbdrv/usbdrv.c **** /*
  16:usbdrv/usbdrv.c **** General Description:
  17:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:usbdrv/usbdrv.c **** documentation of the entire driver.
  19:usbdrv/usbdrv.c **** */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:usbdrv/usbdrv.c **** 
  23:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  25:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:usbdrv/usbdrv.c **** #endif
  37:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:usbdrv/usbdrv.c **** #   endif
  42:usbdrv/usbdrv.c **** #endif
  43:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:usbdrv/usbdrv.c **** #endif
  46:usbdrv/usbdrv.c **** 
  47:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  50:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  51:usbdrv/usbdrv.c **** 
  52:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** /*
  56:usbdrv/usbdrv.c **** optimizing hints:
  57:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:usbdrv/usbdrv.c **** */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:usbdrv/usbdrv.c **** 
  67:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
  71:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:usbdrv/usbdrv.c **** };
  75:usbdrv/usbdrv.c **** #endif
  76:usbdrv/usbdrv.c **** 
  77:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringVendor[] = {
  81:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  82:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:usbdrv/usbdrv.c **** };
  84:usbdrv/usbdrv.c **** #endif
  85:usbdrv/usbdrv.c **** 
  86:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringDevice[] = {
  90:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:usbdrv/usbdrv.c **** };
  93:usbdrv/usbdrv.c **** #endif
  94:usbdrv/usbdrv.c **** 
  95:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:usbdrv/usbdrv.c **** PROGMEM const int usbDescriptorStringSerialNumber[] = {
  99:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:usbdrv/usbdrv.c **** };
 102:usbdrv/usbdrv.c **** #endif
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 107:usbdrv/usbdrv.c **** 
 108:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:usbdrv/usbdrv.c ****      */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:usbdrv/usbdrv.c **** };
 130:usbdrv/usbdrv.c **** #endif
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:usbdrv/usbdrv.c **** 
 134:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:usbdrv/usbdrv.c **** #endif
 138:usbdrv/usbdrv.c **** 
 139:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:usbdrv/usbdrv.c ****     (char)0x83, /* IN endpoint number 1 */
 188:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** };
 193:usbdrv/usbdrv.c **** #endif
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 196:usbdrv/usbdrv.c **** 
 197:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:usbdrv/usbdrv.c **** {
 199:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:usbdrv/usbdrv.c **** #   endif
 204:usbdrv/usbdrv.c **** #endif
 205:usbdrv/usbdrv.c **** }
 206:usbdrv/usbdrv.c **** 
 207:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:usbdrv/usbdrv.c **** {
 209:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** #endif
 215:usbdrv/usbdrv.c **** }
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 221:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** uchar   *p;
 224:usbdrv/usbdrv.c **** char    i;
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:usbdrv/usbdrv.c ****         return;
 229:usbdrv/usbdrv.c **** #endif
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:usbdrv/usbdrv.c ****     }else{
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:usbdrv/usbdrv.c ****     }
 235:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:usbdrv/usbdrv.c ****     i = len;
 237:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:usbdrv/usbdrv.c **** }
 244:usbdrv/usbdrv.c **** 
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:usbdrv/usbdrv.c **** {
 247:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:usbdrv/usbdrv.c **** }
 249:usbdrv/usbdrv.c **** #endif
 250:usbdrv/usbdrv.c **** 
 251:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 253:usbdrv/usbdrv.c **** {
 254:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:usbdrv/usbdrv.c **** }
 256:usbdrv/usbdrv.c **** #endif
 257:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:usbdrv/usbdrv.c **** 
 261:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:usbdrv/usbdrv.c ****  * cases.
 265:usbdrv/usbdrv.c ****  */
 266:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 273:usbdrv/usbdrv.c **** #else
 274:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** 
 282:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:usbdrv/usbdrv.c **** #endif
 285:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:usbdrv/usbdrv.c **** #endif
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:usbdrv/usbdrv.c **** 
 291:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:usbdrv/usbdrv.c ****  * optimizing!
 295:usbdrv/usbdrv.c ****  */
 296:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:usbdrv/usbdrv.c ****             flags = 0;                              \
 300:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:usbdrv/usbdrv.c ****         }else{                                      \
 303:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:usbdrv/usbdrv.c ****         }                                           \
 306:usbdrv/usbdrv.c ****     }
 307:usbdrv/usbdrv.c **** 
 308:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 310:usbdrv/usbdrv.c ****  */
 311:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:usbdrv/usbdrv.c **** {
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:usbdrv/usbdrv.c **** 
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:usbdrv/usbdrv.c ****             flags = 0;
 325:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:usbdrv/usbdrv.c ****             }
 340:usbdrv/usbdrv.c ****         SWITCH_END
 341:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c ****         }
 352:usbdrv/usbdrv.c ****     SWITCH_END
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:usbdrv/usbdrv.c ****     return len;
 355:usbdrv/usbdrv.c **** }
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:usbdrv/usbdrv.c **** 
 359:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:usbdrv/usbdrv.c ****  */
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:usbdrv/usbdrv.c **** {
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 366:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 367:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 368:usbdrv/usbdrv.c **** #endif
 369:usbdrv/usbdrv.c **** 
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 373:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 374:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 375:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 376:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 377:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 378:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 379:usbdrv/usbdrv.c **** #endif
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 381:usbdrv/usbdrv.c ****         len = 2;
 382:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 384:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 385:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 386:usbdrv/usbdrv.c ****             usbResetDataToggling();
 387:usbdrv/usbdrv.c ****         }
 388:usbdrv/usbdrv.c **** #endif
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 391:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 393:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 394:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 397:usbdrv/usbdrv.c ****         len = 1;
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 400:usbdrv/usbdrv.c ****         usbResetStall();
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 402:usbdrv/usbdrv.c ****         len = 1;
 403:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 405:usbdrv/usbdrv.c ****         usbResetDataToggling();
 406:usbdrv/usbdrv.c ****         usbResetStall();
 407:usbdrv/usbdrv.c **** #endif
 408:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 409:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 410:usbdrv/usbdrv.c ****     SWITCH_END
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 412:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 413:usbdrv/usbdrv.c ****     return len;
 414:usbdrv/usbdrv.c **** }
 415:usbdrv/usbdrv.c **** 
 416:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 417:usbdrv/usbdrv.c **** 
 418:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 419:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 420:usbdrv/usbdrv.c ****  * them accordingly.
 421:usbdrv/usbdrv.c ****  */
 422:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 423:usbdrv/usbdrv.c **** {
 424:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 425:usbdrv/usbdrv.c **** 
 426:usbdrv/usbdrv.c **** /* usbRxToken can be:
 427:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 428:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 429:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 430:usbdrv/usbdrv.c ****  */
 431:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 432:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 433:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 434:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 435:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 436:usbdrv/usbdrv.c ****         return;
 437:usbdrv/usbdrv.c ****     }
 438:usbdrv/usbdrv.c **** #endif
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 441:usbdrv/usbdrv.c ****             return;
 442:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 449:usbdrv/usbdrv.c ****         }else{
 450:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 451:usbdrv/usbdrv.c ****         }
 452:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 453:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 454:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 455:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 456:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 457:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 458:usbdrv/usbdrv.c ****                 }else{
 459:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 460:usbdrv/usbdrv.c ****                 }
 461:usbdrv/usbdrv.c ****             }
 462:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 463:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 464:usbdrv/usbdrv.c **** #endif
 465:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 467:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 468:usbdrv/usbdrv.c ****         }else{
 469:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 470:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 471:usbdrv/usbdrv.c ****         }
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 473:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 474:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 475:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 476:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 477:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 478:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 479:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 480:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 481:usbdrv/usbdrv.c ****             }
 482:usbdrv/usbdrv.c ****         }
 483:usbdrv/usbdrv.c **** #endif
 484:usbdrv/usbdrv.c ****     }
 485:usbdrv/usbdrv.c **** }
 486:usbdrv/usbdrv.c **** 
 487:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 488:usbdrv/usbdrv.c **** 
 489:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 490:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 491:usbdrv/usbdrv.c ****  */
 492:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 493:usbdrv/usbdrv.c **** {
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 495:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 496:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 497:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 498:usbdrv/usbdrv.c ****         }else
 499:usbdrv/usbdrv.c **** #endif
 500:usbdrv/usbdrv.c ****         {
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 503:usbdrv/usbdrv.c ****                 do{
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 506:usbdrv/usbdrv.c ****                     r++;
 507:usbdrv/usbdrv.c ****                 }while(--i);
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 509:usbdrv/usbdrv.c ****                 do{
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 511:usbdrv/usbdrv.c ****                 }while(--i);
 512:usbdrv/usbdrv.c ****             }
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c ****     }
 516:usbdrv/usbdrv.c ****     return len;
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 522:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 525:usbdrv/usbdrv.c **** {
 526:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 527:usbdrv/usbdrv.c **** uchar       len;
 528:usbdrv/usbdrv.c **** 
 529:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 530:usbdrv/usbdrv.c ****     if(wantLen > 8)
 531:usbdrv/usbdrv.c ****         wantLen = 8;
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 535:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 540:usbdrv/usbdrv.c ****     }else{
 541:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 543:usbdrv/usbdrv.c ****     }
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 546:usbdrv/usbdrv.c **** }
 547:usbdrv/usbdrv.c **** 
 548:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 549:usbdrv/usbdrv.c **** 
 550:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 551:usbdrv/usbdrv.c **** {
 552:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 553:usbdrv/usbdrv.c **** static uchar    wasReset;
 554:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 555:usbdrv/usbdrv.c **** 
 556:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 559:usbdrv/usbdrv.c ****     }
 560:usbdrv/usbdrv.c **** #endif
 561:usbdrv/usbdrv.c **** }
 562:usbdrv/usbdrv.c **** 
 563:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 564:usbdrv/usbdrv.c **** 
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 566:usbdrv/usbdrv.c **** {
  15               		.loc 1 566 1 view -0
  16               		.cfi_startproc
  17 0000 1F93      		push r17
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 17, -2
  21 0002 CF93      		push r28
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 28, -3
  25 0004 DF93      		push r29
  26               	.LCFI2:
  27               		.cfi_def_cfa_offset 5
  28               		.cfi_offset 29, -4
  29               	/* prologue: function */
  30               	/* frame size = 0 */
  31               	/* stack size = 3 */
  32               	.L__stack_usage = 3
 567:usbdrv/usbdrv.c **** schar   len;
  33               		.loc 1 567 1 view .LVU1
 568:usbdrv/usbdrv.c **** uchar   i;
  34               		.loc 1 568 1 view .LVU2
 569:usbdrv/usbdrv.c **** 
 570:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
  35               		.loc 1 570 5 view .LVU3
  36               		.loc 1 570 20 is_stmt 0 view .LVU4
  37 0006 6091 0000 		lds r22,usbRxLen
  38 000a 6350      		subi r22,lo8(-(-3))
  39               	.LVL0:
 571:usbdrv/usbdrv.c ****     if(len >= 0){
  40               		.loc 1 571 5 is_stmt 1 view .LVU5
  41               		.loc 1 571 7 is_stmt 0 view .LVU6
  42 000c 67FF      		sbrs r22,7
  43 000e 00C0      		rjmp .L59
  44               	.LVL1:
  45               	.L2:
 572:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 573:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 574:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 575:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 576:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 577:usbdrv/usbdrv.c ****  */
 578:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 579:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 580:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 581:usbdrv/usbdrv.c ****             usbRxLen = 0;
 582:usbdrv/usbdrv.c **** #else
 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 584:usbdrv/usbdrv.c **** #endif
 585:usbdrv/usbdrv.c ****     }
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
  46               		.loc 1 586 5 is_stmt 1 view .LVU7
  47               		.loc 1 586 17 is_stmt 0 view .LVU8
  48 0010 8091 0000 		lds r24,usbTxLen
  49               		.loc 1 586 7 view .LVU9
  50 0014 84FF      		sbrs r24,4
  51 0016 00C0      		rjmp .L26
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
  52               		.loc 1 587 9 is_stmt 1 view .LVU10
  53               		.loc 1 587 22 is_stmt 0 view .LVU11
  54 0018 8091 0000 		lds r24,usbMsgLen
  55 001c 9091 0000 		lds r25,usbMsgLen+1
  56               		.loc 1 587 11 view .LVU12
  57 0020 8F3F      		cpi r24,-1
  58 0022 9807      		cpc r25,r24
  59 0024 01F4      		brne .L60
  60               	.L26:
 588:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 589:usbdrv/usbdrv.c ****         }
 590:usbdrv/usbdrv.c ****     }
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
  61               		.loc 1 591 5 is_stmt 1 view .LVU13
  62               	.LVL2:
  63               		.loc 1 591 17 view .LVU14
  64               	.LBB46:
  65               	.LBB47:
  66               	.LBB48:
  67               	.LBB49:
  68               	.LBB50:
 502:usbdrv/usbdrv.c ****                 do{
  69               		.loc 1 502 15 is_stmt 0 view .LVU15
  70 0026 94E1      		ldi r25,lo8(20)
  71 0028 00C0      		rjmp .L35
  72               	.LVL3:
  73               	.L62:
 502:usbdrv/usbdrv.c ****                 do{
  74               		.loc 1 502 15 view .LVU16
  75               	.LBE50:
  76               	.LBE49:
  77               	.LBE48:
  78               	.LBE47:
  79               	.LBE46:
  80               		.loc 1 591 24 is_stmt 1 discriminator 2 view .LVU17
  81               		.loc 1 591 17 discriminator 2 view .LVU18
  82 002a 9150      		subi r25,lo8(-(-1))
  83               	.LVL4:
  84               		.loc 1 591 5 is_stmt 0 discriminator 2 view .LVU19
  85 002c 01F4      		brne .+2
  86 002e 00C0      		rjmp .L61
  87               	.LVL5:
  88               	.L35:
  89               	.LBB64:
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
  90               		.loc 1 592 9 is_stmt 1 view .LVU20
  91               		.loc 1 592 37 is_stmt 0 view .LVU21
  92 0030 80B3      		in r24,0x10
  93               	.LVL6:
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
  94               		.loc 1 593 9 is_stmt 1 view .LVU22
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
  95               		.loc 1 592 15 is_stmt 0 view .LVU23
  96 0032 8471      		andi r24,lo8(20)
  97               	.LVL7:
  98               		.loc 1 593 11 view .LVU24
  99 0034 01F0      		breq .L62
 100               	/* epilogue start */
 101               	.LBE64:
 594:usbdrv/usbdrv.c ****             goto isNotReset;
 595:usbdrv/usbdrv.c ****     }
 596:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 599:usbdrv/usbdrv.c ****     usbResetStall();
 600:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 601:usbdrv/usbdrv.c **** isNotReset:
 602:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 603:usbdrv/usbdrv.c **** }
 102               		.loc 1 603 1 view .LVU25
 103 0036 DF91      		pop r29
 104 0038 CF91      		pop r28
 105 003a 1F91      		pop r17
 106 003c 0895      		ret
 107               	.LVL8:
 108               	.L60:
 588:usbdrv/usbdrv.c ****         }
 109               		.loc 1 588 13 is_stmt 1 view .LVU26
 110               	.LBB65:
 111               	.LBI46:
 524:usbdrv/usbdrv.c **** {
 112               		.loc 1 524 20 view .LVU27
 113               	.LBB61:
 526:usbdrv/usbdrv.c **** uchar       len;
 114               		.loc 1 526 1 view .LVU28
 527:usbdrv/usbdrv.c **** 
 115               		.loc 1 527 1 view .LVU29
 529:usbdrv/usbdrv.c ****     if(wantLen > 8)
 116               		.loc 1 529 5 view .LVU30
 530:usbdrv/usbdrv.c ****         wantLen = 8;
 117               		.loc 1 530 5 view .LVU31
 118 003e EC01      		movw r28,r24
 119 0040 8930      		cpi r24,9
 120 0042 9105      		cpc r25,__zero_reg__
 121 0044 00F0      		brlo .+2
 122 0046 00C0      		rjmp .L63
 123               	.L27:
 124               	.LVL9:
 532:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 125               		.loc 1 532 5 view .LVU32
 532:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 126               		.loc 1 532 15 is_stmt 0 view .LVU33
 127 0048 8C1B      		sub r24,r28
 128 004a 9D0B      		sbc r25,r29
 129 004c 9093 0000 		sts usbMsgLen+1,r25
 130 0050 8093 0000 		sts usbMsgLen,r24
 533:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 131               		.loc 1 533 5 is_stmt 1 view .LVU34
 533:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 132               		.loc 1 533 17 is_stmt 0 view .LVU35
 133 0054 8091 0000 		lds r24,usbTxBuf
 134 0058 98E8      		ldi r25,lo8(-120)
 135 005a 8927      		eor r24,r25
 136 005c 8093 0000 		sts usbTxBuf,r24
 534:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 137               		.loc 1 534 5 is_stmt 1 view .LVU36
 534:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 138               		.loc 1 534 11 is_stmt 0 view .LVU37
 139 0060 6C2F      		mov r22,r28
 140               	.LVL10:
 141               	.LBB58:
 142               	.LBI48:
 492:usbdrv/usbdrv.c **** {
 143               		.loc 1 492 14 is_stmt 1 view .LVU38
 144               	.LBB55:
 494:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 145               		.loc 1 494 5 view .LVU39
 146 0062 1C2F      		mov r17,r28
 147 0064 1C5F      		subi r17,lo8(-(4))
 494:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 148               		.loc 1 494 7 is_stmt 0 view .LVU40
 149 0066 CC23      		tst r28
 150 0068 01F4      		brne .+2
 151 006a 00C0      		rjmp .L28
 152               	.LBB53:
 501:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 153               		.loc 1 501 13 is_stmt 1 view .LVU41
 154               	.LVL11:
 501:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 155               		.loc 1 501 29 is_stmt 0 view .LVU42
 156 006c E091 0000 		lds r30,usbMsgPtr
 157 0070 F091 0000 		lds r31,usbMsgPtr+1
 158               	.LVL12:
 502:usbdrv/usbdrv.c ****                 do{
 159               		.loc 1 502 13 is_stmt 1 view .LVU43
 502:usbdrv/usbdrv.c ****                 do{
 160               		.loc 1 502 15 is_stmt 0 view .LVU44
 161 0074 8091 0000 		lds r24,usbMsgFlags
 162 0078 86FF      		sbrs r24,6
 163 007a 00C0      		rjmp .L29
 164 007c 8FEF      		ldi r24,lo8(-1)
 165 007e 8C0F      		add r24,r28
 166 0080 90E0      		ldi r25,0
 167 0082 0196      		adiw r24,1
 168 0084 8E0F      		add r24,r30
 169 0086 9F1F      		adc r25,r31
 170 0088 20E0      		ldi r18,lo8(usbTxBuf+1)
 171 008a 30E0      		ldi r19,hi8(usbTxBuf+1)
 172               	.LVL13:
 173               	.L30:
 503:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 174               		.loc 1 503 17 is_stmt 1 view .LVU45
 175               	.LBB51:
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 176               		.loc 1 504 21 view .LVU46
 177               	.LBB52:
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 178               		.loc 1 504 31 view .LVU47
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 179               		.loc 1 504 31 view .LVU48
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 180               		.loc 1 504 31 view .LVU49
 181               	/* #APP */
 182               	 ;  504 "usbdrv/usbdrv.c" 1
 183 008c 4491      		lpm r20, Z
 184               		
 185               	 ;  0 "" 2
 186               	.LVL14:
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 187               		.loc 1 504 31 view .LVU50
 504:usbdrv/usbdrv.c ****                     *data++ = c;
 188               		.loc 1 504 31 is_stmt 0 view .LVU51
 189               	/* #NOAPP */
 190               	.LBE52:
 505:usbdrv/usbdrv.c ****                     r++;
 191               		.loc 1 505 21 is_stmt 1 view .LVU52
 192 008e D901      		movw r26,r18
 505:usbdrv/usbdrv.c ****                     r++;
 193               		.loc 1 505 29 is_stmt 0 view .LVU53
 194 0090 4C93      		st X,r20
 195 0092 2F5F      		subi r18,-1
 196 0094 3F4F      		sbci r19,-1
 197               	.LVL15:
 506:usbdrv/usbdrv.c ****                 }while(--i);
 198               		.loc 1 506 21 is_stmt 1 view .LVU54
 506:usbdrv/usbdrv.c ****                 }while(--i);
 199               		.loc 1 506 22 is_stmt 0 view .LVU55
 200 0096 3196      		adiw r30,1
 201               	.LVL16:
 506:usbdrv/usbdrv.c ****                 }while(--i);
 202               		.loc 1 506 22 view .LVU56
 203               	.LBE51:
 507:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 204               		.loc 1 507 23 is_stmt 1 view .LVU57
 507:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 205               		.loc 1 507 17 is_stmt 0 view .LVU58
 206 0098 E817      		cp r30,r24
 207 009a F907      		cpc r31,r25
 208 009c 01F4      		brne .L30
 209               	.LVL17:
 210               	.L31:
 513:usbdrv/usbdrv.c ****         }
 211               		.loc 1 513 13 is_stmt 1 view .LVU59
 513:usbdrv/usbdrv.c ****         }
 212               		.loc 1 513 23 is_stmt 0 view .LVU60
 213 009e 9093 0000 		sts usbMsgPtr+1,r25
 214 00a2 8093 0000 		sts usbMsgPtr,r24
 215               	.LBE53:
 516:usbdrv/usbdrv.c **** }
 216               		.loc 1 516 5 is_stmt 1 view .LVU61
 217               	.LVL18:
 516:usbdrv/usbdrv.c **** }
 218               		.loc 1 516 5 is_stmt 0 view .LVU62
 219               	.LBE55:
 220               	.LBE58:
 535:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 221               		.loc 1 535 5 is_stmt 1 view .LVU63
 536:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 222               		.loc 1 536 9 view .LVU64
 223 00a6 80E0      		ldi r24,lo8(usbTxBuf+1)
 224 00a8 90E0      		ldi r25,hi8(usbTxBuf+1)
 225 00aa 0E94 0000 		call usbCrc16Append
 226               	.LVL19:
 537:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 227               		.loc 1 537 9 view .LVU65
 538:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 228               		.loc 1 538 9 view .LVU66
 538:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 229               		.loc 1 538 11 is_stmt 0 view .LVU67
 230 00ae 1C30      		cpi r17,lo8(12)
 231 00b0 01F0      		breq .L33
 232 00b2 00C0      		rjmp .L36
 233               	.LVL20:
 234               	.L61:
 538:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 235               		.loc 1 538 11 view .LVU68
 236               	.LBE61:
 237               	.LBE65:
 597:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 238               		.loc 1 597 5 is_stmt 1 view .LVU69
 597:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 239               		.loc 1 597 22 is_stmt 0 view .LVU70
 240 00b4 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 598:usbdrv/usbdrv.c ****     usbResetStall();
 241               		.loc 1 598 5 is_stmt 1 view .LVU71
 598:usbdrv/usbdrv.c ****     usbResetStall();
 242               		.loc 1 598 19 is_stmt 0 view .LVU72
 243 00b8 1092 0000 		sts usbDeviceAddr,__zero_reg__
 599:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 244               		.loc 1 599 5 is_stmt 1 view .LVU73
 245               	.LBB66:
 246               	.LBI66:
 207:usbdrv/usbdrv.c **** {
 247               		.loc 1 207 21 view .LVU74
 248               	.LBB67:
 215:usbdrv/usbdrv.c **** 
 249               		.loc 1 215 1 view .LVU75
 250               	.L34:
 251               	.LBE67:
 252               	.LBE66:
 600:usbdrv/usbdrv.c **** isNotReset:
 253               		.loc 1 600 21 view .LVU76
 602:usbdrv/usbdrv.c **** }
 254               		.loc 1 602 5 view .LVU77
 255               	.LVL21:
 561:usbdrv/usbdrv.c **** 
 256               		.loc 1 561 1 view .LVU78
 257               	/* epilogue start */
 258               		.loc 1 603 1 is_stmt 0 view .LVU79
 259 00bc DF91      		pop r29
 260 00be CF91      		pop r28
 261 00c0 1F91      		pop r17
 262 00c2 0895      		ret
 263               	.LVL22:
 264               	.L59:
 578:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 265               		.loc 1 578 9 is_stmt 1 view .LVU80
 578:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 266               		.loc 1 578 49 is_stmt 0 view .LVU81
 267 00c4 2091 0000 		lds r18,usbInputBufOffset
 268 00c8 8CE0      		ldi r24,lo8(12)
 269 00ca 90E0      		ldi r25,0
 270 00cc 821B      		sub r24,r18
 271 00ce 9109      		sbc r25,__zero_reg__
 578:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 272               		.loc 1 578 9 view .LVU82
 273 00d0 EC01      		movw r28,r24
 274 00d2 C050      		subi r28,lo8(-(usbRxBuf))
 275 00d4 D040      		sbci r29,hi8(-(usbRxBuf))
 276               	.LVL23:
 277               	.LBB68:
 278               	.LBI68:
 422:usbdrv/usbdrv.c **** {
 279               		.loc 1 422 20 is_stmt 1 view .LVU83
 280               	.LBB69:
 424:usbdrv/usbdrv.c **** 
 281               		.loc 1 424 1 view .LVU84
 431:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 282               		.loc 1 431 51 view .LVU85
 439:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 283               		.loc 1 439 5 view .LVU86
 439:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 284               		.loc 1 439 7 is_stmt 0 view .LVU87
 285 00d6 8091 0000 		lds r24,usbRxToken
 286 00da 8D32      		cpi r24,lo8(45)
 287 00dc 01F0      		breq .L64
 475:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 288               		.loc 1 475 9 is_stmt 1 view .LVU88
 475:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 289               		.loc 1 475 11 is_stmt 0 view .LVU89
 290 00de 8091 0000 		lds r24,usbMsgFlags
 291 00e2 87FD      		sbrc r24,7
 292 00e4 00C0      		rjmp .L65
 293               	.LVL24:
 294               	.L5:
 475:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 295               		.loc 1 475 11 view .LVU90
 296               	.LBE69:
 297               	.LBE68:
 583:usbdrv/usbdrv.c **** #endif
 298               		.loc 1 583 9 is_stmt 1 view .LVU91
 583:usbdrv/usbdrv.c **** #endif
 299               		.loc 1 583 18 is_stmt 0 view .LVU92
 300 00e6 1092 0000 		sts usbRxLen,__zero_reg__
 301 00ea 00C0      		rjmp .L2
 302               	.LVL25:
 303               	.L63:
 583:usbdrv/usbdrv.c **** #endif
 304               		.loc 1 583 18 view .LVU93
 305 00ec C8E0      		ldi r28,lo8(8)
 306 00ee D0E0      		ldi r29,0
 307 00f0 00C0      		rjmp .L27
 308               	.LVL26:
 309               	.L28:
 310               	.LBB100:
 311               	.LBB62:
 312               	.LBB59:
 313               	.LBB56:
 516:usbdrv/usbdrv.c **** }
 314               		.loc 1 516 5 is_stmt 1 view .LVU94
 516:usbdrv/usbdrv.c **** }
 315               		.loc 1 516 5 is_stmt 0 view .LVU95
 316               	.LBE56:
 317               	.LBE59:
 535:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 318               		.loc 1 535 5 is_stmt 1 view .LVU96
 536:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 319               		.loc 1 536 9 view .LVU97
 320 00f2 60E0      		ldi r22,0
 321 00f4 80E0      		ldi r24,lo8(usbTxBuf+1)
 322 00f6 90E0      		ldi r25,hi8(usbTxBuf+1)
 323 00f8 0E94 0000 		call usbCrc16Append
 324               	.LVL27:
 537:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 325               		.loc 1 537 9 view .LVU98
 538:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 326               		.loc 1 538 9 view .LVU99
 327               	.L36:
 539:usbdrv/usbdrv.c ****     }else{
 328               		.loc 1 539 13 view .LVU100
 539:usbdrv/usbdrv.c ****     }else{
 329               		.loc 1 539 23 is_stmt 0 view .LVU101
 330 00fc 8FEF      		ldi r24,lo8(-1)
 331 00fe 9FEF      		ldi r25,lo8(-1)
 332 0100 9093 0000 		sts usbMsgLen+1,r25
 333 0104 8093 0000 		sts usbMsgLen,r24
 334               	.LVL28:
 335               	.L33:
 544:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 336               		.loc 1 544 5 is_stmt 1 view .LVU102
 544:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 337               		.loc 1 544 14 is_stmt 0 view .LVU103
 338 0108 1093 0000 		sts usbTxLen,r17
 545:usbdrv/usbdrv.c **** }
 339               		.loc 1 545 32 is_stmt 1 view .LVU104
 546:usbdrv/usbdrv.c **** 
 340               		.loc 1 546 1 is_stmt 0 view .LVU105
 341 010c 00C0      		rjmp .L26
 342               	.LVL29:
 343               	.L64:
 546:usbdrv/usbdrv.c **** 
 344               		.loc 1 546 1 view .LVU106
 345               	.LBE62:
 346               	.LBE100:
 347               	.LBB101:
 348               	.LBB98:
 349               	.LBB70:
 440:usbdrv/usbdrv.c ****             return;
 350               		.loc 1 440 9 is_stmt 1 view .LVU107
 440:usbdrv/usbdrv.c ****             return;
 351               		.loc 1 440 11 is_stmt 0 view .LVU108
 352 010e 6830      		cpi r22,lo8(8)
 353 0110 01F4      		brne .L5
 442:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 354               		.loc 1 442 9 is_stmt 1 view .LVU109
 443:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 355               		.loc 1 443 9 view .LVU110
 443:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 356               		.loc 1 443 21 is_stmt 0 view .LVU111
 357 0112 83EC      		ldi r24,lo8(-61)
 358 0114 8093 0000 		sts usbTxBuf,r24
 444:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 359               		.loc 1 444 9 is_stmt 1 view .LVU112
 444:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 360               		.loc 1 444 18 is_stmt 0 view .LVU113
 361 0118 8AE5      		ldi r24,lo8(90)
 362 011a 8093 0000 		sts usbTxLen,r24
 445:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 363               		.loc 1 445 9 is_stmt 1 view .LVU114
 445:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 364               		.loc 1 445 21 is_stmt 0 view .LVU115
 365 011e 1092 0000 		sts usbMsgFlags,__zero_reg__
 446:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 366               		.loc 1 446 9 is_stmt 1 view .LVU116
 367               	.LVL30:
 447:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 368               		.loc 1 447 9 view .LVU117
 446:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 369               		.loc 1 446 15 is_stmt 0 view .LVU118
 370 0122 8881      		ld r24,Y
 371 0124 8076      		andi r24,lo8(96)
 372               	.LVL31:
 447:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 373               		.loc 1 447 11 view .LVU119
 374 0126 01F4      		brne .L66
 450:usbdrv/usbdrv.c ****         }
 375               		.loc 1 450 13 is_stmt 1 view .LVU120
 376               	.LVL32:
 377               	.LBB71:
 378               	.LBI71:
 362:usbdrv/usbdrv.c **** {
 379               		.loc 1 362 27 view .LVU121
 380               	.LBB72:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 381               		.loc 1 364 1 view .LVU122
 365:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 382               		.loc 1 365 1 view .LVU123
 365:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383               		.loc 1 365 9 is_stmt 0 view .LVU124
 384 0128 9A81      		ldd r25,Y+2
 385               	.LVL33:
 370:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 386               		.loc 1 370 5 is_stmt 1 view .LVU125
 370:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 387               		.loc 1 370 16 is_stmt 0 view .LVU126
 388 012a 1092 0000 		sts usbTxBuf+9,__zero_reg__
 389               	.LBB73:
 371:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 390               		.loc 1 371 5 is_stmt 1 view .LVU127
 391 012e 8981      		ldd r24,Y+1
 392               	.LVL34:
 371:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 393               		.loc 1 371 5 view .LVU128
 372:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 394               		.loc 1 372 5 view .LVU129
 395 0130 8111      		cpse r24,__zero_reg__
 396 0132 00C0      		rjmp .L9
 397               	.LBB74:
 373:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 398               		.loc 1 373 9 view .LVU130
 399               	.LVL35:
 374:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 400               		.loc 1 374 9 view .LVU131
 380:usbdrv/usbdrv.c ****         len = 2;
 401               		.loc 1 380 9 view .LVU132
 380:usbdrv/usbdrv.c ****         len = 2;
 402               		.loc 1 380 20 is_stmt 0 view .LVU133
 403 0134 1092 0000 		sts usbTxBuf+10,__zero_reg__
 381:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 404               		.loc 1 381 9 is_stmt 1 view .LVU134
 405               	.LVL36:
 381:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 406               		.loc 1 381 9 is_stmt 0 view .LVU135
 407               	.LBE74:
 408 0138 22E0      		ldi r18,lo8(2)
 409 013a 30E0      		ldi r19,0
 410               	.LBE73:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 411               		.loc 1 364 20 view .LVU136
 412 013c 80E0      		ldi r24,lo8(usbTxBuf+9)
 413 013e 90E0      		ldi r25,hi8(usbTxBuf+9)
 414               	.LVL37:
 415               	.L10:
 416               	.LBB87:
 410:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 417               		.loc 1 410 5 is_stmt 1 view .LVU137
 418               	.LBE87:
 411:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 419               		.loc 1 411 5 view .LVU138
 411:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 420               		.loc 1 411 15 is_stmt 0 view .LVU139
 421 0140 9093 0000 		sts usbMsgPtr+1,r25
 422 0144 8093 0000 		sts usbMsgPtr,r24
 423               	.L18:
 413:usbdrv/usbdrv.c **** }
 424               		.loc 1 413 5 is_stmt 1 view .LVU140
 425               	.LVL38:
 413:usbdrv/usbdrv.c **** }
 426               		.loc 1 413 5 is_stmt 0 view .LVU141
 427               	.LBE72:
 428               	.LBE71:
 453:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 429               		.loc 1 453 9 is_stmt 1 view .LVU142
 430               	.L8:
 465:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 431               		.loc 1 465 9 view .LVU143
 469:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 432               		.loc 1 469 13 view .LVU144
 433 0148 8E81      		ldd r24,Y+6
 434 014a 9F81      		ldd r25,Y+7
 435 014c 8217      		cp r24,r18
 436 014e 9307      		cpc r25,r19
 437 0150 00F4      		brsh .L22
 438 0152 9C01      		movw r18,r24
 439               	.LVL39:
 440               	.L22:
 472:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 441               		.loc 1 472 9 view .LVU145
 472:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 442               		.loc 1 472 19 is_stmt 0 view .LVU146
 443 0154 3093 0000 		sts usbMsgLen+1,r19
 444 0158 2093 0000 		sts usbMsgLen,r18
 445               	.LBE70:
 446 015c 00C0      		rjmp .L5
 447               	.LVL40:
 448               	.L65:
 449               	.LBB94:
 476:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 450               		.loc 1 476 13 is_stmt 1 view .LVU147
 476:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 451               		.loc 1 476 26 is_stmt 0 view .LVU148
 452 015e CE01      		movw r24,r28
 453 0160 0E94 0000 		call usbFunctionWrite
 454               	.LVL41:
 477:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 455               		.loc 1 477 13 is_stmt 1 view .LVU149
 477:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 456               		.loc 1 477 15 is_stmt 0 view .LVU150
 457 0164 8F3F      		cpi r24,lo8(-1)
 458 0166 01F0      		breq .L67
 479:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 459               		.loc 1 479 19 is_stmt 1 view .LVU151
 479:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 460               		.loc 1 479 21 is_stmt 0 view .LVU152
 461 0168 8823      		tst r24
 462 016a 01F4      		brne .+2
 463 016c 00C0      		rjmp .L5
 480:usbdrv/usbdrv.c ****             }
 464               		.loc 1 480 17 is_stmt 1 view .LVU153
 480:usbdrv/usbdrv.c ****             }
 465               		.loc 1 480 27 is_stmt 0 view .LVU154
 466 016e 1092 0000 		sts usbMsgLen+1,__zero_reg__
 467 0172 1092 0000 		sts usbMsgLen,__zero_reg__
 468 0176 00C0      		rjmp .L5
 469               	.LVL42:
 470               	.L29:
 480:usbdrv/usbdrv.c ****             }
 471               		.loc 1 480 27 view .LVU155
 472 0178 A0E0      		ldi r26,lo8(usbTxBuf+1)
 473 017a B0E0      		ldi r27,hi8(usbTxBuf+1)
 474               	.LVL43:
 480:usbdrv/usbdrv.c ****             }
 475               		.loc 1 480 27 view .LVU156
 476 017c 8FEF      		ldi r24,lo8(-1)
 477 017e 8C0F      		add r24,r28
 478 0180 90E0      		ldi r25,0
 479 0182 0196      		adiw r24,1
 480 0184 8E0F      		add r24,r30
 481 0186 9F1F      		adc r25,r31
 482               	.LVL44:
 483               	.L32:
 480:usbdrv/usbdrv.c ****             }
 484               		.loc 1 480 27 view .LVU157
 485               	.LBE94:
 486               	.LBE98:
 487               	.LBE101:
 488               	.LBB102:
 489               	.LBB63:
 490               	.LBB60:
 491               	.LBB57:
 492               	.LBB54:
 509:usbdrv/usbdrv.c ****                     *data++ = *r++;
 493               		.loc 1 509 17 is_stmt 1 view .LVU158
 510:usbdrv/usbdrv.c ****                 }while(--i);
 494               		.loc 1 510 21 view .LVU159
 495 0188 9F01      		movw r18,r30
 510:usbdrv/usbdrv.c ****                 }while(--i);
 496               		.loc 1 510 33 is_stmt 0 view .LVU160
 497 018a 3196      		adiw r30,1
 498               	.LVL45:
 510:usbdrv/usbdrv.c ****                 }while(--i);
 499               		.loc 1 510 31 view .LVU161
 500 018c E901      		movw r28,r18
 501 018e 2881      		ld r18,Y
 510:usbdrv/usbdrv.c ****                 }while(--i);
 502               		.loc 1 510 29 view .LVU162
 503 0190 2D93      		st X+,r18
 511:usbdrv/usbdrv.c ****             }
 504               		.loc 1 511 23 is_stmt 1 view .LVU163
 511:usbdrv/usbdrv.c ****             }
 505               		.loc 1 511 17 is_stmt 0 view .LVU164
 506 0192 E817      		cp r30,r24
 507 0194 F907      		cpc r31,r25
 508 0196 01F4      		brne .L32
 509 0198 00C0      		rjmp .L31
 510               	.LVL46:
 511               	.L66:
 511:usbdrv/usbdrv.c ****             }
 512               		.loc 1 511 17 view .LVU165
 513               	.LBE54:
 514               	.LBE57:
 515               	.LBE60:
 516               	.LBE63:
 517               	.LBE102:
 518               	.LBB103:
 519               	.LBB99:
 520               	.LBB95:
 448:usbdrv/usbdrv.c ****         }else{
 521               		.loc 1 448 13 is_stmt 1 view .LVU166
 448:usbdrv/usbdrv.c ****         }else{
 522               		.loc 1 448 24 is_stmt 0 view .LVU167
 523 019a CE01      		movw r24,r28
 524               	.LVL47:
 448:usbdrv/usbdrv.c ****         }else{
 525               		.loc 1 448 24 view .LVU168
 526 019c 0E94 0000 		call usbFunctionSetup
 527               	.LVL48:
 448:usbdrv/usbdrv.c ****         }else{
 528               		.loc 1 448 24 view .LVU169
 529 01a0 9C01      		movw r18,r24
 530               	.LVL49:
 453:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 531               		.loc 1 453 9 is_stmt 1 view .LVU170
 453:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 532               		.loc 1 453 11 is_stmt 0 view .LVU171
 533 01a2 2F3F      		cpi r18,-1
 534 01a4 3207      		cpc r19,r18
 535 01a6 01F4      		brne .L8
 455:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 536               		.loc 1 455 13 is_stmt 1 view .LVU172
 455:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 537               		.loc 1 455 15 is_stmt 0 view .LVU173
 538 01a8 8881      		ld r24,Y
 539 01aa 87FF      		sbrs r24,7
 540 01ac 00C0      		rjmp .L21
 456:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 541               		.loc 1 456 17 is_stmt 1 view .LVU174
 459:usbdrv/usbdrv.c ****                 }
 542               		.loc 1 459 21 view .LVU175
 459:usbdrv/usbdrv.c ****                 }
 543               		.loc 1 459 30 is_stmt 0 view .LVU176
 544 01ae 2E81      		ldd r18,Y+6
 545 01b0 3F81      		ldd r19,Y+7
 546               	.LVL50:
 547               	.L21:
 462:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 548               		.loc 1 462 13 is_stmt 1 view .LVU177
 462:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 549               		.loc 1 462 25 is_stmt 0 view .LVU178
 550 01b2 80E8      		ldi r24,lo8(-128)
 551 01b4 8093 0000 		sts usbMsgFlags,r24
 552 01b8 00C0      		rjmp .L22
 553               	.LVL51:
 554               	.L67:
 462:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 555               		.loc 1 462 25 view .LVU179
 556               	.LBE95:
 557               	.LBB96:
 478:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 558               		.loc 1 478 17 is_stmt 1 view .LVU180
 478:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 559               		.loc 1 478 26 is_stmt 0 view .LVU181
 560 01ba 8EE1      		ldi r24,lo8(30)
 561               	.LVL52:
 478:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 562               		.loc 1 478 26 view .LVU182
 563 01bc 8093 0000 		sts usbTxLen,r24
 564 01c0 00C0      		rjmp .L5
 565               	.LVL53:
 566               	.L9:
 478:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 567               		.loc 1 478 26 view .LVU183
 568               	.LBE96:
 569               	.LBB97:
 570               	.LBB93:
 571               	.LBB92:
 572               	.LBB88:
 389:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 573               		.loc 1 389 5 is_stmt 1 view .LVU184
 574 01c2 8530      		cpi r24,lo8(5)
 575 01c4 01F0      		breq .L68
 392:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 576               		.loc 1 392 5 view .LVU185
 577 01c6 8630      		cpi r24,lo8(6)
 578 01c8 01F0      		breq .L69
 395:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 579               		.loc 1 395 5 view .LVU186
 580 01ca 8830      		cpi r24,lo8(8)
 581 01cc 01F0      		breq .L39
 398:usbdrv/usbdrv.c ****         usbConfiguration = value;
 582               		.loc 1 398 5 view .LVU187
 583 01ce 8930      		cpi r24,lo8(9)
 584 01d0 01F0      		breq .L70
 401:usbdrv/usbdrv.c ****         len = 1;
 585               		.loc 1 401 5 view .LVU188
 586 01d2 41E0      		ldi r20,lo8(1)
 587 01d4 90E0      		ldi r25,0
 588               	.LVL54:
 401:usbdrv/usbdrv.c ****         len = 1;
 589               		.loc 1 401 5 is_stmt 0 view .LVU189
 590 01d6 8A30      		cpi r24,lo8(10)
 591 01d8 01F0      		breq .L20
 592 01da 40E0      		ldi r20,0
 593               	.L20:
 401:usbdrv/usbdrv.c ****         len = 1;
 594               		.loc 1 401 5 view .LVU190
 595 01dc 242F      		mov r18,r20
 596 01de 392F      		mov r19,r25
 597               	.LBE88:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 598               		.loc 1 364 20 view .LVU191
 599 01e0 80E0      		ldi r24,lo8(usbTxBuf+9)
 600 01e2 90E0      		ldi r25,hi8(usbTxBuf+9)
 601               	.LVL55:
 602               	.LBB89:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 603               		.loc 1 364 20 view .LVU192
 604 01e4 00C0      		rjmp .L10
 605               	.LVL56:
 606               	.L68:
 390:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 607               		.loc 1 390 9 is_stmt 1 view .LVU193
 390:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 608               		.loc 1 390 26 is_stmt 0 view .LVU194
 609 01e6 9093 0000 		sts usbNewDeviceAddr,r25
 391:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 610               		.loc 1 391 31 is_stmt 1 view .LVU195
 611 01ea 30E0      		ldi r19,0
 612 01ec 20E0      		ldi r18,0
 613               	.LBE89:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 614               		.loc 1 364 20 is_stmt 0 view .LVU196
 615 01ee 80E0      		ldi r24,lo8(usbTxBuf+9)
 616 01f0 90E0      		ldi r25,hi8(usbTxBuf+9)
 617               	.LVL57:
 618               	.LBB90:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 619               		.loc 1 364 20 view .LVU197
 620 01f2 00C0      		rjmp .L10
 621               	.LVL58:
 622               	.L39:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 623               		.loc 1 364 20 view .LVU198
 624 01f4 21E0      		ldi r18,lo8(1)
 625 01f6 30E0      		ldi r19,0
 396:usbdrv/usbdrv.c ****         len = 1;
 626               		.loc 1 396 17 view .LVU199
 627 01f8 80E0      		ldi r24,lo8(usbConfiguration)
 628 01fa 90E0      		ldi r25,hi8(usbConfiguration)
 629               	.LVL59:
 396:usbdrv/usbdrv.c ****         len = 1;
 630               		.loc 1 396 17 view .LVU200
 631 01fc 00C0      		rjmp .L10
 632               	.LVL60:
 633               	.L69:
 393:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 634               		.loc 1 393 9 is_stmt 1 view .LVU201
 393:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 635               		.loc 1 393 15 is_stmt 0 view .LVU202
 636 01fe 8B81      		ldd r24,Y+3
 637               	.LVL61:
 638               	.LBB75:
 639               	.LBI75:
 311:usbdrv/usbdrv.c **** {
 640               		.loc 1 311 27 is_stmt 1 view .LVU203
 641               	.LBB76:
 313:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 642               		.loc 1 313 1 view .LVU204
 314:usbdrv/usbdrv.c **** 
 643               		.loc 1 314 1 view .LVU205
 644               	.LBB77:
 316:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 645               		.loc 1 316 5 view .LVU206
 316:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 646               		.loc 1 316 5 view .LVU207
 317:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 647               		.loc 1 317 5 view .LVU208
 648 0200 8130      		cpi r24,lo8(1)
 649 0202 01F0      		breq .L71
 319:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 650               		.loc 1 319 5 view .LVU209
 651 0204 8230      		cpi r24,lo8(2)
 652 0206 01F0      		breq .L72
 321:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 653               		.loc 1 321 5 view .LVU210
 654 0208 8330      		cpi r24,lo8(3)
 655 020a 01F0      		breq .L73
 656               	.L38:
 321:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 657               		.loc 1 321 5 is_stmt 0 view .LVU211
 658               	.LBE77:
 313:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 659               		.loc 1 313 13 view .LVU212
 660 020c 30E0      		ldi r19,0
 661 020e 20E0      		ldi r18,0
 662               	.LVL62:
 663               	.L14:
 353:usbdrv/usbdrv.c ****     return len;
 664               		.loc 1 353 5 is_stmt 1 view .LVU213
 353:usbdrv/usbdrv.c ****     return len;
 665               		.loc 1 353 17 is_stmt 0 view .LVU214
 666 0210 80E4      		ldi r24,lo8(64)
 667 0212 8093 0000 		sts usbMsgFlags,r24
 354:usbdrv/usbdrv.c **** }
 668               		.loc 1 354 5 is_stmt 1 view .LVU215
 669               	.LVL63:
 354:usbdrv/usbdrv.c **** }
 670               		.loc 1 354 5 is_stmt 0 view .LVU216
 671               	.LBE76:
 672               	.LBE75:
 394:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 673               		.loc 1 394 9 is_stmt 1 view .LVU217
 674 0216 00C0      		rjmp .L8
 675               	.LVL64:
 676               	.L70:
 399:usbdrv/usbdrv.c ****         usbResetStall();
 677               		.loc 1 399 9 view .LVU218
 399:usbdrv/usbdrv.c ****         usbResetStall();
 678               		.loc 1 399 26 is_stmt 0 view .LVU219
 679 0218 9093 0000 		sts usbConfiguration,r25
 400:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 680               		.loc 1 400 9 is_stmt 1 view .LVU220
 681               	.LBB82:
 682               	.LBI82:
 207:usbdrv/usbdrv.c **** {
 683               		.loc 1 207 21 view .LVU221
 684               	.LBB83:
 215:usbdrv/usbdrv.c **** 
 685               		.loc 1 215 1 view .LVU222
 686 021c 30E0      		ldi r19,0
 687 021e 20E0      		ldi r18,0
 688               	.LBE83:
 689               	.LBE82:
 690               	.LBE90:
 364:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 691               		.loc 1 364 20 is_stmt 0 view .LVU223
 692 0220 80E0      		ldi r24,lo8(usbTxBuf+9)
 693 0222 90E0      		ldi r25,hi8(usbTxBuf+9)
 694               	.LVL65:
 695               	.LBB91:
 696               	.LBB85:
 697               	.LBB84:
 215:usbdrv/usbdrv.c **** 
 698               		.loc 1 215 1 view .LVU224
 699 0224 00C0      		rjmp .L10
 700               	.LVL66:
 701               	.L73:
 215:usbdrv/usbdrv.c **** 
 702               		.loc 1 215 1 view .LVU225
 703               	.LBE84:
 704               	.LBE85:
 705               	.LBB86:
 706               	.LBB81:
 707               	.LBB80:
 708               	.LBB78:
 327:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 709               		.loc 1 327 9 is_stmt 1 view .LVU226
 327:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 710               		.loc 1 327 9 view .LVU227
 328:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 711               		.loc 1 328 9 view .LVU228
 712 0226 9923      		tst r25
 713 0228 01F0      		breq .L74
 330:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 714               		.loc 1 330 9 view .LVU229
 715 022a 9130      		cpi r25,lo8(1)
 716 022c 01F0      		breq .L75
 332:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 717               		.loc 1 332 9 view .LVU230
 718 022e 9230      		cpi r25,lo8(2)
 719 0230 01F4      		brne .L38
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 720               		.loc 1 333 13 view .LVU231
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 721               		.loc 1 333 13 view .LVU232
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 722               		.loc 1 333 13 view .LVU233
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 723               		.loc 1 333 13 view .LVU234
 724               	.LVL67:
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 725               		.loc 1 333 13 view .LVU235
 726 0232 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 727 0234 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 728               	.LVL68:
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 729               		.loc 1 333 13 is_stmt 0 view .LVU236
 730 0236 9093 0000 		sts usbMsgPtr+1,r25
 731 023a 8093 0000 		sts usbMsgPtr,r24
 732 023e 2CE0      		ldi r18,lo8(12)
 733 0240 30E0      		ldi r19,0
 734 0242 00C0      		rjmp .L14
 735               	.LVL69:
 736               	.L71:
 333:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 737               		.loc 1 333 13 view .LVU237
 738               	.LBE78:
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 739               		.loc 1 318 9 is_stmt 1 view .LVU238
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 740               		.loc 1 318 9 view .LVU239
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 741               		.loc 1 318 9 view .LVU240
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 742               		.loc 1 318 9 view .LVU241
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 743               		.loc 1 318 9 view .LVU242
 744 0244 80E0      		ldi r24,lo8(usbDescriptorDevice)
 745 0246 90E0      		ldi r25,hi8(usbDescriptorDevice)
 746               	.LVL70:
 318:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 747               		.loc 1 318 9 is_stmt 0 view .LVU243
 748 0248 9093 0000 		sts usbMsgPtr+1,r25
 749 024c 8093 0000 		sts usbMsgPtr,r24
 750 0250 22E1      		ldi r18,lo8(18)
 751 0252 30E0      		ldi r19,0
 752 0254 00C0      		rjmp .L14
 753               	.LVL71:
 754               	.L72:
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 755               		.loc 1 320 9 is_stmt 1 view .LVU244
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 756               		.loc 1 320 9 view .LVU245
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 757               		.loc 1 320 9 view .LVU246
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 758               		.loc 1 320 9 view .LVU247
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 759               		.loc 1 320 9 view .LVU248
 760 0256 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 761 0258 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 762               	.LVL72:
 320:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 763               		.loc 1 320 9 is_stmt 0 view .LVU249
 764 025a 9093 0000 		sts usbMsgPtr+1,r25
 765 025e 8093 0000 		sts usbMsgPtr,r24
 766 0262 22E1      		ldi r18,lo8(18)
 767 0264 30E0      		ldi r19,0
 768 0266 00C0      		rjmp .L14
 769               	.LVL73:
 770               	.L75:
 771               	.LBB79:
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 772               		.loc 1 331 13 is_stmt 1 view .LVU250
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 773               		.loc 1 331 13 view .LVU251
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 774               		.loc 1 331 13 view .LVU252
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 775               		.loc 1 331 13 view .LVU253
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 776               		.loc 1 331 13 view .LVU254
 777 0268 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 778 026a 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 779               	.LVL74:
 331:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 780               		.loc 1 331 13 is_stmt 0 view .LVU255
 781 026c 9093 0000 		sts usbMsgPtr+1,r25
 782 0270 8093 0000 		sts usbMsgPtr,r24
 783 0274 22E1      		ldi r18,lo8(18)
 784 0276 30E0      		ldi r19,0
 785 0278 00C0      		rjmp .L14
 786               	.LVL75:
 787               	.L74:
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 788               		.loc 1 329 13 is_stmt 1 view .LVU256
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 789               		.loc 1 329 13 view .LVU257
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 790               		.loc 1 329 13 view .LVU258
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 791               		.loc 1 329 13 view .LVU259
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 792               		.loc 1 329 13 view .LVU260
 793 027a 80E0      		ldi r24,lo8(usbDescriptorString0)
 794 027c 90E0      		ldi r25,hi8(usbDescriptorString0)
 795               	.LVL76:
 329:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 796               		.loc 1 329 13 is_stmt 0 view .LVU261
 797 027e 9093 0000 		sts usbMsgPtr+1,r25
 798 0282 8093 0000 		sts usbMsgPtr,r24
 799 0286 24E0      		ldi r18,lo8(4)
 800 0288 30E0      		ldi r19,0
 801 028a 00C0      		rjmp .L14
 802               	.LBE79:
 803               	.LBE80:
 804               	.LBE81:
 805               	.LBE86:
 806               	.LBE91:
 807               	.LBE92:
 808               	.LBE93:
 809               	.LBE97:
 810               	.LBE99:
 811               	.LBE103:
 812               		.cfi_endproc
 813               	.LFE9:
 815               	.global	usbInit
 817               	usbInit:
 818               	.LFB10:
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 606:usbdrv/usbdrv.c **** 
 607:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 608:usbdrv/usbdrv.c **** {
 819               		.loc 1 608 1 is_stmt 1 view -0
 820               		.cfi_startproc
 821               	/* prologue: function */
 822               	/* frame size = 0 */
 823               	/* stack size = 0 */
 824               	.L__stack_usage = 0
 609:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 610:usbdrv/usbdrv.c **** /*
 611:usbdrv/usbdrv.c **** In this enviroment.
 612:usbdrv/usbdrv.c **** compiler: gcc version 4.3.2 (WinAVR 20090313)
 613:usbdrv/usbdrv.c **** mcu target: mega164p
 614:usbdrv/usbdrv.c **** gcc produces a bad object. This source is good. The easy way to fix this problem is rearrange it.
 615:usbdrv/usbdrv.c **** */
 616:usbdrv/usbdrv.c ****     //USB_INTR_CFG |= USB_INTR_CFG_SET;
 617:usbdrv/usbdrv.c ****     USB_INTR_CFG = USB_INTR_CFG_SET;
 825               		.loc 1 617 5 view .LVU263
 826               		.loc 1 617 18 is_stmt 0 view .LVU264
 827 028c 8BE0      		ldi r24,lo8(11)
 828 028e 85BF      		out 0x35,r24
 618:usbdrv/usbdrv.c **** #endif
 619:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 620:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 621:usbdrv/usbdrv.c **** #endif
 622:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 829               		.loc 1 622 5 is_stmt 1 view .LVU265
 830               		.loc 1 622 21 is_stmt 0 view .LVU266
 831 0290 8BB7      		in r24,0x3b
 832 0292 8064      		ori r24,lo8(64)
 833 0294 8BBF      		out 0x3b,r24
 623:usbdrv/usbdrv.c ****     usbResetDataToggling();
 834               		.loc 1 623 5 is_stmt 1 view .LVU267
 205:usbdrv/usbdrv.c **** 
 835               		.loc 1 205 1 view .LVU268
 836               	/* epilogue start */
 624:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 625:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 626:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 627:usbdrv/usbdrv.c ****     usbTxLen3 = USBPID_NAK;
 628:usbdrv/usbdrv.c **** #endif
 629:usbdrv/usbdrv.c **** #endif
 630:usbdrv/usbdrv.c **** }
 837               		.loc 1 630 1 is_stmt 0 view .LVU269
 838 0296 0895      		ret
 839               		.cfi_endproc
 840               	.LFE10:
 842               	.global	usbDescriptorConfiguration
 843               		.section	.progmem.data,"a",@progbits
 846               	usbDescriptorConfiguration:
 847 0000 0902 1200 		.string	"\t\002\022"
 848 0004 0101 00   		.string	"\001\001"
 849 0007 8014 0904 		.string	"\200\024\t\004"
 849      00
 850 000c 00        		.string	""
 851 000d 00        		.string	""
 852 000e 00        		.string	""
 853 000f 00        		.string	""
 854 0010 00        		.string	""
 855 0011 00        		.string	""
 856               	.global	usbDescriptorDevice
 859               	usbDescriptorDevice:
 860 0012 1201 1001 		.string	"\022\001\020\001\377"
 860      FF00 
 861 0018 00        		.string	""
 862 0019 08C0 16DC 		.string	"\b\300\026\334\005"
 862      0500 
 863 001f 0101 0200 		.string	"\001\001\002"
 864 0023 01        		.ascii	"\001"
 865               	.global	usbDescriptorStringDevice
 868               	usbDescriptorStringDevice:
 869 0024 0C03      		.word	780
 870 0026 6B00      		.word	107
 871 0028 6100      		.word	97
 872 002a 7A00      		.word	122
 873 002c 7A00      		.word	122
 874 002e 6F00      		.word	111
 875               	.global	usbDescriptorStringVendor
 878               	usbDescriptorStringVendor:
 879 0030 1203      		.word	786
 880 0032 6F00      		.word	111
 881 0034 6200      		.word	98
 882 0036 6400      		.word	100
 883 0038 6500      		.word	101
 884 003a 7600      		.word	118
 885 003c 2E00      		.word	46
 886 003e 6100      		.word	97
 887 0040 7400      		.word	116
 888               	.global	usbDescriptorString0
 891               	usbDescriptorString0:
 892 0042 0403 0904 		.ascii	"\004\003\t\004"
 893               		.local	usbMsgFlags
 894               		.comm	usbMsgFlags,1,1
 895               		.data
 898               	usbMsgLen:
 899 0000 FFFF      		.word	-1
 900               		.comm	usbMsgPtr,2,1
 901               		.comm	usbTxBuf,11,1
 902               	.global	usbTxLen
 905               	usbTxLen:
 906 0002 5A        		.byte	90
 907               		.comm	usbRxToken,1,1
 908               		.comm	usbCurrentTok,1,1
 909               		.comm	usbRxLen,1,1
 910               		.comm	usbConfiguration,1,1
 911               		.comm	usbNewDeviceAddr,1,1
 912               		.comm	usbDeviceAddr,1,1
 913               		.comm	usbInputBufOffset,1,1
 914               		.comm	usbRxBuf,22,1
 915               		.text
 916               	.Letext0:
 917               		.file 2 "/usr/avr/include/stdint.h"
 918               		.file 3 "usbdrv/usbdrv.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbdrv.c
     /tmp/cc8wle9r.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8wle9r.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8wle9r.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8wle9r.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8wle9r.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8wle9r.s:12     .text:0000000000000000 usbPoll
                            *COM*:0000000000000001 usbRxLen
     /tmp/cc8wle9r.s:905    .data:0000000000000002 usbTxLen
     /tmp/cc8wle9r.s:898    .data:0000000000000000 usbMsgLen
                            *COM*:000000000000000b usbTxBuf
                            *COM*:0000000000000002 usbMsgPtr
                             .bss:0000000000000000 usbMsgFlags
                            *COM*:0000000000000001 usbNewDeviceAddr
                            *COM*:0000000000000001 usbDeviceAddr
                            *COM*:0000000000000001 usbInputBufOffset
                            *COM*:0000000000000016 usbRxBuf
                            *COM*:0000000000000001 usbRxToken
                            *COM*:0000000000000001 usbConfiguration
     /tmp/cc8wle9r.s:868    .progmem.data:0000000000000024 usbDescriptorStringDevice
     /tmp/cc8wle9r.s:859    .progmem.data:0000000000000012 usbDescriptorDevice
     /tmp/cc8wle9r.s:846    .progmem.data:0000000000000000 usbDescriptorConfiguration
     /tmp/cc8wle9r.s:878    .progmem.data:0000000000000030 usbDescriptorStringVendor
     /tmp/cc8wle9r.s:891    .progmem.data:0000000000000042 usbDescriptorString0
     /tmp/cc8wle9r.s:817    .text:000000000000028c usbInit
                            *COM*:0000000000000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionWrite
usbFunctionSetup
__do_copy_data
__do_clear_bss
