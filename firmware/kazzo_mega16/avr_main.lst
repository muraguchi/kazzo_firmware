   1               		.file	"avr_main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	usbFunctionWrite
  12               	usbFunctionWrite:
  13               	.LVL0:
  14               	.LFB10:
  15               		.file 1 "avr_main.c"
   1:avr_main.c    **** #include <avr/wdt.h>
   2:avr_main.c    **** #include <avr/interrupt.h>
   3:avr_main.c    **** #include <util/delay.h>
   4:avr_main.c    **** #include <string.h>
   5:avr_main.c    **** #include <avr/pgmspace.h>
   6:avr_main.c    **** #include "usbdrv.h"
   7:avr_main.c    **** #include "bus_access.h"
   8:avr_main.c    **** #include "disk_access.h"
   9:avr_main.c    **** #include "flashmemory.h"
  10:avr_main.c    **** #include "mcu_program.h"
  11:avr_main.c    **** #include "kazzo_request.h"
  12:avr_main.c    **** 
  13:avr_main.c    **** //---- global variable ----
  14:avr_main.c    **** #define REQUEST_NOP (0xee)
  15:avr_main.c    **** static struct write_command{
  16:avr_main.c    **** 	enum request request;
  17:avr_main.c    **** 	uint16_t address, length, offset;
  18:avr_main.c    **** }request_both_write, request_cpu_program, request_ppu_program;
  19:avr_main.c    **** 
  20:avr_main.c    **** //---- function start ----
  21:avr_main.c    **** /*static uint8_t cpu_buffer[FLASH_PACKET_SIZE];
  22:avr_main.c    **** static uint8_t ppu_buffer[FLASH_PACKET_SIZE];*/
  23:avr_main.c    **** uchar usbFunctionWrite(uchar *data, uchar len)
  24:avr_main.c    **** {
  16               		.loc 1 24 1 view -0
  17               		.cfi_startproc
  18               		.loc 1 24 1 is_stmt 0 view .LVU1
  19 0000 EF92      		push r14
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 14, -2
  23 0002 FF92      		push r15
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 15, -3
  27 0004 1F93      		push r17
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 17, -4
  31 0006 CF93      		push r28
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 6
  34               		.cfi_offset 28, -5
  35 0008 DF93      		push r29
  36               	.LCFI4:
  37               		.cfi_def_cfa_offset 7
  38               		.cfi_offset 29, -6
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 5 */
  42               	.L__stack_usage = 5
  43 000a 9C01      		movw r18,r24
  25:avr_main.c    **** 	static uint8_t cpu_buffer[FLASH_PACKET_SIZE];
  44               		.loc 1 25 2 is_stmt 1 view .LVU2
  26:avr_main.c    **** 	static uint8_t ppu_buffer[FLASH_PACKET_SIZE];
  45               		.loc 1 26 2 view .LVU3
  27:avr_main.c    **** 	const uint16_t length = (uint16_t) len;
  46               		.loc 1 27 2 view .LVU4
  47               		.loc 1 27 17 is_stmt 0 view .LVU5
  48 000c C62F      		mov r28,r22
  49 000e D0E0      		ldi r29,0
  50               	.LVL1:
  28:avr_main.c    **** 	uchar i;
  51               		.loc 1 28 2 is_stmt 1 view .LVU6
  29:avr_main.c    **** 	//decode masked data
  30:avr_main.c    **** 	for(i = 0; i < len; i++){
  52               		.loc 1 30 2 view .LVU7
  53               		.loc 1 30 13 view .LVU8
  54               		.loc 1 30 2 is_stmt 0 view .LVU9
  55 0010 6623      		tst r22
  56 0012 01F0      		breq .L2
  57 0014 FC01      		movw r30,r24
  58 0016 6150      		subi r22,lo8(-(-1))
  59               	.LVL2:
  60               		.loc 1 30 2 view .LVU10
  61 0018 0196      		adiw r24,1
  62               	.LVL3:
  63               		.loc 1 30 2 view .LVU11
  64 001a 680F      		add r22,r24
  65 001c 792F      		mov r23,r25
  66 001e 711D      		adc r23,__zero_reg__
  31:avr_main.c    **** 		data[i] ^= 0xa5;
  67               		.loc 1 31 11 view .LVU12
  68 0020 95EA      		ldi r25,lo8(-91)
  69               	.LVL4:
  70               	.L3:
  71               		.loc 1 31 3 is_stmt 1 discriminator 3 view .LVU13
  72               		.loc 1 31 11 is_stmt 0 discriminator 3 view .LVU14
  73 0022 8191      		ld r24,Z+
  74               	.LVL5:
  75               		.loc 1 31 11 discriminator 3 view .LVU15
  76 0024 DF01      		movw r26,r30
  77 0026 1197      		sbiw r26,1
  78 0028 8927      		eor r24,r25
  79 002a 8C93      		st X,r24
  30:avr_main.c    **** 		data[i] ^= 0xa5;
  80               		.loc 1 30 22 is_stmt 1 discriminator 3 view .LVU16
  81               	.LVL6:
  30:avr_main.c    **** 		data[i] ^= 0xa5;
  82               		.loc 1 30 13 discriminator 3 view .LVU17
  30:avr_main.c    **** 		data[i] ^= 0xa5;
  83               		.loc 1 30 2 is_stmt 0 discriminator 3 view .LVU18
  84 002c 6E17      		cp r22,r30
  85 002e 7F07      		cpc r23,r31
  86 0030 01F4      		brne .L3
  87               	.LVL7:
  88               	.L2:
  32:avr_main.c    **** 	}
  33:avr_main.c    **** 	switch(request_both_write.request){
  89               		.loc 1 33 2 is_stmt 1 view .LVU19
  90               		.loc 1 33 27 is_stmt 0 view .LVU20
  91 0032 8091 0000 		lds r24,request_both_write
  92               		.loc 1 33 2 view .LVU21
  93 0036 8530      		cpi r24,lo8(5)
  94 0038 01F0      		breq .L4
  95 003a 8730      		cpi r24,lo8(7)
  96 003c 01F4      		brne .+2
  97 003e 00C0      		rjmp .L5
  98 0040 8430      		cpi r24,lo8(4)
  99 0042 01F4      		brne .+2
 100 0044 00C0      		rjmp .L23
  34:avr_main.c    **** 	case REQUEST_CPU_WRITE_6502:
  35:avr_main.c    **** 		cpu_write_6502(request_both_write.address + request_both_write.offset, length, data);
  36:avr_main.c    **** 		goto BOTH_NEXT;
  37:avr_main.c    **** 	case REQUEST_CPU_WRITE_FLASH:
  38:avr_main.c    **** 		cpu_write_flash(request_both_write.address + request_both_write.offset, length, data);
  39:avr_main.c    **** 		goto BOTH_NEXT;
  40:avr_main.c    **** 	case REQUEST_PPU_WRITE:
  41:avr_main.c    **** 		ppu_write(request_both_write.address + request_both_write.offset, length, data);
  42:avr_main.c    **** 		goto BOTH_NEXT;
  43:avr_main.c    **** 	BOTH_NEXT:{
  44:avr_main.c    **** 		request_both_write.offset += length;
  45:avr_main.c    **** 		uchar ret = request_both_write.offset == request_both_write.length;
  46:avr_main.c    **** 		if(ret){
  47:avr_main.c    **** 			request_both_write.request = REQUEST_NOP;
  48:avr_main.c    **** 		}
  49:avr_main.c    **** 		return ret;
  50:avr_main.c    **** 		}
  51:avr_main.c    **** 	default:
  52:avr_main.c    **** 		break;
 101               		.loc 1 52 3 is_stmt 1 view .LVU22
  53:avr_main.c    **** 	}
  54:avr_main.c    **** 	switch(request_cpu_program.request){
 102               		.loc 1 54 2 view .LVU23
 103               		.loc 1 54 28 is_stmt 0 view .LVU24
 104 0046 1091 0000 		lds r17,request_cpu_program
 105               		.loc 1 54 2 view .LVU25
 106 004a 412F      		mov r20,r17
 107 004c 4950      		subi r20,9
 108 004e 550B      		sbc r21,r21
 109 0050 4230      		cpi r20,2
 110 0052 5105      		cpc r21,__zero_reg__
 111 0054 00F4      		brsh .+2
 112 0056 00C0      		rjmp .L24
  55:avr_main.c    **** 	case REQUEST_FLASH_PROGRAM:
  56:avr_main.c    **** 	case REQUEST_FLASH_CONFIG_SET:{
  57:avr_main.c    **** 		memcpy(cpu_buffer + request_cpu_program.offset, data, length);
  58:avr_main.c    **** 		request_cpu_program.offset += length;
  59:avr_main.c    **** 		uchar ret = request_cpu_program.offset == request_cpu_program.length;
  60:avr_main.c    **** 		if(ret){
  61:avr_main.c    **** 			if(request_cpu_program.request == REQUEST_FLASH_CONFIG_SET){
  62:avr_main.c    **** 				flash_cpu_config(cpu_buffer, request_cpu_program.length);
  63:avr_main.c    **** 			}else{
  64:avr_main.c    **** 				flash_cpu_program(request_cpu_program.address, request_cpu_program.length, cpu_buffer);
  65:avr_main.c    **** 			}
  66:avr_main.c    **** 			request_cpu_program.request = REQUEST_NOP;
  67:avr_main.c    **** 		}
  68:avr_main.c    **** 		return ret;}
  69:avr_main.c    **** 	default:
  70:avr_main.c    **** 		break;
 113               		.loc 1 70 3 is_stmt 1 view .LVU26
  71:avr_main.c    **** 	}
  72:avr_main.c    **** 	switch(request_ppu_program.request){
 114               		.loc 1 72 2 view .LVU27
 115               		.loc 1 72 28 is_stmt 0 view .LVU28
 116 0058 1091 0000 		lds r17,request_ppu_program
 117               		.loc 1 72 2 view .LVU29
 118 005c 412F      		mov r20,r17
 119 005e 4950      		subi r20,9
 120 0060 550B      		sbc r21,r21
 121 0062 4230      		cpi r20,2
 122 0064 5105      		cpc r21,__zero_reg__
 123 0066 00F4      		brsh .+2
 124 0068 00C0      		rjmp .L25
  73:avr_main.c    **** 	case REQUEST_FLASH_PROGRAM:
  74:avr_main.c    **** 	case REQUEST_FLASH_CONFIG_SET:{
  75:avr_main.c    **** 		memcpy(ppu_buffer + request_ppu_program.offset, data, length);
  76:avr_main.c    **** 		request_ppu_program.offset += length;
  77:avr_main.c    **** 		uchar ret = request_ppu_program.offset == request_ppu_program.length;
  78:avr_main.c    **** 		if(ret){
  79:avr_main.c    **** 			if(request_ppu_program.request == REQUEST_FLASH_CONFIG_SET){
  80:avr_main.c    **** 				flash_ppu_config(ppu_buffer, request_cpu_program.length);
  81:avr_main.c    **** 			}else{
  82:avr_main.c    **** 				flash_ppu_program(request_ppu_program.address, request_ppu_program.length, ppu_buffer);
  83:avr_main.c    **** 			}
  84:avr_main.c    **** 			request_ppu_program.request = REQUEST_NOP;
  85:avr_main.c    **** 		}
  86:avr_main.c    **** 		return ret;}
  87:avr_main.c    **** 	default:
  88:avr_main.c    **** 		break;
  89:avr_main.c    **** 	}
  90:avr_main.c    **** 	return 1;
 125               		.loc 1 90 9 view .LVU30
 126 006a 81E0      		ldi r24,lo8(1)
 127               	/* epilogue start */
  91:avr_main.c    **** }
 128               		.loc 1 91 1 view .LVU31
 129 006c DF91      		pop r29
 130 006e CF91      		pop r28
 131               	.LVL8:
 132               		.loc 1 91 1 view .LVU32
 133 0070 1F91      		pop r17
 134 0072 FF90      		pop r15
 135 0074 EF90      		pop r14
 136 0076 0895      		ret
 137               	.LVL9:
 138               	.L4:
  38:avr_main.c    **** 		goto BOTH_NEXT;
 139               		.loc 1 38 3 is_stmt 1 view .LVU33
 140 0078 E091 0000 		lds r30,request_both_write+1
 141 007c F091 0000 		lds r31,request_both_write+1+1
 142 0080 8091 0000 		lds r24,request_both_write+5
 143 0084 9091 0000 		lds r25,request_both_write+5+1
 144 0088 A901      		movw r20,r18
 145 008a BE01      		movw r22,r28
 146 008c 8E0F      		add r24,r30
 147 008e 9F1F      		adc r25,r31
 148 0090 0E94 0000 		call cpu_write_flash
 149               	.LVL10:
  39:avr_main.c    **** 	case REQUEST_PPU_WRITE:
 150               		.loc 1 39 3 view .LVU34
 151               	.L7:
 152               	.LBB7:
  44:avr_main.c    **** 		uchar ret = request_both_write.offset == request_both_write.length;
 153               		.loc 1 44 3 view .LVU35
  44:avr_main.c    **** 		uchar ret = request_both_write.offset == request_both_write.length;
 154               		.loc 1 44 29 is_stmt 0 view .LVU36
 155 0094 6091 0000 		lds r22,request_both_write+5
 156 0098 7091 0000 		lds r23,request_both_write+5+1
 157 009c C60F      		add r28,r22
 158 009e D71F      		adc r29,r23
 159               	.LVL11:
  44:avr_main.c    **** 		uchar ret = request_both_write.offset == request_both_write.length;
 160               		.loc 1 44 29 view .LVU37
 161 00a0 D093 0000 		sts request_both_write+5+1,r29
 162 00a4 C093 0000 		sts request_both_write+5,r28
  45:avr_main.c    **** 		if(ret){
 163               		.loc 1 45 3 is_stmt 1 view .LVU38
 164               	.LVL12:
  46:avr_main.c    **** 			request_both_write.request = REQUEST_NOP;
 165               		.loc 1 46 3 view .LVU39
  46:avr_main.c    **** 			request_both_write.request = REQUEST_NOP;
 166               		.loc 1 46 5 is_stmt 0 view .LVU40
 167 00a8 8091 0000 		lds r24,request_both_write+3
 168 00ac 9091 0000 		lds r25,request_both_write+3+1
 169 00b0 C817      		cp r28,r24
 170 00b2 D907      		cpc r29,r25
 171 00b4 01F0      		breq .L26
 172               	.LVL13:
 173               	.L17:
  46:avr_main.c    **** 			request_both_write.request = REQUEST_NOP;
 174               		.loc 1 46 5 view .LVU41
 175               	.LBE7:
 176               	.LBB8:
  86:avr_main.c    **** 	default:
 177               		.loc 1 86 10 view .LVU42
 178 00b6 80E0      		ldi r24,0
 179               	.L1:
 180               	/* epilogue start */
 181               	.LBE8:
 182               		.loc 1 91 1 view .LVU43
 183 00b8 DF91      		pop r29
 184 00ba CF91      		pop r28
 185 00bc 1F91      		pop r17
 186 00be FF90      		pop r15
 187 00c0 EF90      		pop r14
 188 00c2 0895      		ret
 189               	.LVL14:
 190               	.L26:
 191               	.LBB9:
  47:avr_main.c    **** 		}
 192               		.loc 1 47 4 is_stmt 1 view .LVU44
  47:avr_main.c    **** 		}
 193               		.loc 1 47 31 is_stmt 0 view .LVU45
 194 00c4 8EEE      		ldi r24,lo8(-18)
 195               	.LVL15:
  47:avr_main.c    **** 		}
 196               		.loc 1 47 31 view .LVU46
 197 00c6 8093 0000 		sts request_both_write,r24
  49:avr_main.c    **** 		}
 198               		.loc 1 49 10 view .LVU47
 199 00ca 81E0      		ldi r24,lo8(1)
 200               	/* epilogue start */
 201               	.LBE9:
 202               		.loc 1 91 1 view .LVU48
 203 00cc DF91      		pop r29
 204 00ce CF91      		pop r28
 205               	.LVL16:
 206               		.loc 1 91 1 view .LVU49
 207 00d0 1F91      		pop r17
 208 00d2 FF90      		pop r15
 209 00d4 EF90      		pop r14
 210 00d6 0895      		ret
 211               	.LVL17:
 212               	.L23:
  35:avr_main.c    **** 		goto BOTH_NEXT;
 213               		.loc 1 35 3 is_stmt 1 view .LVU50
 214 00d8 E091 0000 		lds r30,request_both_write+1
 215 00dc F091 0000 		lds r31,request_both_write+1+1
 216 00e0 8091 0000 		lds r24,request_both_write+5
 217 00e4 9091 0000 		lds r25,request_both_write+5+1
 218 00e8 A901      		movw r20,r18
 219 00ea BE01      		movw r22,r28
 220 00ec 8E0F      		add r24,r30
 221 00ee 9F1F      		adc r25,r31
 222 00f0 0E94 0000 		call cpu_write_6502
 223               	.LVL18:
  36:avr_main.c    **** 	case REQUEST_CPU_WRITE_FLASH:
 224               		.loc 1 36 3 view .LVU51
 225 00f4 00C0      		rjmp .L7
 226               	.LVL19:
 227               	.L5:
  41:avr_main.c    **** 		goto BOTH_NEXT;
 228               		.loc 1 41 3 view .LVU52
 229 00f6 E091 0000 		lds r30,request_both_write+1
 230 00fa F091 0000 		lds r31,request_both_write+1+1
 231 00fe 8091 0000 		lds r24,request_both_write+5
 232 0102 9091 0000 		lds r25,request_both_write+5+1
 233 0106 A901      		movw r20,r18
 234 0108 BE01      		movw r22,r28
 235 010a 8E0F      		add r24,r30
 236 010c 9F1F      		adc r25,r31
 237 010e 0E94 0000 		call ppu_write
 238               	.LVL20:
  42:avr_main.c    **** 	BOTH_NEXT:{
 239               		.loc 1 42 3 view .LVU53
 240 0112 00C0      		rjmp .L7
 241               	.LVL21:
 242               	.L24:
 243               	.LBB10:
  57:avr_main.c    **** 		request_cpu_program.offset += length;
 244               		.loc 1 57 3 view .LVU54
  57:avr_main.c    **** 		request_cpu_program.offset += length;
 245               		.loc 1 57 42 is_stmt 0 view .LVU55
 246 0114 E090 0000 		lds r14,request_cpu_program+5
 247 0118 F090 0000 		lds r15,request_cpu_program+5+1
  57:avr_main.c    **** 		request_cpu_program.offset += length;
 248               		.loc 1 57 3 view .LVU56
 249 011c AE01      		movw r20,r28
 250 011e B901      		movw r22,r18
 251 0120 C701      		movw r24,r14
 252 0122 8050      		subi r24,lo8(-(cpu_buffer.2108))
 253 0124 9040      		sbci r25,hi8(-(cpu_buffer.2108))
 254 0126 0E94 0000 		call memcpy
 255               	.LVL22:
  58:avr_main.c    **** 		uchar ret = request_cpu_program.offset == request_cpu_program.length;
 256               		.loc 1 58 3 is_stmt 1 view .LVU57
  58:avr_main.c    **** 		uchar ret = request_cpu_program.offset == request_cpu_program.length;
 257               		.loc 1 58 30 is_stmt 0 view .LVU58
 258 012a CE0D      		add r28,r14
 259 012c DF1D      		adc r29,r15
 260               	.LVL23:
  58:avr_main.c    **** 		uchar ret = request_cpu_program.offset == request_cpu_program.length;
 261               		.loc 1 58 30 view .LVU59
 262 012e D093 0000 		sts request_cpu_program+5+1,r29
 263 0132 C093 0000 		sts request_cpu_program+5,r28
  59:avr_main.c    **** 		if(ret){
 264               		.loc 1 59 3 is_stmt 1 view .LVU60
  59:avr_main.c    **** 		if(ret){
 265               		.loc 1 59 64 is_stmt 0 view .LVU61
 266 0136 8091 0000 		lds r24,request_cpu_program+3
 267 013a 9091 0000 		lds r25,request_cpu_program+3+1
 268               	.LVL24:
  60:avr_main.c    **** 			if(request_cpu_program.request == REQUEST_FLASH_CONFIG_SET){
 269               		.loc 1 60 3 is_stmt 1 view .LVU62
  60:avr_main.c    **** 			if(request_cpu_program.request == REQUEST_FLASH_CONFIG_SET){
 270               		.loc 1 60 5 is_stmt 0 view .LVU63
 271 013e C817      		cp r28,r24
 272 0140 D907      		cpc r29,r25
 273 0142 01F0      		breq .+2
 274 0144 00C0      		rjmp .L17
  61:avr_main.c    **** 				flash_cpu_config(cpu_buffer, request_cpu_program.length);
 275               		.loc 1 61 4 is_stmt 1 view .LVU64
  61:avr_main.c    **** 				flash_cpu_config(cpu_buffer, request_cpu_program.length);
 276               		.loc 1 61 6 is_stmt 0 view .LVU65
 277 0146 1930      		cpi r17,lo8(9)
 278 0148 01F0      		breq .L27
  64:avr_main.c    **** 			}
 279               		.loc 1 64 5 is_stmt 1 view .LVU66
 280 014a 40E0      		ldi r20,lo8(cpu_buffer.2108)
 281 014c 50E0      		ldi r21,hi8(cpu_buffer.2108)
 282 014e BE01      		movw r22,r28
 283 0150 8091 0000 		lds r24,request_cpu_program+1
 284 0154 9091 0000 		lds r25,request_cpu_program+1+1
 285               	.LVL25:
  64:avr_main.c    **** 			}
 286               		.loc 1 64 5 is_stmt 0 view .LVU67
 287 0158 0E94 0000 		call flash_cpu_program
 288               	.LVL26:
 289               	.L11:
  66:avr_main.c    **** 		}
 290               		.loc 1 66 4 is_stmt 1 view .LVU68
  66:avr_main.c    **** 		}
 291               		.loc 1 66 32 is_stmt 0 view .LVU69
 292 015c 8EEE      		ldi r24,lo8(-18)
 293 015e 8093 0000 		sts request_cpu_program,r24
  68:avr_main.c    **** 	default:
 294               		.loc 1 68 10 view .LVU70
 295 0162 81E0      		ldi r24,lo8(1)
 296 0164 00C0      		rjmp .L1
 297               	.LVL27:
 298               	.L25:
  68:avr_main.c    **** 	default:
 299               		.loc 1 68 10 view .LVU71
 300               	.LBE10:
 301               	.LBB11:
  75:avr_main.c    **** 		request_ppu_program.offset += length;
 302               		.loc 1 75 3 is_stmt 1 view .LVU72
  75:avr_main.c    **** 		request_ppu_program.offset += length;
 303               		.loc 1 75 42 is_stmt 0 view .LVU73
 304 0166 E090 0000 		lds r14,request_ppu_program+5
 305 016a F090 0000 		lds r15,request_ppu_program+5+1
  75:avr_main.c    **** 		request_ppu_program.offset += length;
 306               		.loc 1 75 3 view .LVU74
 307 016e AE01      		movw r20,r28
 308 0170 B901      		movw r22,r18
 309 0172 C701      		movw r24,r14
 310 0174 8050      		subi r24,lo8(-(ppu_buffer.2109))
 311 0176 9040      		sbci r25,hi8(-(ppu_buffer.2109))
 312 0178 0E94 0000 		call memcpy
 313               	.LVL28:
  76:avr_main.c    **** 		uchar ret = request_ppu_program.offset == request_ppu_program.length;
 314               		.loc 1 76 3 is_stmt 1 view .LVU75
  76:avr_main.c    **** 		uchar ret = request_ppu_program.offset == request_ppu_program.length;
 315               		.loc 1 76 30 is_stmt 0 view .LVU76
 316 017c CE0D      		add r28,r14
 317 017e DF1D      		adc r29,r15
 318               	.LVL29:
  76:avr_main.c    **** 		uchar ret = request_ppu_program.offset == request_ppu_program.length;
 319               		.loc 1 76 30 view .LVU77
 320 0180 D093 0000 		sts request_ppu_program+5+1,r29
 321 0184 C093 0000 		sts request_ppu_program+5,r28
  77:avr_main.c    **** 		if(ret){
 322               		.loc 1 77 3 is_stmt 1 view .LVU78
  77:avr_main.c    **** 		if(ret){
 323               		.loc 1 77 64 is_stmt 0 view .LVU79
 324 0188 8091 0000 		lds r24,request_ppu_program+3
 325 018c 9091 0000 		lds r25,request_ppu_program+3+1
 326               	.LVL30:
  78:avr_main.c    **** 			if(request_ppu_program.request == REQUEST_FLASH_CONFIG_SET){
 327               		.loc 1 78 3 is_stmt 1 view .LVU80
  78:avr_main.c    **** 			if(request_ppu_program.request == REQUEST_FLASH_CONFIG_SET){
 328               		.loc 1 78 5 is_stmt 0 view .LVU81
 329 0190 C817      		cp r28,r24
 330 0192 D907      		cpc r29,r25
 331 0194 01F0      		breq .+2
 332 0196 00C0      		rjmp .L17
  79:avr_main.c    **** 				flash_ppu_config(ppu_buffer, request_cpu_program.length);
 333               		.loc 1 79 4 is_stmt 1 view .LVU82
  79:avr_main.c    **** 				flash_ppu_config(ppu_buffer, request_cpu_program.length);
 334               		.loc 1 79 6 is_stmt 0 view .LVU83
 335 0198 1930      		cpi r17,lo8(9)
 336 019a 01F0      		breq .L28
  82:avr_main.c    **** 			}
 337               		.loc 1 82 5 is_stmt 1 view .LVU84
 338 019c 40E0      		ldi r20,lo8(ppu_buffer.2109)
 339 019e 50E0      		ldi r21,hi8(ppu_buffer.2109)
 340 01a0 BE01      		movw r22,r28
 341 01a2 8091 0000 		lds r24,request_ppu_program+1
 342 01a6 9091 0000 		lds r25,request_ppu_program+1+1
 343               	.LVL31:
  82:avr_main.c    **** 			}
 344               		.loc 1 82 5 is_stmt 0 view .LVU85
 345 01aa 0E94 0000 		call flash_ppu_program
 346               	.LVL32:
 347               	.L13:
  84:avr_main.c    **** 		}
 348               		.loc 1 84 4 is_stmt 1 view .LVU86
  84:avr_main.c    **** 		}
 349               		.loc 1 84 32 is_stmt 0 view .LVU87
 350 01ae 8EEE      		ldi r24,lo8(-18)
 351 01b0 8093 0000 		sts request_ppu_program,r24
  86:avr_main.c    **** 	default:
 352               		.loc 1 86 10 view .LVU88
 353 01b4 81E0      		ldi r24,lo8(1)
 354 01b6 00C0      		rjmp .L1
 355               	.LVL33:
 356               	.L27:
  86:avr_main.c    **** 	default:
 357               		.loc 1 86 10 view .LVU89
 358               	.LBE11:
 359               	.LBB12:
  62:avr_main.c    **** 			}else{
 360               		.loc 1 62 5 is_stmt 1 view .LVU90
 361 01b8 BE01      		movw r22,r28
 362 01ba 80E0      		ldi r24,lo8(cpu_buffer.2108)
 363 01bc 90E0      		ldi r25,hi8(cpu_buffer.2108)
 364               	.LVL34:
  62:avr_main.c    **** 			}else{
 365               		.loc 1 62 5 is_stmt 0 view .LVU91
 366 01be 0E94 0000 		call flash_cpu_config
 367               	.LVL35:
  62:avr_main.c    **** 			}else{
 368               		.loc 1 62 5 view .LVU92
 369 01c2 00C0      		rjmp .L11
 370               	.LVL36:
 371               	.L28:
  62:avr_main.c    **** 			}else{
 372               		.loc 1 62 5 view .LVU93
 373               	.LBE12:
 374               	.LBB13:
  80:avr_main.c    **** 			}else{
 375               		.loc 1 80 5 is_stmt 1 view .LVU94
 376 01c4 6091 0000 		lds r22,request_cpu_program+3
 377 01c8 7091 0000 		lds r23,request_cpu_program+3+1
 378 01cc 80E0      		ldi r24,lo8(ppu_buffer.2109)
 379 01ce 90E0      		ldi r25,hi8(ppu_buffer.2109)
 380               	.LVL37:
  80:avr_main.c    **** 			}else{
 381               		.loc 1 80 5 is_stmt 0 view .LVU95
 382 01d0 0E94 0000 		call flash_ppu_config
 383               	.LVL38:
  80:avr_main.c    **** 			}else{
 384               		.loc 1 80 5 view .LVU96
 385 01d4 00C0      		rjmp .L13
 386               	.LBE13:
 387               		.cfi_endproc
 388               	.LFE10:
 390               	.global	usbFunctionSetup
 392               	usbFunctionSetup:
 393               	.LVL39:
 394               	.LFB11:
  92:avr_main.c    **** 
  93:avr_main.c    **** //static uint8_t readbuffer[READ_PACKET_SIZE];
  94:avr_main.c    **** usbMsgLen_t usbFunctionSetup(uchar d[8])
  95:avr_main.c    **** {
 395               		.loc 1 95 1 is_stmt 1 view -0
 396               		.cfi_startproc
 397               		.loc 1 95 1 is_stmt 0 view .LVU98
 398 01d6 EF92      		push r14
 399               	.LCFI5:
 400               		.cfi_def_cfa_offset 3
 401               		.cfi_offset 14, -2
 402 01d8 FF92      		push r15
 403               	.LCFI6:
 404               		.cfi_def_cfa_offset 4
 405               		.cfi_offset 15, -3
 406 01da 0F93      		push r16
 407               	.LCFI7:
 408               		.cfi_def_cfa_offset 5
 409               		.cfi_offset 16, -4
 410 01dc 1F93      		push r17
 411               	.LCFI8:
 412               		.cfi_def_cfa_offset 6
 413               		.cfi_offset 17, -5
 414 01de CF93      		push r28
 415               	.LCFI9:
 416               		.cfi_def_cfa_offset 7
 417               		.cfi_offset 28, -6
 418 01e0 DF93      		push r29
 419               	.LCFI10:
 420               		.cfi_def_cfa_offset 8
 421               		.cfi_offset 29, -7
 422 01e2 00D0      		rcall .
 423               	.LCFI11:
 424               		.cfi_def_cfa_offset 10
 425 01e4 CDB7      		in r28,__SP_L__
 426 01e6 DEB7      		in r29,__SP_H__
 427               	.LCFI12:
 428               		.cfi_def_cfa_register 28
 429               	/* prologue: function */
 430               	/* frame size = 2 */
 431               	/* stack size = 8 */
 432               	.L__stack_usage = 8
 433 01e8 8C01      		movw r16,r24
  96:avr_main.c    **** 	static uint8_t readbuffer[READ_PACKET_SIZE];
 434               		.loc 1 96 2 is_stmt 1 view .LVU99
  97:avr_main.c    **** 	static uint8_t status[2];
 435               		.loc 1 97 2 view .LVU100
  98:avr_main.c    **** 	usbRequest_t *rq = (void *)d;
 436               		.loc 1 98 2 view .LVU101
 437               	.LVL40:
  99:avr_main.c    **** 	struct write_command *write_command;
 438               		.loc 1 99 2 view .LVU102
 100:avr_main.c    **** 
 101:avr_main.c    **** 	switch((enum request) rq->bRequest){
 439               		.loc 1 101 2 view .LVU103
 440               		.loc 1 101 26 is_stmt 0 view .LVU104
 441 01ea DC01      		movw r26,r24
 442 01ec 1196      		adiw r26,1
 443 01ee 8C91      		ld r24,X
 444 01f0 1197      		sbiw r26,1
 445               	.LVL41:
 446               		.loc 1 101 26 view .LVU105
 447 01f2 8338      		cpi r24,lo8(-125)
 448 01f4 00F0      		brlo .+2
 449 01f6 00C0      		rjmp .L60
 450 01f8 E82F      		mov r30,r24
 451 01fa F0E0      		ldi r31,0
 452 01fc E050      		subi r30,lo8(-(gs(.L32)))
 453 01fe F040      		sbci r31,hi8(-(gs(.L32)))
 454 0200 0C94 0000 		jmp __tablejump2__
 455               		.section	.jumptables.gcc.usbFunctionSetup,"a",@progbits
 456               		.p2align	1
 457               	.L32:
 458 0000 0000      		.word gs(.L47)
 459 0002 0000      		.word gs(.L46)
 460 0004 0000      		.word gs(.L45)
 461 0006 0000      		.word gs(.L44)
 462 0008 0000      		.word gs(.L61)
 463 000a 0000      		.word gs(.L61)
 464 000c 0000      		.word gs(.L43)
 465 000e 0000      		.word gs(.L61)
 466 0010 0000      		.word gs(.L41)
 467 0012 0000      		.word gs(.L40)
 468 0014 0000      		.word gs(.L40)
 469 0016 0000      		.word gs(.L39)
 470 0018 0000      		.word gs(.L38)
 471 001a 0000      		.word gs(.L37)
 472 001c 0000      		.word gs(.L60)
 473 001e 0000      		.word gs(.L36)
 474 0020 0000      		.word gs(.L35)
 475 0022 0000      		.word gs(.L60)
 476 0024 0000      		.word gs(.L60)
 477 0026 0000      		.word gs(.L60)
 478 0028 0000      		.word gs(.L60)
 479 002a 0000      		.word gs(.L60)
 480 002c 0000      		.word gs(.L60)
 481 002e 0000      		.word gs(.L60)
 482 0030 0000      		.word gs(.L60)
 483 0032 0000      		.word gs(.L60)
 484 0034 0000      		.word gs(.L60)
 485 0036 0000      		.word gs(.L60)
 486 0038 0000      		.word gs(.L60)
 487 003a 0000      		.word gs(.L60)
 488 003c 0000      		.word gs(.L60)
 489 003e 0000      		.word gs(.L60)
 490 0040 0000      		.word gs(.L60)
 491 0042 0000      		.word gs(.L60)
 492 0044 0000      		.word gs(.L60)
 493 0046 0000      		.word gs(.L60)
 494 0048 0000      		.word gs(.L60)
 495 004a 0000      		.word gs(.L60)
 496 004c 0000      		.word gs(.L60)
 497 004e 0000      		.word gs(.L60)
 498 0050 0000      		.word gs(.L60)
 499 0052 0000      		.word gs(.L60)
 500 0054 0000      		.word gs(.L60)
 501 0056 0000      		.word gs(.L60)
 502 0058 0000      		.word gs(.L60)
 503 005a 0000      		.word gs(.L60)
 504 005c 0000      		.word gs(.L60)
 505 005e 0000      		.word gs(.L60)
 506 0060 0000      		.word gs(.L60)
 507 0062 0000      		.word gs(.L60)
 508 0064 0000      		.word gs(.L60)
 509 0066 0000      		.word gs(.L60)
 510 0068 0000      		.word gs(.L60)
 511 006a 0000      		.word gs(.L60)
 512 006c 0000      		.word gs(.L60)
 513 006e 0000      		.word gs(.L60)
 514 0070 0000      		.word gs(.L60)
 515 0072 0000      		.word gs(.L60)
 516 0074 0000      		.word gs(.L60)
 517 0076 0000      		.word gs(.L60)
 518 0078 0000      		.word gs(.L60)
 519 007a 0000      		.word gs(.L60)
 520 007c 0000      		.word gs(.L60)
 521 007e 0000      		.word gs(.L60)
 522 0080 0000      		.word gs(.L60)
 523 0082 0000      		.word gs(.L60)
 524 0084 0000      		.word gs(.L60)
 525 0086 0000      		.word gs(.L60)
 526 0088 0000      		.word gs(.L60)
 527 008a 0000      		.word gs(.L60)
 528 008c 0000      		.word gs(.L60)
 529 008e 0000      		.word gs(.L60)
 530 0090 0000      		.word gs(.L60)
 531 0092 0000      		.word gs(.L60)
 532 0094 0000      		.word gs(.L60)
 533 0096 0000      		.word gs(.L60)
 534 0098 0000      		.word gs(.L60)
 535 009a 0000      		.word gs(.L60)
 536 009c 0000      		.word gs(.L60)
 537 009e 0000      		.word gs(.L60)
 538 00a0 0000      		.word gs(.L60)
 539 00a2 0000      		.word gs(.L60)
 540 00a4 0000      		.word gs(.L60)
 541 00a6 0000      		.word gs(.L60)
 542 00a8 0000      		.word gs(.L60)
 543 00aa 0000      		.word gs(.L60)
 544 00ac 0000      		.word gs(.L60)
 545 00ae 0000      		.word gs(.L60)
 546 00b0 0000      		.word gs(.L60)
 547 00b2 0000      		.word gs(.L60)
 548 00b4 0000      		.word gs(.L60)
 549 00b6 0000      		.word gs(.L60)
 550 00b8 0000      		.word gs(.L60)
 551 00ba 0000      		.word gs(.L60)
 552 00bc 0000      		.word gs(.L60)
 553 00be 0000      		.word gs(.L60)
 554 00c0 0000      		.word gs(.L60)
 555 00c2 0000      		.word gs(.L60)
 556 00c4 0000      		.word gs(.L60)
 557 00c6 0000      		.word gs(.L60)
 558 00c8 0000      		.word gs(.L60)
 559 00ca 0000      		.word gs(.L60)
 560 00cc 0000      		.word gs(.L60)
 561 00ce 0000      		.word gs(.L60)
 562 00d0 0000      		.word gs(.L60)
 563 00d2 0000      		.word gs(.L60)
 564 00d4 0000      		.word gs(.L60)
 565 00d6 0000      		.word gs(.L60)
 566 00d8 0000      		.word gs(.L60)
 567 00da 0000      		.word gs(.L60)
 568 00dc 0000      		.word gs(.L60)
 569 00de 0000      		.word gs(.L60)
 570 00e0 0000      		.word gs(.L60)
 571 00e2 0000      		.word gs(.L60)
 572 00e4 0000      		.word gs(.L60)
 573 00e6 0000      		.word gs(.L60)
 574 00e8 0000      		.word gs(.L60)
 575 00ea 0000      		.word gs(.L60)
 576 00ec 0000      		.word gs(.L60)
 577 00ee 0000      		.word gs(.L60)
 578 00f0 0000      		.word gs(.L60)
 579 00f2 0000      		.word gs(.L60)
 580 00f4 0000      		.word gs(.L60)
 581 00f6 0000      		.word gs(.L60)
 582 00f8 0000      		.word gs(.L60)
 583 00fa 0000      		.word gs(.L60)
 584 00fc 0000      		.word gs(.L60)
 585 00fe 0000      		.word gs(.L60)
 586 0100 0000      		.word gs(.L34)
 587 0102 0000      		.word gs(.L33)
 588 0104 0000      		.word gs(.L31)
 589               		.text
 590               	.L33:
 591               	.LBB14:
 102:avr_main.c    **** 	case REQUEST_ECHO:
 103:avr_main.c    **** 		readbuffer[0] = rq->wValue.bytes[0];
 104:avr_main.c    **** 		readbuffer[1] = rq->wValue.bytes[1];
 105:avr_main.c    **** 		readbuffer[2] = rq->wIndex.bytes[0];
 106:avr_main.c    **** 		readbuffer[3] = rq->wIndex.bytes[1];
 107:avr_main.c    **** 		usbMsgPtr = readbuffer;
 108:avr_main.c    **** 		return 4;
 109:avr_main.c    **** 	case REQUEST_PHI2_INIT:
 110:avr_main.c    **** 		flash_both_idle();
 111:avr_main.c    **** 		phi2_init();
 112:avr_main.c    **** 		return 0;
 113:avr_main.c    **** 	case REQUEST_CPU_READ:
 114:avr_main.c    **** 		cpu_read(rq->wValue.word, rq->wLength.word, readbuffer);
 115:avr_main.c    **** 		goto xxx_read;
 116:avr_main.c    **** 	case REQUEST_CPU_READ_6502:
 117:avr_main.c    **** 		cpu_read_6502(rq->wValue.word, rq->wLength.word, readbuffer);
 118:avr_main.c    **** 		goto xxx_read;
 119:avr_main.c    **** 	case REQUEST_PPU_READ:
 120:avr_main.c    **** 		ppu_read(rq->wValue.word, rq->wLength.word, readbuffer);
 121:avr_main.c    **** 		goto xxx_read;
 122:avr_main.c    **** 	case REQUEST_CPU_WRITE_6502: case REQUEST_CPU_WRITE_FLASH:
 123:avr_main.c    **** 	case REQUEST_PPU_WRITE:
 124:avr_main.c    **** 		write_command = &request_both_write;
 125:avr_main.c    **** 		goto xxx_write;
 126:avr_main.c    **** 	case REQUEST_FLASH_PROGRAM:
 127:avr_main.c    **** 	case REQUEST_FLASH_CONFIG_SET:
 128:avr_main.c    **** 		if(rq->wIndex.word == INDEX_CPU){
 129:avr_main.c    **** 			write_command = &request_cpu_program;
 130:avr_main.c    **** 		}else{
 131:avr_main.c    **** 			write_command = &request_ppu_program;
 132:avr_main.c    **** 		}
 133:avr_main.c    **** 		goto xxx_write;
 134:avr_main.c    **** 	xxx_write:
 135:avr_main.c    **** 		write_command->request = rq->bRequest;
 136:avr_main.c    **** 		write_command->length = rq->wLength.word;
 137:avr_main.c    **** 		write_command->address = rq->wValue.word;
 138:avr_main.c    **** 		write_command->offset = 0;
 139:avr_main.c    **** 		return USB_NO_MSG; //goto usbFunctionWrite
 140:avr_main.c    **** /*	case REQUEST_FLASH_BUFFER_GET:
 141:avr_main.c    **** 		if(rq->wIndex.word == INDEX_CPU){
 142:avr_main.c    **** 			usbMsgPtr = cpu_buffer;
 143:avr_main.c    **** 		}else{
 144:avr_main.c    **** 			usbMsgPtr = ppu_buffer;
 145:avr_main.c    **** 		}
 146:avr_main.c    **** 		return FLASH_PACKET_SIZE;*/
 147:avr_main.c    **** 	case REQUEST_DISK_STATUS_GET:
 148:avr_main.c    **** 		//usbMsgPtr = status;
 149:avr_main.c    **** 		return 0; //disk_status_get(status);
 150:avr_main.c    **** 	case REQUEST_DISK_READ: 
 151:avr_main.c    **** 		disk_init(DISK_READ);
 152:avr_main.c    **** 		return 0;
 153:avr_main.c    **** 	case REQUEST_DISK_WRITE:
 154:avr_main.c    **** 		disk_init(DISK_WRITE);
 155:avr_main.c    **** 		return 0;
 156:avr_main.c    **** 	case REQUEST_FLASH_STATUS:
 157:avr_main.c    **** 		usbMsgPtr = status;
 158:avr_main.c    **** 		switch((enum index) rq->wIndex.word){
 159:avr_main.c    **** 		case INDEX_CPU:
 160:avr_main.c    **** 			status[0] = flash_cpu_status();
 161:avr_main.c    **** 			return 1;
 162:avr_main.c    **** 		case INDEX_PPU:
 163:avr_main.c    **** 			status[0] = flash_ppu_status();
 164:avr_main.c    **** 			return 1;
 165:avr_main.c    **** 		default:
 166:avr_main.c    **** 			status[0] = flash_cpu_status();
 167:avr_main.c    **** 			status[1] = flash_ppu_status();
 168:avr_main.c    **** 			return 2;
 169:avr_main.c    **** 		}
 170:avr_main.c    **** 		return 1;
 171:avr_main.c    **** 	case REQUEST_FLASH_DEVICE:
 172:avr_main.c    **** 		if(rq->wIndex.word == INDEX_CPU){
 173:avr_main.c    **** 			flash_cpu_device_get(status);
 174:avr_main.c    **** 		}else{
 175:avr_main.c    **** 			flash_ppu_device_get(status);
 176:avr_main.c    **** 		}
 177:avr_main.c    **** 		usbMsgPtr = status;
 178:avr_main.c    **** 		return 2;
 179:avr_main.c    **** 	case REQUEST_FLASH_ERASE:
 180:avr_main.c    **** 		if(rq->wIndex.word == INDEX_CPU){
 181:avr_main.c    **** 			flash_cpu_erase(rq->wValue.word);
 182:avr_main.c    **** 		}else{
 183:avr_main.c    **** 			flash_ppu_erase(rq->wValue.word);
 184:avr_main.c    **** 		}
 185:avr_main.c    **** 		return 0;
 186:avr_main.c    **** 	case REQUEST_VRAM_CONNECTION:
 187:avr_main.c    **** 		status[0] = vram_connection_get();
 188:avr_main.c    **** 		usbMsgPtr = status;
 189:avr_main.c    **** 		return 1;
 190:avr_main.c    **** 	case REQUEST_FIRMWARE_VERSION:{
 191:avr_main.c    **** 		__attribute__ ((section(".firmware.version")))
 192:avr_main.c    **** 		static const /*PROGMEM*/ char date[VERSION_STRING_SIZE] = 
 193:avr_main.c    **** #if PCB_REVISION == 1
 194:avr_main.c    **** 		"kazzo16"
 195:avr_main.c    **** #endif
 196:avr_main.c    **** #if PCB_REVISION == 2
 197:avr_main.c    **** 		"kazzo^8"
 198:avr_main.c    **** #endif
 199:avr_main.c    **** 		" 0.1.3 / " __DATE__;
 200:avr_main.c    **** 		memcpy_P(readbuffer, date, rq->wLength.word);
 201:avr_main.c    **** 		goto xxx_read;}
 202:avr_main.c    **** 	case REQUEST_FIRMWARE_PROGRAM:{
 203:avr_main.c    **** 		void (*t)(uint8_t *buf, uint16_t address, uint16_t length);
 592               		.loc 1 203 3 is_stmt 1 view .LVU106
 204:avr_main.c    **** #if PCB_REVISION == 1
 205:avr_main.c    **** 		static const char signature[] = {'k', 'a', 'z', 'z', 'o', '1', '6'};
 593               		.loc 1 205 3 view .LVU107
 206:avr_main.c    **** #endif
 207:avr_main.c    **** #if PCB_REVISION == 2
 208:avr_main.c    **** 		static const char signature[] = {'k', 'a', 'z', 'z', 'o', '^', '8'};
 209:avr_main.c    **** #endif
 210:avr_main.c    **** 		const uint16_t address = rq->wValue.word;
 594               		.loc 1 210 3 view .LVU108
 595               		.loc 1 210 18 is_stmt 0 view .LVU109
 596 0204 F801      		movw r30,r16
 597 0206 E280      		ldd r14,Z+2
 598 0208 F380      		ldd r15,Z+3
 599               	.LVL42:
 211:avr_main.c    **** 		const uint16_t length = rq->wIndex.word;
 600               		.loc 1 211 3 is_stmt 1 view .LVU110
 212:avr_main.c    **** 		if(address >= 0x3800){
 601               		.loc 1 212 3 view .LVU111
 602               		.loc 1 212 5 is_stmt 0 view .LVU112
 603 020a E114      		cp r14,__zero_reg__
 604 020c F8E3      		ldi r31,56
 605 020e FF06      		cpc r15,r31
 606 0210 00F4      		brsh .L60
 211:avr_main.c    **** 		const uint16_t length = rq->wIndex.word;
 607               		.loc 1 211 18 view .LVU113
 608 0212 1496      		adiw r26,4
 609 0214 0D91      		ld r16,X+
 610 0216 1C91      		ld r17,X
 611               	.LVL43:
 213:avr_main.c    **** 			return 0;
 214:avr_main.c    **** 		}
 215:avr_main.c    **** 		if(((address & 0x3f00) == 0) && (length < 0x1800)){
 612               		.loc 1 215 3 is_stmt 1 view .LVU114
 613               		.loc 1 215 16 is_stmt 0 view .LVU115
 614 0218 C701      		movw r24,r14
 615 021a 8827      		clr r24
 616 021c 9F73      		andi r25,63
 617               		.loc 1 215 5 view .LVU116
 618 021e 892B      		or r24,r25
 619 0220 01F4      		brne .L56
 620               		.loc 1 215 32 discriminator 1 view .LVU117
 621 0222 0115      		cp r16,__zero_reg__
 622 0224 B8E1      		ldi r27,24
 623 0226 1B07      		cpc r17,r27
 624 0228 00F0      		brlo .L60
 625               	.L56:
 216:avr_main.c    **** 			return 0;
 217:avr_main.c    **** 		}
 218:avr_main.c    **** 		if(length + address > 0x3800){
 626               		.loc 1 218 3 is_stmt 1 view .LVU118
 627               		.loc 1 218 13 is_stmt 0 view .LVU119
 628 022a C701      		movw r24,r14
 629 022c 800F      		add r24,r16
 630 022e 911F      		adc r25,r17
 631               		.loc 1 218 5 view .LVU120
 632 0230 8130      		cpi r24,1
 633 0232 9843      		sbci r25,56
 634 0234 00F4      		brsh .L60
 219:avr_main.c    **** 			return 0;
 220:avr_main.c    **** 		}
 221:avr_main.c    **** 		cpu_read(0x3780 - 0x2000 + 0x6000, sizeof(signature), readbuffer);
 635               		.loc 1 221 3 is_stmt 1 view .LVU121
 636 0236 40E0      		ldi r20,lo8(readbuffer.2135)
 637 0238 50E0      		ldi r21,hi8(readbuffer.2135)
 638 023a 67E0      		ldi r22,lo8(7)
 639 023c 70E0      		ldi r23,0
 640 023e 80E8      		ldi r24,lo8(-128)
 641 0240 97E7      		ldi r25,lo8(119)
 642 0242 0E94 0000 		call cpu_read
 643               	.LVL44:
 222:avr_main.c    **** 		if(memcmp(readbuffer, signature, sizeof(signature)) == 0){
 644               		.loc 1 222 3 view .LVU122
 645               		.loc 1 222 6 is_stmt 0 view .LVU123
 646 0246 2091 0000 		lds r18,readbuffer.2135
 647 024a 3091 0000 		lds r19,readbuffer.2135+1
 648 024e 8091 0000 		lds r24,signature.2168
 649 0252 9091 0000 		lds r25,signature.2168+1
 650 0256 2817      		cp r18,r24
 651 0258 3907      		cpc r19,r25
 652 025a 01F4      		brne .+2
 653 025c 00C0      		rjmp .L64
 654               	.L57:
 655 025e 81E0      		ldi r24,lo8(1)
 656 0260 90E0      		ldi r25,0
 657               	.L58:
 658               		.loc 1 222 5 view .LVU124
 659 0262 892B      		or r24,r25
 660 0264 01F4      		brne .L60
 223:avr_main.c    **** 			usbDeviceDisconnect();
 661               		.loc 1 223 4 is_stmt 1 view .LVU125
 662 0266 8C9A      		sbi 0x11,4
 224:avr_main.c    **** 			memcpy_P(&t, &BOOTLOADER_ASSIGN.programmer, sizeof(BOOTLOADER_ASSIGN.programmer));
 663               		.loc 1 224 4 view .LVU126
 664 0268 42E0      		ldi r20,lo8(2)
 665 026a 50E0      		ldi r21,0
 666 026c 60E0      		ldi r22,lo8(BOOTLOADER_ASSIGN+32)
 667 026e 70E0      		ldi r23,hi8(BOOTLOADER_ASSIGN+32)
 668 0270 CE01      		movw r24,r28
 669 0272 0196      		adiw r24,1
 670 0274 0E94 0000 		call memcpy_P
 671               	.LVL45:
 225:avr_main.c    **** 			(*t)(readbuffer, address, length);
 672               		.loc 1 225 4 view .LVU127
 673               		.loc 1 225 5 is_stmt 0 view .LVU128
 674 0278 E981      		ldd r30,Y+1
 675 027a FA81      		ldd r31,Y+2
 676 027c A801      		movw r20,r16
 677 027e B701      		movw r22,r14
 678 0280 80E0      		ldi r24,lo8(readbuffer.2135)
 679 0282 90E0      		ldi r25,hi8(readbuffer.2135)
 680 0284 0995      		icall
 681               	.LVL46:
 682               	.LBE14:
 226:avr_main.c    **** 		}
 227:avr_main.c    **** 		}return 0;
 683               		.loc 1 227 4 is_stmt 1 view .LVU129
 684               	.L60:
 101:avr_main.c    **** 	case REQUEST_ECHO:
 685               		.loc 1 101 26 is_stmt 0 view .LVU130
 686 0286 10E0      		ldi r17,0
 687 0288 00E0      		ldi r16,0
 688               	.L29:
 228:avr_main.c    **** 	case REQUEST_FIRMWARE_DOWNLOAD:{
 229:avr_main.c    **** 		const /*PROGMEM*/ uint8_t *firm = (const /*PROGMEM*/ uint8_t *) rq->wValue.word;
 230:avr_main.c    **** 		memcpy_P(readbuffer, firm, rq->wLength.word);
 231:avr_main.c    **** 		}
 232:avr_main.c    **** 		goto xxx_read;
 233:avr_main.c    **** 	xxx_read:
 234:avr_main.c    **** 		usbMsgPtr = readbuffer;
 235:avr_main.c    **** 		return rq->wLength.word;
 236:avr_main.c    **** 	}
 237:avr_main.c    **** 	return 0;
 238:avr_main.c    **** }
 689               		.loc 1 238 1 view .LVU131
 690 028a C801      		movw r24,r16
 691               	/* epilogue start */
 692 028c 0F90      		pop __tmp_reg__
 693 028e 0F90      		pop __tmp_reg__
 694 0290 DF91      		pop r29
 695 0292 CF91      		pop r28
 696 0294 1F91      		pop r17
 697 0296 0F91      		pop r16
 698 0298 FF90      		pop r15
 699 029a EF90      		pop r14
 700 029c 0895      		ret
 701               	.LVL47:
 702               	.L40:
 128:avr_main.c    **** 			write_command = &request_cpu_program;
 703               		.loc 1 128 3 is_stmt 1 view .LVU132
 128:avr_main.c    **** 			write_command = &request_cpu_program;
 704               		.loc 1 128 5 is_stmt 0 view .LVU133
 705 029e F801      		movw r30,r16
 706 02a0 2481      		ldd r18,Z+4
 707 02a2 3581      		ldd r19,Z+5
 131:avr_main.c    **** 		}
 708               		.loc 1 131 18 view .LVU134
 709 02a4 E0E0      		ldi r30,lo8(request_ppu_program)
 710 02a6 F0E0      		ldi r31,hi8(request_ppu_program)
 128:avr_main.c    **** 			write_command = &request_cpu_program;
 711               		.loc 1 128 5 view .LVU135
 712 02a8 2130      		cpi r18,1
 713 02aa 3105      		cpc r19,__zero_reg__
 714 02ac 01F4      		brne .+2
 715 02ae 00C0      		rjmp .L65
 716               	.L42:
 717               	.LVL48:
 135:avr_main.c    **** 		write_command->length = rq->wLength.word;
 718               		.loc 1 135 3 is_stmt 1 view .LVU136
 135:avr_main.c    **** 		write_command->length = rq->wLength.word;
 719               		.loc 1 135 26 is_stmt 0 view .LVU137
 720 02b0 8083      		st Z,r24
 136:avr_main.c    **** 		write_command->address = rq->wValue.word;
 721               		.loc 1 136 3 is_stmt 1 view .LVU138
 136:avr_main.c    **** 		write_command->address = rq->wValue.word;
 722               		.loc 1 136 25 is_stmt 0 view .LVU139
 723 02b2 D801      		movw r26,r16
 724 02b4 1696      		adiw r26,6
 725 02b6 8D91      		ld r24,X+
 726 02b8 9C91      		ld r25,X
 727 02ba 1797      		sbiw r26,6+1
 728 02bc 9483      		std Z+4,r25
 729 02be 8383      		std Z+3,r24
 137:avr_main.c    **** 		write_command->offset = 0;
 730               		.loc 1 137 3 is_stmt 1 view .LVU140
 137:avr_main.c    **** 		write_command->offset = 0;
 731               		.loc 1 137 26 is_stmt 0 view .LVU141
 732 02c0 1296      		adiw r26,2
 733 02c2 8D91      		ld r24,X+
 734 02c4 9C91      		ld r25,X
 735 02c6 9283      		std Z+2,r25
 736 02c8 8183      		std Z+1,r24
 138:avr_main.c    **** 		return USB_NO_MSG; //goto usbFunctionWrite
 737               		.loc 1 138 3 is_stmt 1 view .LVU142
 138:avr_main.c    **** 		return USB_NO_MSG; //goto usbFunctionWrite
 738               		.loc 1 138 25 is_stmt 0 view .LVU143
 739 02ca 1682      		std Z+6,__zero_reg__
 740 02cc 1582      		std Z+5,__zero_reg__
 139:avr_main.c    **** /*	case REQUEST_FLASH_BUFFER_GET:
 741               		.loc 1 139 3 is_stmt 1 view .LVU144
 139:avr_main.c    **** /*	case REQUEST_FLASH_BUFFER_GET:
 742               		.loc 1 139 10 is_stmt 0 view .LVU145
 743 02ce 0FEF      		ldi r16,lo8(-1)
 744 02d0 1FEF      		ldi r17,lo8(-1)
 745               	.LVL49:
 139:avr_main.c    **** /*	case REQUEST_FLASH_BUFFER_GET:
 746               		.loc 1 139 10 view .LVU146
 747 02d2 00C0      		rjmp .L29
 748               	.LVL50:
 749               	.L37:
 187:avr_main.c    **** 		usbMsgPtr = status;
 750               		.loc 1 187 3 is_stmt 1 view .LVU147
 187:avr_main.c    **** 		usbMsgPtr = status;
 751               		.loc 1 187 15 is_stmt 0 view .LVU148
 752 02d4 0E94 0000 		call vram_connection_get
 753               	.LVL51:
 187:avr_main.c    **** 		usbMsgPtr = status;
 754               		.loc 1 187 13 view .LVU149
 755 02d8 8093 0000 		sts status.2136,r24
 188:avr_main.c    **** 		return 1;
 756               		.loc 1 188 3 is_stmt 1 view .LVU150
 188:avr_main.c    **** 		return 1;
 757               		.loc 1 188 13 is_stmt 0 view .LVU151
 758 02dc 80E0      		ldi r24,lo8(status.2136)
 759 02de 90E0      		ldi r25,hi8(status.2136)
 760 02e0 9093 0000 		sts usbMsgPtr+1,r25
 761 02e4 8093 0000 		sts usbMsgPtr,r24
 189:avr_main.c    **** 	case REQUEST_FIRMWARE_VERSION:{
 762               		.loc 1 189 3 is_stmt 1 view .LVU152
 189:avr_main.c    **** 	case REQUEST_FIRMWARE_VERSION:{
 763               		.loc 1 189 10 is_stmt 0 view .LVU153
 764 02e8 01E0      		ldi r16,lo8(1)
 765 02ea 10E0      		ldi r17,0
 766               	.LVL52:
 189:avr_main.c    **** 	case REQUEST_FIRMWARE_VERSION:{
 767               		.loc 1 189 10 view .LVU154
 768 02ec 00C0      		rjmp .L29
 769               	.LVL53:
 770               	.L36:
 151:avr_main.c    **** 		return 0;
 771               		.loc 1 151 3 is_stmt 1 view .LVU155
 772 02ee 80E0      		ldi r24,0
 773 02f0 0E94 0000 		call disk_init
 774               	.LVL54:
 152:avr_main.c    **** 	case REQUEST_DISK_WRITE:
 775               		.loc 1 152 3 view .LVU156
 152:avr_main.c    **** 	case REQUEST_DISK_WRITE:
 776               		.loc 1 152 10 is_stmt 0 view .LVU157
 777 02f4 10E0      		ldi r17,0
 778 02f6 00E0      		ldi r16,0
 779               	.LVL55:
 152:avr_main.c    **** 	case REQUEST_DISK_WRITE:
 780               		.loc 1 152 10 view .LVU158
 781 02f8 00C0      		rjmp .L29
 782               	.LVL56:
 783               	.L35:
 154:avr_main.c    **** 		return 0;
 784               		.loc 1 154 3 is_stmt 1 view .LVU159
 785 02fa 81E0      		ldi r24,lo8(1)
 786 02fc 0E94 0000 		call disk_init
 787               	.LVL57:
 155:avr_main.c    **** 	case REQUEST_FLASH_STATUS:
 788               		.loc 1 155 3 view .LVU160
 155:avr_main.c    **** 	case REQUEST_FLASH_STATUS:
 789               		.loc 1 155 10 is_stmt 0 view .LVU161
 790 0300 10E0      		ldi r17,0
 791 0302 00E0      		ldi r16,0
 792               	.LVL58:
 155:avr_main.c    **** 	case REQUEST_FLASH_STATUS:
 793               		.loc 1 155 10 view .LVU162
 794 0304 00C0      		rjmp .L29
 795               	.LVL59:
 796               	.L43:
 120:avr_main.c    **** 		goto xxx_read;
 797               		.loc 1 120 3 is_stmt 1 view .LVU163
 798 0306 1696      		adiw r26,6
 799 0308 6D91      		ld r22,X+
 800 030a 7C91      		ld r23,X
 801 030c 1797      		sbiw r26,6+1
 802 030e 40E0      		ldi r20,lo8(readbuffer.2135)
 803 0310 50E0      		ldi r21,hi8(readbuffer.2135)
 804 0312 1296      		adiw r26,2
 805 0314 8D91      		ld r24,X+
 806 0316 9C91      		ld r25,X
 807 0318 0E94 0000 		call ppu_read
 808               	.LVL60:
 121:avr_main.c    **** 	case REQUEST_CPU_WRITE_6502: case REQUEST_CPU_WRITE_FLASH:
 809               		.loc 1 121 3 view .LVU164
 810               	.L48:
 234:avr_main.c    **** 		return rq->wLength.word;
 811               		.loc 1 234 3 view .LVU165
 234:avr_main.c    **** 		return rq->wLength.word;
 812               		.loc 1 234 13 is_stmt 0 view .LVU166
 813 031c 80E0      		ldi r24,lo8(readbuffer.2135)
 814 031e 90E0      		ldi r25,hi8(readbuffer.2135)
 815 0320 9093 0000 		sts usbMsgPtr+1,r25
 816 0324 8093 0000 		sts usbMsgPtr,r24
 235:avr_main.c    **** 	}
 817               		.loc 1 235 3 is_stmt 1 view .LVU167
 235:avr_main.c    **** 	}
 818               		.loc 1 235 21 is_stmt 0 view .LVU168
 819 0328 F801      		movw r30,r16
 820 032a 0681      		ldd r16,Z+6
 821 032c 1781      		ldd r17,Z+7
 822               	.LVL61:
 235:avr_main.c    **** 	}
 823               		.loc 1 235 21 view .LVU169
 824 032e 00C0      		rjmp .L29
 825               	.LVL62:
 826               	.L41:
 157:avr_main.c    **** 		switch((enum index) rq->wIndex.word){
 827               		.loc 1 157 3 is_stmt 1 view .LVU170
 157:avr_main.c    **** 		switch((enum index) rq->wIndex.word){
 828               		.loc 1 157 13 is_stmt 0 view .LVU171
 829 0330 80E0      		ldi r24,lo8(status.2136)
 830 0332 90E0      		ldi r25,hi8(status.2136)
 831 0334 9093 0000 		sts usbMsgPtr+1,r25
 832 0338 8093 0000 		sts usbMsgPtr,r24
 158:avr_main.c    **** 		case INDEX_CPU:
 833               		.loc 1 158 3 is_stmt 1 view .LVU172
 834 033c F801      		movw r30,r16
 835 033e 8481      		ldd r24,Z+4
 836 0340 9581      		ldd r25,Z+5
 837 0342 8C01      		movw r16,r24
 838               	.LVL63:
 158:avr_main.c    **** 		case INDEX_CPU:
 839               		.loc 1 158 3 is_stmt 0 view .LVU173
 840 0344 1127      		clr r17
 841 0346 8130      		cpi r24,lo8(1)
 842 0348 01F4      		brne .+2
 843 034a 00C0      		rjmp .L49
 158:avr_main.c    **** 		case INDEX_CPU:
 844               		.loc 1 158 3 view .LVU174
 845 034c 0230      		cpi r16,2
 846 034e 1105      		cpc r17,__zero_reg__
 847 0350 01F4      		brne .+2
 848 0352 00C0      		rjmp .L50
 166:avr_main.c    **** 			status[1] = flash_ppu_status();
 849               		.loc 1 166 4 is_stmt 1 view .LVU175
 166:avr_main.c    **** 			status[1] = flash_ppu_status();
 850               		.loc 1 166 16 is_stmt 0 view .LVU176
 851 0354 0E94 0000 		call flash_cpu_status
 852               	.LVL64:
 166:avr_main.c    **** 			status[1] = flash_ppu_status();
 853               		.loc 1 166 14 view .LVU177
 854 0358 8093 0000 		sts status.2136,r24
 167:avr_main.c    **** 			return 2;
 855               		.loc 1 167 4 is_stmt 1 view .LVU178
 167:avr_main.c    **** 			return 2;
 856               		.loc 1 167 16 is_stmt 0 view .LVU179
 857 035c 0E94 0000 		call flash_ppu_status
 858               	.LVL65:
 167:avr_main.c    **** 			return 2;
 859               		.loc 1 167 14 view .LVU180
 860 0360 8093 0000 		sts status.2136+1,r24
 168:avr_main.c    **** 		}
 861               		.loc 1 168 4 is_stmt 1 view .LVU181
 168:avr_main.c    **** 		}
 862               		.loc 1 168 11 is_stmt 0 view .LVU182
 863 0364 02E0      		ldi r16,lo8(2)
 864 0366 10E0      		ldi r17,0
 865 0368 00C0      		rjmp .L29
 866               	.LVL66:
 867               	.L39:
 180:avr_main.c    **** 			flash_cpu_erase(rq->wValue.word);
 868               		.loc 1 180 3 is_stmt 1 view .LVU183
 869 036a F801      		movw r30,r16
 870 036c 8281      		ldd r24,Z+2
 871 036e 9381      		ldd r25,Z+3
 180:avr_main.c    **** 			flash_cpu_erase(rq->wValue.word);
 872               		.loc 1 180 5 is_stmt 0 view .LVU184
 873 0370 2481      		ldd r18,Z+4
 874 0372 3581      		ldd r19,Z+5
 875 0374 2130      		cpi r18,1
 876 0376 3105      		cpc r19,__zero_reg__
 877 0378 01F4      		brne .+2
 878 037a 00C0      		rjmp .L66
 183:avr_main.c    **** 		}
 879               		.loc 1 183 4 is_stmt 1 view .LVU185
 880 037c 0E94 0000 		call flash_ppu_erase
 881               	.LVL67:
 185:avr_main.c    **** 	case REQUEST_VRAM_CONNECTION:
 882               		.loc 1 185 10 is_stmt 0 view .LVU186
 883 0380 10E0      		ldi r17,0
 884 0382 00E0      		ldi r16,0
 885               	.LVL68:
 185:avr_main.c    **** 	case REQUEST_VRAM_CONNECTION:
 886               		.loc 1 185 10 view .LVU187
 887 0384 00C0      		rjmp .L29
 888               	.LVL69:
 889               	.L38:
 172:avr_main.c    **** 			flash_cpu_device_get(status);
 890               		.loc 1 172 3 is_stmt 1 view .LVU188
 172:avr_main.c    **** 			flash_cpu_device_get(status);
 891               		.loc 1 172 5 is_stmt 0 view .LVU189
 892 0386 1496      		adiw r26,4
 893 0388 8D91      		ld r24,X+
 894 038a 9C91      		ld r25,X
 895 038c 0197      		sbiw r24,1
 896 038e 01F4      		brne .+2
 897 0390 00C0      		rjmp .L67
 175:avr_main.c    **** 		}
 898               		.loc 1 175 4 is_stmt 1 view .LVU190
 899 0392 80E0      		ldi r24,lo8(status.2136)
 900 0394 90E0      		ldi r25,hi8(status.2136)
 901 0396 0E94 0000 		call flash_ppu_device_get
 902               	.LVL70:
 903               	.L53:
 177:avr_main.c    **** 		return 2;
 904               		.loc 1 177 3 view .LVU191
 177:avr_main.c    **** 		return 2;
 905               		.loc 1 177 13 is_stmt 0 view .LVU192
 906 039a 80E0      		ldi r24,lo8(status.2136)
 907 039c 90E0      		ldi r25,hi8(status.2136)
 908 039e 9093 0000 		sts usbMsgPtr+1,r25
 909 03a2 8093 0000 		sts usbMsgPtr,r24
 178:avr_main.c    **** 	case REQUEST_FLASH_ERASE:
 910               		.loc 1 178 3 is_stmt 1 view .LVU193
 178:avr_main.c    **** 	case REQUEST_FLASH_ERASE:
 911               		.loc 1 178 10 is_stmt 0 view .LVU194
 912 03a6 02E0      		ldi r16,lo8(2)
 913 03a8 10E0      		ldi r17,0
 914               	.LVL71:
 178:avr_main.c    **** 	case REQUEST_FLASH_ERASE:
 915               		.loc 1 178 10 view .LVU195
 916 03aa 00C0      		rjmp .L29
 917               	.LVL72:
 918               	.L45:
 117:avr_main.c    **** 		goto xxx_read;
 919               		.loc 1 117 3 is_stmt 1 view .LVU196
 920 03ac F801      		movw r30,r16
 921 03ae 6681      		ldd r22,Z+6
 922 03b0 7781      		ldd r23,Z+7
 923 03b2 40E0      		ldi r20,lo8(readbuffer.2135)
 924 03b4 50E0      		ldi r21,hi8(readbuffer.2135)
 925 03b6 8281      		ldd r24,Z+2
 926 03b8 9381      		ldd r25,Z+3
 927 03ba 0E94 0000 		call cpu_read_6502
 928               	.LVL73:
 118:avr_main.c    **** 	case REQUEST_PPU_READ:
 929               		.loc 1 118 3 view .LVU197
 930 03be 00C0      		rjmp .L48
 931               	.L47:
 103:avr_main.c    **** 		readbuffer[1] = rq->wValue.bytes[1];
 932               		.loc 1 103 3 view .LVU198
 103:avr_main.c    **** 		readbuffer[1] = rq->wValue.bytes[1];
 933               		.loc 1 103 17 is_stmt 0 view .LVU199
 934 03c0 F801      		movw r30,r16
 935 03c2 8281      		ldd r24,Z+2
 936 03c4 8093 0000 		sts readbuffer.2135,r24
 104:avr_main.c    **** 		readbuffer[2] = rq->wIndex.bytes[0];
 937               		.loc 1 104 3 is_stmt 1 view .LVU200
 104:avr_main.c    **** 		readbuffer[2] = rq->wIndex.bytes[0];
 938               		.loc 1 104 17 is_stmt 0 view .LVU201
 939 03c8 8381      		ldd r24,Z+3
 940 03ca 8093 0000 		sts readbuffer.2135+1,r24
 105:avr_main.c    **** 		readbuffer[3] = rq->wIndex.bytes[1];
 941               		.loc 1 105 3 is_stmt 1 view .LVU202
 105:avr_main.c    **** 		readbuffer[3] = rq->wIndex.bytes[1];
 942               		.loc 1 105 17 is_stmt 0 view .LVU203
 943 03ce 8481      		ldd r24,Z+4
 944 03d0 8093 0000 		sts readbuffer.2135+2,r24
 106:avr_main.c    **** 		usbMsgPtr = readbuffer;
 945               		.loc 1 106 3 is_stmt 1 view .LVU204
 106:avr_main.c    **** 		usbMsgPtr = readbuffer;
 946               		.loc 1 106 17 is_stmt 0 view .LVU205
 947 03d4 8581      		ldd r24,Z+5
 948 03d6 8093 0000 		sts readbuffer.2135+3,r24
 107:avr_main.c    **** 		return 4;
 949               		.loc 1 107 3 is_stmt 1 view .LVU206
 107:avr_main.c    **** 		return 4;
 950               		.loc 1 107 13 is_stmt 0 view .LVU207
 951 03da 80E0      		ldi r24,lo8(readbuffer.2135)
 952 03dc 90E0      		ldi r25,hi8(readbuffer.2135)
 953 03de 9093 0000 		sts usbMsgPtr+1,r25
 954 03e2 8093 0000 		sts usbMsgPtr,r24
 108:avr_main.c    **** 	case REQUEST_PHI2_INIT:
 955               		.loc 1 108 3 is_stmt 1 view .LVU208
 108:avr_main.c    **** 	case REQUEST_PHI2_INIT:
 956               		.loc 1 108 10 is_stmt 0 view .LVU209
 957 03e6 04E0      		ldi r16,lo8(4)
 958 03e8 10E0      		ldi r17,0
 959               	.LVL74:
 108:avr_main.c    **** 	case REQUEST_PHI2_INIT:
 960               		.loc 1 108 10 view .LVU210
 961 03ea 00C0      		rjmp .L29
 962               	.LVL75:
 963               	.L46:
 110:avr_main.c    **** 		phi2_init();
 964               		.loc 1 110 3 is_stmt 1 view .LVU211
 965 03ec 0E94 0000 		call flash_both_idle
 966               	.LVL76:
 111:avr_main.c    **** 		return 0;
 967               		.loc 1 111 3 view .LVU212
 968 03f0 0E94 0000 		call phi2_init
 969               	.LVL77:
 112:avr_main.c    **** 	case REQUEST_CPU_READ:
 970               		.loc 1 112 3 view .LVU213
 112:avr_main.c    **** 	case REQUEST_CPU_READ:
 971               		.loc 1 112 10 is_stmt 0 view .LVU214
 972 03f4 10E0      		ldi r17,0
 973 03f6 00E0      		ldi r16,0
 974               	.LVL78:
 112:avr_main.c    **** 	case REQUEST_CPU_READ:
 975               		.loc 1 112 10 view .LVU215
 976 03f8 00C0      		rjmp .L29
 977               	.LVL79:
 978               	.L44:
 114:avr_main.c    **** 		goto xxx_read;
 979               		.loc 1 114 3 is_stmt 1 view .LVU216
 980 03fa 1696      		adiw r26,6
 981 03fc 6D91      		ld r22,X+
 982 03fe 7C91      		ld r23,X
 983 0400 1797      		sbiw r26,6+1
 984 0402 40E0      		ldi r20,lo8(readbuffer.2135)
 985 0404 50E0      		ldi r21,hi8(readbuffer.2135)
 986 0406 1296      		adiw r26,2
 987 0408 8D91      		ld r24,X+
 988 040a 9C91      		ld r25,X
 989 040c 0E94 0000 		call cpu_read
 990               	.LVL80:
 115:avr_main.c    **** 	case REQUEST_CPU_READ_6502:
 991               		.loc 1 115 3 view .LVU217
 992 0410 00C0      		rjmp .L48
 993               	.L34:
 994               	.LBB15:
 191:avr_main.c    **** 		static const /*PROGMEM*/ char date[VERSION_STRING_SIZE] = 
 995               		.loc 1 191 3 view .LVU218
 200:avr_main.c    **** 		goto xxx_read;}
 996               		.loc 1 200 3 view .LVU219
 997 0412 1696      		adiw r26,6
 998 0414 4D91      		ld r20,X+
 999 0416 5C91      		ld r21,X
 1000 0418 60E0      		ldi r22,lo8(date.2162)
 1001 041a 70E0      		ldi r23,hi8(date.2162)
 1002 041c 80E0      		ldi r24,lo8(readbuffer.2135)
 1003 041e 90E0      		ldi r25,hi8(readbuffer.2135)
 1004 0420 0E94 0000 		call memcpy_P
 1005               	.LVL81:
 201:avr_main.c    **** 	case REQUEST_FIRMWARE_PROGRAM:{
 1006               		.loc 1 201 3 view .LVU220
 1007 0424 00C0      		rjmp .L48
 1008               	.L31:
 201:avr_main.c    **** 	case REQUEST_FIRMWARE_PROGRAM:{
 1009               		.loc 1 201 3 is_stmt 0 view .LVU221
 1010               	.LBE15:
 1011               	.LBB16:
 229:avr_main.c    **** 		memcpy_P(readbuffer, firm, rq->wLength.word);
 1012               		.loc 1 229 3 is_stmt 1 view .LVU222
 1013               	.LVL82:
 230:avr_main.c    **** 		}
 1014               		.loc 1 230 3 view .LVU223
 1015 0426 1696      		adiw r26,6
 1016 0428 4D91      		ld r20,X+
 1017 042a 5C91      		ld r21,X
 1018 042c 1797      		sbiw r26,6+1
 1019 042e 1296      		adiw r26,2
 1020 0430 6D91      		ld r22,X+
 1021 0432 7C91      		ld r23,X
 1022 0434 80E0      		ldi r24,lo8(readbuffer.2135)
 1023 0436 90E0      		ldi r25,hi8(readbuffer.2135)
 1024 0438 0E94 0000 		call memcpy_P
 1025               	.LVL83:
 230:avr_main.c    **** 		}
 1026               		.loc 1 230 3 is_stmt 0 view .LVU224
 1027               	.LBE16:
 232:avr_main.c    **** 	xxx_read:
 1028               		.loc 1 232 3 is_stmt 1 view .LVU225
 1029 043c 00C0      		rjmp .L48
 1030               	.LVL84:
 1031               	.L50:
 163:avr_main.c    **** 			return 1;
 1032               		.loc 1 163 4 view .LVU226
 163:avr_main.c    **** 			return 1;
 1033               		.loc 1 163 16 is_stmt 0 view .LVU227
 1034 043e 0E94 0000 		call flash_ppu_status
 1035               	.LVL85:
 163:avr_main.c    **** 			return 1;
 1036               		.loc 1 163 14 view .LVU228
 1037 0442 8093 0000 		sts status.2136,r24
 164:avr_main.c    **** 		default:
 1038               		.loc 1 164 4 is_stmt 1 view .LVU229
 164:avr_main.c    **** 		default:
 1039               		.loc 1 164 11 is_stmt 0 view .LVU230
 1040 0446 01E0      		ldi r16,lo8(1)
 1041 0448 10E0      		ldi r17,0
 1042 044a 00C0      		rjmp .L29
 1043               	.LVL86:
 1044               	.L61:
 101:avr_main.c    **** 	case REQUEST_ECHO:
 1045               		.loc 1 101 26 view .LVU231
 1046 044c E0E0      		ldi r30,lo8(request_both_write)
 1047 044e F0E0      		ldi r31,hi8(request_both_write)
 1048 0450 00C0      		rjmp .L42
 1049               	.L65:
 129:avr_main.c    **** 		}else{
 1050               		.loc 1 129 18 view .LVU232
 1051 0452 E0E0      		ldi r30,lo8(request_cpu_program)
 1052 0454 F0E0      		ldi r31,hi8(request_cpu_program)
 1053 0456 00C0      		rjmp .L42
 1054               	.L67:
 173:avr_main.c    **** 		}else{
 1055               		.loc 1 173 4 is_stmt 1 view .LVU233
 1056 0458 80E0      		ldi r24,lo8(status.2136)
 1057 045a 90E0      		ldi r25,hi8(status.2136)
 1058 045c 0E94 0000 		call flash_cpu_device_get
 1059               	.LVL87:
 1060 0460 00C0      		rjmp .L53
 1061               	.L66:
 181:avr_main.c    **** 		}else{
 1062               		.loc 1 181 4 view .LVU234
 1063 0462 0E94 0000 		call flash_cpu_erase
 1064               	.LVL88:
 185:avr_main.c    **** 	case REQUEST_VRAM_CONNECTION:
 1065               		.loc 1 185 10 is_stmt 0 view .LVU235
 1066 0466 10E0      		ldi r17,0
 1067 0468 00E0      		ldi r16,0
 1068               	.LVL89:
 185:avr_main.c    **** 	case REQUEST_VRAM_CONNECTION:
 1069               		.loc 1 185 10 view .LVU236
 1070 046a 00C0      		rjmp .L29
 1071               	.LVL90:
 1072               	.L49:
 160:avr_main.c    **** 			return 1;
 1073               		.loc 1 160 4 is_stmt 1 view .LVU237
 160:avr_main.c    **** 			return 1;
 1074               		.loc 1 160 16 is_stmt 0 view .LVU238
 1075 046c 0E94 0000 		call flash_cpu_status
 1076               	.LVL91:
 160:avr_main.c    **** 			return 1;
 1077               		.loc 1 160 14 view .LVU239
 1078 0470 8093 0000 		sts status.2136,r24
 161:avr_main.c    **** 		case INDEX_PPU:
 1079               		.loc 1 161 4 is_stmt 1 view .LVU240
 161:avr_main.c    **** 		case INDEX_PPU:
 1080               		.loc 1 161 11 is_stmt 0 view .LVU241
 1081 0474 00C0      		rjmp .L29
 1082               	.LVL92:
 1083               	.L64:
 1084               	.LBB17:
 222:avr_main.c    **** 			usbDeviceDisconnect();
 1085               		.loc 1 222 6 view .LVU242
 1086 0476 2091 0000 		lds r18,readbuffer.2135+2
 1087 047a 3091 0000 		lds r19,readbuffer.2135+2+1
 1088 047e 8091 0000 		lds r24,signature.2168+2
 1089 0482 9091 0000 		lds r25,signature.2168+2+1
 1090 0486 2817      		cp r18,r24
 1091 0488 3907      		cpc r19,r25
 1092 048a 01F0      		breq .+2
 1093 048c 00C0      		rjmp .L57
 1094 048e 2091 0000 		lds r18,readbuffer.2135+4
 1095 0492 3091 0000 		lds r19,readbuffer.2135+4+1
 1096 0496 8091 0000 		lds r24,signature.2168+4
 1097 049a 9091 0000 		lds r25,signature.2168+4+1
 1098 049e 2817      		cp r18,r24
 1099 04a0 3907      		cpc r19,r25
 1100 04a2 01F0      		breq .+2
 1101 04a4 00C0      		rjmp .L57
 1102 04a6 9091 0000 		lds r25,readbuffer.2135+6
 1103 04aa 8091 0000 		lds r24,signature.2168+6
 1104 04ae 9813      		cpse r25,r24
 1105 04b0 00C0      		rjmp .L57
 1106 04b2 90E0      		ldi r25,0
 1107 04b4 80E0      		ldi r24,0
 1108 04b6 00C0      		rjmp .L58
 1109               	.LBE17:
 1110               		.cfi_endproc
 1111               	.LFE11:
 1113               		.section	.text.startup,"ax",@progbits
 1114               	.global	main
 1116               	main:
 1117               	.LFB12:
 239:avr_main.c    **** 
 240:avr_main.c    **** int main(void)
 241:avr_main.c    **** {
 1118               		.loc 1 241 1 is_stmt 1 view -0
 1119               		.cfi_startproc
 1120               	/* prologue: function */
 1121               	/* frame size = 0 */
 1122               	/* stack size = 0 */
 1123               	.L__stack_usage = 0
 242:avr_main.c    **** 	static const struct write_command wc_init = {
 1124               		.loc 1 242 2 view .LVU244
 243:avr_main.c    **** 		.request = REQUEST_NOP, .length = 0, .offset = 0
 244:avr_main.c    **** 	};
 245:avr_main.c    **** 	request_both_write = wc_init;
 1125               		.loc 1 245 2 view .LVU245
 1126               		.loc 1 245 21 is_stmt 0 view .LVU246
 1127 0000 96E0      		ldi r25,lo8(6)
 1128 0002 E0E0      		ldi r30,lo8(request_both_write+1)
 1129 0004 F0E0      		ldi r31,hi8(request_both_write+1)
 1130 0006 DF01      		movw r26,r30
 1131 0008 292F      		mov r18,r25
 1132               		0:
 1133 000a 1D92      		st X+,__zero_reg__
 1134 000c 2A95      		dec r18
 1135 000e 01F4      		brne 0b
 1136 0010 8EEE      		ldi r24,lo8(-18)
 1137 0012 8093 0000 		sts request_both_write,r24
 246:avr_main.c    **** 	request_cpu_program = wc_init;
 1138               		.loc 1 246 2 is_stmt 1 view .LVU247
 1139               		.loc 1 246 22 is_stmt 0 view .LVU248
 1140 0016 E0E0      		ldi r30,lo8(request_cpu_program+1)
 1141 0018 F0E0      		ldi r31,hi8(request_cpu_program+1)
 1142 001a DF01      		movw r26,r30
 1143 001c 292F      		mov r18,r25
 1144               		0:
 1145 001e 1D92      		st X+,__zero_reg__
 1146 0020 2A95      		dec r18
 1147 0022 01F4      		brne 0b
 1148 0024 8093 0000 		sts request_cpu_program,r24
 247:avr_main.c    **** 	request_ppu_program = wc_init;
 1149               		.loc 1 247 2 is_stmt 1 view .LVU249
 1150               		.loc 1 247 22 is_stmt 0 view .LVU250
 1151 0028 E0E0      		ldi r30,lo8(request_ppu_program+1)
 1152 002a F0E0      		ldi r31,hi8(request_ppu_program+1)
 1153 002c DF01      		movw r26,r30
 1154               		0:
 1155 002e 1D92      		st X+,__zero_reg__
 1156 0030 9A95      		dec r25
 1157 0032 01F4      		brne 0b
 1158 0034 8093 0000 		sts request_ppu_program,r24
 248:avr_main.c    **** 
 249:avr_main.c    **** 	bus_init();
 1159               		.loc 1 249 2 is_stmt 1 view .LVU251
 1160 0038 0E94 0000 		call bus_init
 1161               	.LVL93:
 250:avr_main.c    **** 	usbInit();
 1162               		.loc 1 250 2 view .LVU252
 1163 003c 0E94 0000 		call usbInit
 1164               	.LVL94:
 251:avr_main.c    **** 	usbDeviceDisconnect();
 1165               		.loc 1 251 2 view .LVU253
 1166 0040 8C9A      		sbi 0x11,4
 1167               	.LBB18:
 252:avr_main.c    **** 	{
 253:avr_main.c    **** 		uchar   i;
 1168               		.loc 1 253 3 view .LVU254
 254:avr_main.c    **** 		i = 0;
 1169               		.loc 1 254 3 view .LVU255
 1170               	.LVL95:
 255:avr_main.c    **** 		while(--i){
 1171               		.loc 1 255 3 view .LVU256
 1172               		.loc 1 255 8 view .LVU257
 1173               		.loc 1 255 8 is_stmt 0 view .LVU258
 1174               	.LBE18:
 251:avr_main.c    **** 	{
 1175               		.loc 1 251 2 view .LVU259
 1176 0042 8FEF      		ldi r24,lo8(-1)
 1177               	.LVL96:
 1178               	.L69:
 1179               	.LBB21:
 256:avr_main.c    **** 			wdt_reset();
 1180               		.loc 1 256 4 is_stmt 1 view .LVU260
 1181               	/* #APP */
 1182               	 ;  256 "avr_main.c" 1
 1183 0044 A895      		wdr
 1184               	 ;  0 "" 2
 257:avr_main.c    **** 			_delay_ms(1);
 1185               		.loc 1 257 4 view .LVU261
 1186               	.LVL97:
 1187               	/* #NOAPP */
 1188               	.LBB19:
 1189               	.LBI19:
 1190               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 1191               		.loc 2 166 1 view .LVU262
 1192               	.LBB20:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 1193               		.loc 2 168 2 view .LVU263
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 1194               		.loc 2 172 2 view .LVU264
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1195               		.loc 2 173 2 view .LVU265
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1196               		.loc 2 174 2 view .LVU266
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 1197               		.loc 2 184 3 view .LVU267
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1198               		.loc 2 187 2 view .LVU268
 1199 0046 EFE9      		ldi r30,lo8(3999)
 1200 0048 FFE0      		ldi r31,hi8(3999)
 1201 004a 3197      	1:	sbiw r30,1
 1202 004c 01F4      		brne 1b
 1203 004e 00C0      		rjmp .
 1204 0050 0000      		nop
 1205               	.LVL98:
 1206               		.loc 2 187 2 is_stmt 0 view .LVU269
 1207               	.LBE20:
 1208               	.LBE19:
 255:avr_main.c    **** 			wdt_reset();
 1209               		.loc 1 255 8 is_stmt 1 view .LVU270
 255:avr_main.c    **** 			wdt_reset();
 1210               		.loc 1 255 8 is_stmt 0 view .LVU271
 1211 0052 8150      		subi r24,lo8(-(-1))
 1212               	.LVL99:
 255:avr_main.c    **** 			wdt_reset();
 1213               		.loc 1 255 8 view .LVU272
 1214 0054 01F4      		brne .L69
 1215               	.LBE21:
 258:avr_main.c    **** 		}
 259:avr_main.c    **** 	}
 260:avr_main.c    **** 	usbDeviceConnect();
 1216               		.loc 1 260 2 is_stmt 1 view .LVU273
 1217 0056 8C98      		cbi 0x11,4
 261:avr_main.c    **** 	wdt_enable(WDTO_500MS);
 1218               		.loc 1 261 2 view .LVU274
 1219               	.LVL100:
 1220               	.LBB22:
 1221               	.LBI22:
 1222               		.file 3 "/usr/avr/include/avr/wdt.h"
   1:/usr/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/avr/include/avr/wdt.h **** 
   5:/usr/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/avr/wdt.h **** 
   8:/usr/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/avr/wdt.h **** 
  11:/usr/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/avr/wdt.h ****      distribution.
  15:/usr/avr/include/avr/wdt.h **** 
  16:/usr/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/avr/wdt.h **** 
  20:/usr/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/avr/wdt.h **** 
  32:/usr/avr/include/avr/wdt.h **** /* $Id: wdt.h 2503 2016-02-07 22:59:47Z joerg_wunsch $ */
  33:/usr/avr/include/avr/wdt.h **** 
  34:/usr/avr/include/avr/wdt.h **** /*
  35:/usr/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/avr/include/avr/wdt.h ****  */
  37:/usr/avr/include/avr/wdt.h **** 
  38:/usr/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/avr/include/avr/wdt.h **** 
  41:/usr/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/avr/include/avr/wdt.h **** 
  44:/usr/avr/include/avr/wdt.h **** /** \file */
  45:/usr/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/avr/include/avr/wdt.h **** 
  48:/usr/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/avr/include/avr/wdt.h **** 
  57:/usr/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/avr/include/avr/wdt.h **** 
  61:/usr/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/avr/include/avr/wdt.h ****     the following:
  68:/usr/avr/include/avr/wdt.h **** 
  69:/usr/avr/include/avr/wdt.h ****     \code
  70:/usr/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/avr/include/avr/wdt.h **** 
  73:/usr/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/avr/include/avr/wdt.h **** 
  75:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/avr/include/avr/wdt.h ****     {
  80:/usr/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/avr/include/avr/wdt.h ****     }
  84:/usr/avr/include/avr/wdt.h ****     \endcode
  85:/usr/avr/include/avr/wdt.h **** 
  86:/usr/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/avr/include/avr/wdt.h **** */
  91:/usr/avr/include/avr/wdt.h **** 
  92:/usr/avr/include/avr/wdt.h **** /**
  93:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/avr/include/avr/wdt.h **** */
  98:/usr/avr/include/avr/wdt.h **** 
  99:/usr/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/avr/include/avr/wdt.h **** 
 101:/usr/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/avr/include/avr/wdt.h **** 
 103:/usr/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/avr/include/avr/wdt.h **** #else
 106:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/avr/include/avr/wdt.h **** #endif
 108:/usr/avr/include/avr/wdt.h **** 
 109:/usr/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/avr/include/avr/wdt.h **** #else
 114:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/avr/include/avr/wdt.h **** #endif
 116:/usr/avr/include/avr/wdt.h **** 
 117:/usr/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/avr/include/avr/wdt.h **** #else
 120:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/avr/include/avr/wdt.h **** #endif
 122:/usr/avr/include/avr/wdt.h **** 
 123:/usr/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/avr/include/avr/wdt.h **** 
 125:/usr/avr/include/avr/wdt.h **** 
 126:/usr/avr/include/avr/wdt.h **** /**
 127:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/avr/include/avr/wdt.h **** 
 134:/usr/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/avr/include/avr/wdt.h **** */
 136:/usr/avr/include/avr/wdt.h **** 
 137:/usr/avr/include/avr/wdt.h **** 
 138:/usr/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/avr/include/avr/wdt.h **** 
 140:/usr/avr/include/avr/wdt.h **** /*
 141:/usr/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 142:/usr/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 143:/usr/avr/include/avr/wdt.h ****    registers to the CCP register
 144:/usr/avr/include/avr/wdt.h **** ** At the same time,
 145:/usr/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 146:/usr/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 147:/usr/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 148:/usr/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 149:/usr/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 150:/usr/avr/include/avr/wdt.h ****    sync is finished).
 151:/usr/avr/include/avr/wdt.h **** */
 152:/usr/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 153:/usr/avr/include/avr/wdt.h **** do { \
 154:/usr/avr/include/avr/wdt.h **** uint8_t temp; \
 155:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 156:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 157:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 158:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 159:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 160:/usr/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 161:/usr/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 162:/usr/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 163:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 164:/usr/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 165:/usr/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 166:/usr/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 167:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 168:/usr/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 169:/usr/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 170:/usr/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 171:/usr/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 172:/usr/avr/include/avr/wdt.h ****     : "r0" \
 173:/usr/avr/include/avr/wdt.h **** ); \
 174:/usr/avr/include/avr/wdt.h **** } while(0)
 175:/usr/avr/include/avr/wdt.h **** 
 176:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 177:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 178:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 179:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 180:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 181:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 182:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 183:/usr/avr/include/avr/wdt.h ****     : \
 184:/usr/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 185:/usr/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 186:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 187:/usr/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 188:/usr/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 189:/usr/avr/include/avr/wdt.h ****     : "r0" \
 190:/usr/avr/include/avr/wdt.h **** );
 191:/usr/avr/include/avr/wdt.h **** 
 192:/usr/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 193:/usr/avr/include/avr/wdt.h **** 
 194:/usr/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 195:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 196:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 197:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 198:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 199:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 200:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 201:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 202:/usr/avr/include/avr/wdt.h ****     : /* no outputs */  \
 203:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 204:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 205:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 206:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 207:/usr/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 208:/usr/avr/include/avr/wdt.h ****     : "r16" \
 209:/usr/avr/include/avr/wdt.h **** )
 210:/usr/avr/include/avr/wdt.h **** 
 211:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 212:/usr/avr/include/avr/wdt.h **** do { \
 213:/usr/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 214:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 215:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 216:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 217:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 218:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 219:/usr/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 220:/usr/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 221:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 222:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 223:/usr/avr/include/avr/wdt.h ****     : /*no output */ \
 224:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 225:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 226:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 227:/usr/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 228:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 229:/usr/avr/include/avr/wdt.h ****     : "r16" \
 230:/usr/avr/include/avr/wdt.h **** ); \
 231:/usr/avr/include/avr/wdt.h **** }while(0)
 232:/usr/avr/include/avr/wdt.h **** 
 233:/usr/avr/include/avr/wdt.h **** #elif defined(CCP)
 234:/usr/avr/include/avr/wdt.h **** 
 235:/usr/avr/include/avr/wdt.h **** static __inline__
 236:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 237:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 238:/usr/avr/include/avr/wdt.h **** {
 239:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 240:/usr/avr/include/avr/wdt.h **** 	{
 241:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 242:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 243:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 244:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 245:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 246:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 247:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 248:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 249:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 250:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 251:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 252:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 253:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 254:/usr/avr/include/avr/wdt.h **** 			: "r0"
 255:/usr/avr/include/avr/wdt.h **** 			);
 256:/usr/avr/include/avr/wdt.h **** 	}
 257:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 258:/usr/avr/include/avr/wdt.h **** 	{
 259:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 260:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 261:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 262:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 263:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 264:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 265:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 266:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 267:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 268:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 269:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 270:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 271:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 272:/usr/avr/include/avr/wdt.h **** 			: "r0"
 273:/usr/avr/include/avr/wdt.h **** 			);
 274:/usr/avr/include/avr/wdt.h **** 	}
 275:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 276:/usr/avr/include/avr/wdt.h **** 	{
 277:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 278:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 279:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 280:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 281:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 282:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 283:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 284:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 285:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 286:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 287:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 288:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 289:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 290:/usr/avr/include/avr/wdt.h **** 			: "r0"
 291:/usr/avr/include/avr/wdt.h **** 			);
 292:/usr/avr/include/avr/wdt.h **** 	}
 293:/usr/avr/include/avr/wdt.h **** 	else
 294:/usr/avr/include/avr/wdt.h ****  	{
 295:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 296:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 297:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 298:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 299:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 300:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 301:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 302:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 303:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 304:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 305:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 306:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 307:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 308:/usr/avr/include/avr/wdt.h **** 			: "r0"
 309:/usr/avr/include/avr/wdt.h **** 			);
 310:/usr/avr/include/avr/wdt.h **** 	}
 311:/usr/avr/include/avr/wdt.h **** }
 312:/usr/avr/include/avr/wdt.h **** 
 313:/usr/avr/include/avr/wdt.h **** static __inline__
 314:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 315:/usr/avr/include/avr/wdt.h **** void wdt_disable (void)
 316:/usr/avr/include/avr/wdt.h **** {
 317:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 318:/usr/avr/include/avr/wdt.h **** 	{
 319:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 320:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 321:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 322:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 323:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 324:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 325:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 326:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 327:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 328:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 330:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 331:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 334:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 335:/usr/avr/include/avr/wdt.h **** 				: "r0"
 336:/usr/avr/include/avr/wdt.h **** 				);
 337:/usr/avr/include/avr/wdt.h **** 	}
 338:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 339:/usr/avr/include/avr/wdt.h **** 	{
 340:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 341:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 342:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 343:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 344:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 345:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 346:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 347:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 348:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 349:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 350:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 351:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 352:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 353:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 354:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 355:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 356:/usr/avr/include/avr/wdt.h **** 				: "r0"
 357:/usr/avr/include/avr/wdt.h **** 				);
 358:/usr/avr/include/avr/wdt.h **** 	}
 359:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:/usr/avr/include/avr/wdt.h **** 	{
 361:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 362:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 363:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 365:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 366:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 372:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 373:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:/usr/avr/include/avr/wdt.h **** 				: "r0"
 378:/usr/avr/include/avr/wdt.h **** 				);
 379:/usr/avr/include/avr/wdt.h **** 	}
 380:/usr/avr/include/avr/wdt.h **** 	else
 381:/usr/avr/include/avr/wdt.h **** 	{
 382:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 383:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 384:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 386:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 387:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 393:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 394:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:/usr/avr/include/avr/wdt.h **** 				: "r0"
 399:/usr/avr/include/avr/wdt.h **** 				);
 400:/usr/avr/include/avr/wdt.h **** 	}
 401:/usr/avr/include/avr/wdt.h **** }
 402:/usr/avr/include/avr/wdt.h **** 
 403:/usr/avr/include/avr/wdt.h **** #else
 404:/usr/avr/include/avr/wdt.h **** 
 405:/usr/avr/include/avr/wdt.h **** static __inline__
 406:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 407:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 1223               		.loc 3 407 6 view .LVU275
 1224               	.LBB23:
 408:/usr/avr/include/avr/wdt.h **** {
 409:/usr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 1225               		.loc 3 409 2 view .LVU276
 410:/usr/avr/include/avr/wdt.h **** 	{
 411:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 1226               		.loc 3 411 3 view .LVU277
 1227 0058 88E1      		ldi r24,lo8(24)
 1228               	.LVL101:
 1229               		.loc 3 411 3 is_stmt 0 view .LVU278
 1230 005a 9DE0      		ldi r25,lo8(13)
 1231               	/* #APP */
 1232               	 ;  411 "/usr/avr/include/avr/wdt.h" 1
 1233 005c 0FB6      		in __tmp_reg__,__SREG__
 1234 005e F894      		cli
 1235 0060 A895      		wdr
 1236 0062 81BD      		out 33, r24
 1237 0064 0FBE      		out __SREG__,__tmp_reg__
 1238 0066 91BD      		out 33, r25
 1239               	 	
 1240               	 ;  0 "" 2
 1241               	.LVL102:
 1242               		.loc 3 411 3 view .LVU279
 1243               	/* #NOAPP */
 1244               	.LBE23:
 1245               	.LBE22:
 262:avr_main.c    **** 	sei();
 1246               		.loc 1 262 2 is_stmt 1 view .LVU280
 1247               	/* #APP */
 1248               	 ;  262 "avr_main.c" 1
 1249 0068 7894      		sei
 1250               	 ;  0 "" 2
 1251               	/* #NOAPP */
 1252               	.L70:
 263:avr_main.c    **** 	for(;;){
 1253               		.loc 1 263 2 discriminator 1 view .LVU281
 264:avr_main.c    **** 		wdt_reset();
 1254               		.loc 1 264 3 discriminator 1 view .LVU282
 1255               	/* #APP */
 1256               	 ;  264 "avr_main.c" 1
 1257 006a A895      		wdr
 1258               	 ;  0 "" 2
 265:avr_main.c    **** 		usbPoll();
 1259               		.loc 1 265 3 discriminator 1 view .LVU283
 1260               	/* #NOAPP */
 1261 006c 0E94 0000 		call usbPoll
 1262               	.LVL103:
 266:avr_main.c    **** 		//disk_process();
 267:avr_main.c    **** 		flash_process();
 1263               		.loc 1 267 3 discriminator 1 view .LVU284
 1264 0070 0E94 0000 		call flash_process
 1265               	.LVL104:
 263:avr_main.c    **** 		wdt_reset();
 1266               		.loc 1 263 7 discriminator 1 view .LVU285
 1267 0074 00C0      		rjmp .L70
 1268               		.cfi_endproc
 1269               	.LFE12:
 1271               		.section	.rodata
 1274               	signature.2168:
 1275 0000 6B61 7A7A 		.ascii	"kazzo16"
 1275      6F31 36
 1276               		.local	status.2136
 1277               		.comm	status.2136,2,1
 1278               		.local	readbuffer.2135
 1279               		.comm	readbuffer.2135,256,1
 1280               		.local	ppu_buffer.2109
 1281               		.comm	ppu_buffer.2109,256,1
 1282               		.local	cpu_buffer.2108
 1283               		.comm	cpu_buffer.2108,256,1
 1284               		.section	.firmware.version,"a"
 1287               	date.2162:
 1288 0000 6B61 7A7A 		.string	"kazzo16 0.1.3 / Jan 26 2020"
 1288      6F31 3620 
 1288      302E 312E 
 1288      3320 2F20 
 1288      4A61 6E20 
 1289 001c 0000 0000 		.zero	4
 1290               		.local	request_ppu_program
 1291               		.comm	request_ppu_program,7,1
 1292               		.local	request_cpu_program
 1293               		.comm	request_cpu_program,7,1
 1294               		.local	request_both_write
 1295               		.comm	request_both_write,7,1
 1296               		.comm	BOOTLOADER_ASSIGN,34,1
 1297               		.text
 1298               	.Letext0:
 1299               		.file 4 "/usr/avr/include/stdint.h"
 1300               		.file 5 "./kazzo_request.h"
 1301               		.file 6 "./usbdrv/usbdrv.h"
 1302               		.file 7 "disk_access.h"
 1303               		.file 8 "mcu_program.h"
 1304               		.file 9 "bus_access.h"
 1305               		.file 10 "flashmemory.h"
 1306               		.file 11 "/usr/avr/include/avr/pgmspace.h"
 1307               		.file 12 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 avr_main.c
     /tmp/cc3KQkge.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc3KQkge.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc3KQkge.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc3KQkge.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc3KQkge.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc3KQkge.s:12     .text:0000000000000000 usbFunctionWrite
     /tmp/cc3KQkge.s:1293   .bss:0000000000000310 request_both_write
     /tmp/cc3KQkge.s:1291   .bss:0000000000000309 request_cpu_program
     /tmp/cc3KQkge.s:1283   .bss:0000000000000302 request_ppu_program
     /tmp/cc3KQkge.s:1281   .bss:0000000000000202 cpu_buffer.2108
     /tmp/cc3KQkge.s:1279   .bss:0000000000000102 ppu_buffer.2109
     /tmp/cc3KQkge.s:392    .text:00000000000001d6 usbFunctionSetup
     /tmp/cc3KQkge.s:1277   .bss:0000000000000002 readbuffer.2135
     /tmp/cc3KQkge.s:1274   .rodata:0000000000000000 signature.2168
                            *COM*:0000000000000022 BOOTLOADER_ASSIGN
                             .bss:0000000000000000 status.2136
     /tmp/cc3KQkge.s:1287   .firmware.version:0000000000000000 date.2162
     /tmp/cc3KQkge.s:1116   .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
cpu_write_flash
cpu_write_6502
ppu_write
memcpy
flash_cpu_program
flash_ppu_program
flash_cpu_config
flash_ppu_config
__tablejump2__
cpu_read
memcpy_P
vram_connection_get
usbMsgPtr
disk_init
ppu_read
flash_cpu_status
flash_ppu_status
flash_ppu_erase
flash_ppu_device_get
cpu_read_6502
flash_both_idle
phi2_init
flash_cpu_device_get
flash_cpu_erase
bus_init
usbInit
usbPoll
flash_process
__do_copy_data
__do_clear_bss
