   1               		.file	"mcu_program.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.bootloader.programmer,"ax",@progbits
  12               	mcu_data_program:
  13               	.LVL0:
  14               	.LFB12:
  15               		.file 1 "mcu_program.c"
   1:mcu_program.c **** #include <stdint.h>
   2:mcu_program.c **** #include <avr/boot.h>
   3:mcu_program.c **** #include <avr/interrupt.h>
   4:mcu_program.c **** #include <avr/pgmspace.h> 
   5:mcu_program.c **** #include <avr/wdt.h>
   6:mcu_program.c **** #include "kazzo_request.h"
   7:mcu_program.c **** #include "bus_access.h"
   8:mcu_program.c **** #include "mcu_program.h"
   9:mcu_program.c **** 
  10:mcu_program.c **** #if SPM_PAGESIZE > READ_PACKET_SIZE 
  11:mcu_program.c ****  #error READ_PACKET_SIZE is few capacity
  12:mcu_program.c **** #endif
  13:mcu_program.c **** /*
  14:mcu_program.c **** firmware bootloader sequence
  15:mcu_program.c **** - User insert a cartrige which has charcter RAM and CPU work RAM.
  16:mcu_program.c **** - Host send new firmware image with REQUEST_PPU_WRITE and REQUEST_CPU_WRITE_6502.
  17:mcu_program.c **** - Host receive and compare translated memory image.
  18:mcu_program.c **** - Firmware reprogram by REQUEST_FIRMWARE_PROGRAM.
  19:mcu_program.c **** 
  20:mcu_program.c **** MEGA164P-20[AP]U
  21:mcu_program.c **** ISP programming -> REQUEST_FIRMWARE_PROGRAM -> flash memory is programmed 2 pages only...
  22:mcu_program.c **** ISP programming -> power off->on -> REQUEST_FIRMWARE_PROGRAM -> flash memory is programmed all page
  23:mcu_program.c **** */
  24:mcu_program.c **** //inline function is not needed section defination.
  25:mcu_program.c **** //memcmp and memset are linked exteneded program area where cannot use when bootloader running.
  26:mcu_program.c **** enum{
  27:mcu_program.c **** 	fillsize = 0x10
  28:mcu_program.c **** };
  29:mcu_program.c **** static inline int my_memcmp(const uint8_t *firm, const uint8_t fill)
  30:mcu_program.c **** {
  31:mcu_program.c **** #define CMP1(offset) if(firm[offset] != fill){return 1;}
  32:mcu_program.c **** #define CMP4(i) CMP1(i+0) CMP1(i+1) CMP1(i+2) CMP1(i+3)
  33:mcu_program.c **** 	CMP4(0) CMP4(4) CMP4(8) CMP4(12)
  34:mcu_program.c **** 	return 0;
  35:mcu_program.c **** #undef CMP4
  36:mcu_program.c **** #undef CMP1
  37:mcu_program.c **** }
  38:mcu_program.c **** static inline int fillcmp(const uint8_t *firm, const uint8_t fill)
  39:mcu_program.c **** {
  40:mcu_program.c **** 	int i;
  41:mcu_program.c **** 	for(i = 0; i < SPM_PAGESIZE; i += fillsize){
  42:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
  43:mcu_program.c **** 			return 1;
  44:mcu_program.c **** 		}
  45:mcu_program.c **** 		firm += fillsize;
  46:mcu_program.c **** 	}
  47:mcu_program.c **** 	return 0;
  48:mcu_program.c **** }
  49:mcu_program.c **** __attribute__((noreturn))
  50:mcu_program.c **** __attribute__ ((section(".bootloader.programmer")))
  51:mcu_program.c **** static void mcu_data_program(uint8_t *buf, uint16_t address, uint16_t length)
  52:mcu_program.c **** {
  16               		.loc 1 52 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               		.loc 1 52 1 is_stmt 0 view .LVU1
  23 0000 8C01      		movw r16,r24
  24 0002 5B01      		movw r10,r22
  25 0004 CA01      		movw r24,r20
  26               	.LVL1:
  53:mcu_program.c **** 	uint16_t offset = 0;
  27               		.loc 1 53 2 is_stmt 1 view .LVU2
  54:mcu_program.c **** 	int page;
  28               		.loc 1 54 2 view .LVU3
  55:mcu_program.c **** 	cli();
  29               		.loc 1 55 2 view .LVU4
  30               	/* #APP */
  31               	 ;  55 "mcu_program.c" 1
  32 0006 F894      		cli
  33               	 ;  0 "" 2
  56:mcu_program.c **** 	wdt_disable();
  34               		.loc 1 56 2 view .LVU5
  35               	/* #NOAPP */
  36               	.LBB29:
  37               	.LBI29:
  38               		.file 2 "/usr/avr/include/avr/wdt.h"
   1:/usr/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/avr/include/avr/wdt.h **** 
   5:/usr/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/avr/wdt.h **** 
   8:/usr/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/avr/wdt.h **** 
  11:/usr/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/avr/wdt.h ****      distribution.
  15:/usr/avr/include/avr/wdt.h **** 
  16:/usr/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/avr/wdt.h **** 
  20:/usr/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/avr/wdt.h **** 
  32:/usr/avr/include/avr/wdt.h **** /* $Id: wdt.h 2503 2016-02-07 22:59:47Z joerg_wunsch $ */
  33:/usr/avr/include/avr/wdt.h **** 
  34:/usr/avr/include/avr/wdt.h **** /*
  35:/usr/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/avr/include/avr/wdt.h ****  */
  37:/usr/avr/include/avr/wdt.h **** 
  38:/usr/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/avr/include/avr/wdt.h **** 
  41:/usr/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/avr/include/avr/wdt.h **** 
  44:/usr/avr/include/avr/wdt.h **** /** \file */
  45:/usr/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/avr/include/avr/wdt.h **** 
  48:/usr/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/avr/include/avr/wdt.h **** 
  57:/usr/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/avr/include/avr/wdt.h **** 
  61:/usr/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/avr/include/avr/wdt.h ****     the following:
  68:/usr/avr/include/avr/wdt.h **** 
  69:/usr/avr/include/avr/wdt.h ****     \code
  70:/usr/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/avr/include/avr/wdt.h **** 
  73:/usr/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/avr/include/avr/wdt.h **** 
  75:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/avr/include/avr/wdt.h ****     {
  80:/usr/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/avr/include/avr/wdt.h ****     }
  84:/usr/avr/include/avr/wdt.h ****     \endcode
  85:/usr/avr/include/avr/wdt.h **** 
  86:/usr/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/avr/include/avr/wdt.h **** */
  91:/usr/avr/include/avr/wdt.h **** 
  92:/usr/avr/include/avr/wdt.h **** /**
  93:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/avr/include/avr/wdt.h **** */
  98:/usr/avr/include/avr/wdt.h **** 
  99:/usr/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/avr/include/avr/wdt.h **** 
 101:/usr/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/avr/include/avr/wdt.h **** 
 103:/usr/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/avr/include/avr/wdt.h **** #else
 106:/usr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/avr/include/avr/wdt.h **** #endif
 108:/usr/avr/include/avr/wdt.h **** 
 109:/usr/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/avr/include/avr/wdt.h **** #else
 114:/usr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/avr/include/avr/wdt.h **** #endif
 116:/usr/avr/include/avr/wdt.h **** 
 117:/usr/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/avr/include/avr/wdt.h **** #else
 120:/usr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/avr/include/avr/wdt.h **** #endif
 122:/usr/avr/include/avr/wdt.h **** 
 123:/usr/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/avr/include/avr/wdt.h **** 
 125:/usr/avr/include/avr/wdt.h **** 
 126:/usr/avr/include/avr/wdt.h **** /**
 127:/usr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/avr/include/avr/wdt.h **** 
 134:/usr/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/avr/include/avr/wdt.h **** */
 136:/usr/avr/include/avr/wdt.h **** 
 137:/usr/avr/include/avr/wdt.h **** 
 138:/usr/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/avr/include/avr/wdt.h **** 
 140:/usr/avr/include/avr/wdt.h **** /*
 141:/usr/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 142:/usr/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 143:/usr/avr/include/avr/wdt.h ****    registers to the CCP register
 144:/usr/avr/include/avr/wdt.h **** ** At the same time,
 145:/usr/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 146:/usr/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 147:/usr/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 148:/usr/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 149:/usr/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 150:/usr/avr/include/avr/wdt.h ****    sync is finished).
 151:/usr/avr/include/avr/wdt.h **** */
 152:/usr/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 153:/usr/avr/include/avr/wdt.h **** do { \
 154:/usr/avr/include/avr/wdt.h **** uint8_t temp; \
 155:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 156:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 157:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 158:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 159:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 160:/usr/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 161:/usr/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 162:/usr/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 163:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 164:/usr/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 165:/usr/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 166:/usr/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 167:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 168:/usr/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 169:/usr/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 170:/usr/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 171:/usr/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 172:/usr/avr/include/avr/wdt.h ****     : "r0" \
 173:/usr/avr/include/avr/wdt.h **** ); \
 174:/usr/avr/include/avr/wdt.h **** } while(0)
 175:/usr/avr/include/avr/wdt.h **** 
 176:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 177:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 178:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 179:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 180:/usr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 181:/usr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 182:/usr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 183:/usr/avr/include/avr/wdt.h ****     : \
 184:/usr/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 185:/usr/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 186:/usr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 187:/usr/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 188:/usr/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 189:/usr/avr/include/avr/wdt.h ****     : "r0" \
 190:/usr/avr/include/avr/wdt.h **** );
 191:/usr/avr/include/avr/wdt.h **** 
 192:/usr/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 193:/usr/avr/include/avr/wdt.h **** 
 194:/usr/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 195:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 196:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 197:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 198:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 199:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 200:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 201:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 202:/usr/avr/include/avr/wdt.h ****     : /* no outputs */  \
 203:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 204:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 205:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 206:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 207:/usr/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 208:/usr/avr/include/avr/wdt.h ****     : "r16" \
 209:/usr/avr/include/avr/wdt.h **** )
 210:/usr/avr/include/avr/wdt.h **** 
 211:/usr/avr/include/avr/wdt.h **** #define wdt_disable() \
 212:/usr/avr/include/avr/wdt.h **** do { \
 213:/usr/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 214:/usr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 215:/usr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 216:/usr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 217:/usr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 218:/usr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 219:/usr/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 220:/usr/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 221:/usr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 222:/usr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 223:/usr/avr/include/avr/wdt.h ****     : /*no output */ \
 224:/usr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 225:/usr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 226:/usr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 227:/usr/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 228:/usr/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 229:/usr/avr/include/avr/wdt.h ****     : "r16" \
 230:/usr/avr/include/avr/wdt.h **** ); \
 231:/usr/avr/include/avr/wdt.h **** }while(0)
 232:/usr/avr/include/avr/wdt.h **** 
 233:/usr/avr/include/avr/wdt.h **** #elif defined(CCP)
 234:/usr/avr/include/avr/wdt.h **** 
 235:/usr/avr/include/avr/wdt.h **** static __inline__
 236:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 237:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 238:/usr/avr/include/avr/wdt.h **** {
 239:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 240:/usr/avr/include/avr/wdt.h **** 	{
 241:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 242:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 243:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 244:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 245:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 246:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 247:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 248:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 249:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 250:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 251:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 252:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 253:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 254:/usr/avr/include/avr/wdt.h **** 			: "r0"
 255:/usr/avr/include/avr/wdt.h **** 			);
 256:/usr/avr/include/avr/wdt.h **** 	}
 257:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 258:/usr/avr/include/avr/wdt.h **** 	{
 259:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 260:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 261:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 262:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 263:/usr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 264:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 265:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 266:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 267:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 268:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 269:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 270:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 271:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 272:/usr/avr/include/avr/wdt.h **** 			: "r0"
 273:/usr/avr/include/avr/wdt.h **** 			);
 274:/usr/avr/include/avr/wdt.h **** 	}
 275:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 276:/usr/avr/include/avr/wdt.h **** 	{
 277:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 278:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 279:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 280:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 281:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 282:/usr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 283:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 284:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 285:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 286:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 287:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 288:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 289:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 290:/usr/avr/include/avr/wdt.h **** 			: "r0"
 291:/usr/avr/include/avr/wdt.h **** 			);
 292:/usr/avr/include/avr/wdt.h **** 	}
 293:/usr/avr/include/avr/wdt.h **** 	else
 294:/usr/avr/include/avr/wdt.h ****  	{
 295:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 296:/usr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 297:/usr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 298:/usr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 299:/usr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 300:/usr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 301:/usr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 302:/usr/avr/include/avr/wdt.h **** 			: /* no outputs */
 303:/usr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 304:/usr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 305:/usr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 306:/usr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 307:/usr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 308:/usr/avr/include/avr/wdt.h **** 			: "r0"
 309:/usr/avr/include/avr/wdt.h **** 			);
 310:/usr/avr/include/avr/wdt.h **** 	}
 311:/usr/avr/include/avr/wdt.h **** }
 312:/usr/avr/include/avr/wdt.h **** 
 313:/usr/avr/include/avr/wdt.h **** static __inline__
 314:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 315:/usr/avr/include/avr/wdt.h **** void wdt_disable (void)
 316:/usr/avr/include/avr/wdt.h **** {
 317:/usr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 318:/usr/avr/include/avr/wdt.h **** 	{
 319:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 320:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 321:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 322:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 323:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 324:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 325:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 326:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 327:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 328:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 330:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 331:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 334:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 335:/usr/avr/include/avr/wdt.h **** 				: "r0"
 336:/usr/avr/include/avr/wdt.h **** 				);
 337:/usr/avr/include/avr/wdt.h **** 	}
 338:/usr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 339:/usr/avr/include/avr/wdt.h **** 	{
 340:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 341:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 342:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 343:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 344:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 345:/usr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 346:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 347:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 348:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 349:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 350:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 351:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 352:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 353:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 354:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 355:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 356:/usr/avr/include/avr/wdt.h **** 				: "r0"
 357:/usr/avr/include/avr/wdt.h **** 				);
 358:/usr/avr/include/avr/wdt.h **** 	}
 359:/usr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:/usr/avr/include/avr/wdt.h **** 	{
 361:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 362:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 363:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 365:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 366:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:/usr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:/usr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 372:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 373:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:/usr/avr/include/avr/wdt.h **** 				: "r0"
 378:/usr/avr/include/avr/wdt.h **** 				);
 379:/usr/avr/include/avr/wdt.h **** 	}
 380:/usr/avr/include/avr/wdt.h **** 	else
 381:/usr/avr/include/avr/wdt.h **** 	{
 382:/usr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 383:/usr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 384:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 386:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 387:/usr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:/usr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:/usr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:/usr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:/usr/avr/include/avr/wdt.h **** 				: /*no output */
 393:/usr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 394:/usr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:/usr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:/usr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:/usr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:/usr/avr/include/avr/wdt.h **** 				: "r0"
 399:/usr/avr/include/avr/wdt.h **** 				);
 400:/usr/avr/include/avr/wdt.h **** 	}
 401:/usr/avr/include/avr/wdt.h **** }
 402:/usr/avr/include/avr/wdt.h **** 
 403:/usr/avr/include/avr/wdt.h **** #else
 404:/usr/avr/include/avr/wdt.h **** 
 405:/usr/avr/include/avr/wdt.h **** static __inline__
 406:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 407:/usr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 408:/usr/avr/include/avr/wdt.h **** {
 409:/usr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 410:/usr/avr/include/avr/wdt.h **** 	{
 411:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 412:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 413:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 414:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 415:/usr/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 416:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 417:/usr/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 418:/usr/avr/include/avr/wdt.h **** 				: /* no outputs */
 419:/usr/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 420:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 421:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 422:/usr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 423:/usr/avr/include/avr/wdt.h **** 				: "r0"
 424:/usr/avr/include/avr/wdt.h **** 		);
 425:/usr/avr/include/avr/wdt.h **** 	}
 426:/usr/avr/include/avr/wdt.h **** 	else
 427:/usr/avr/include/avr/wdt.h **** 	{
 428:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 429:/usr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 433:/usr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 434:/usr/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 435:/usr/avr/include/avr/wdt.h **** 				: /* no outputs */
 436:/usr/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 437:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 438:/usr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 439:/usr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 440:/usr/avr/include/avr/wdt.h **** 				: "r0"
 441:/usr/avr/include/avr/wdt.h **** 		);
 442:/usr/avr/include/avr/wdt.h **** 	}
 443:/usr/avr/include/avr/wdt.h **** }
 444:/usr/avr/include/avr/wdt.h **** 
 445:/usr/avr/include/avr/wdt.h **** static __inline__
 446:/usr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 447:/usr/avr/include/avr/wdt.h **** void wdt_disable (void)
  39               		.loc 2 447 6 view .LVU6
  40               	.LBB30:
 448:/usr/avr/include/avr/wdt.h **** {
 449:/usr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
  41               		.loc 2 449 2 view .LVU7
  42               	.LBB31:
 450:/usr/avr/include/avr/wdt.h **** 	{
 451:/usr/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
  43               		.loc 2 451 9 view .LVU8
 452:/usr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
  44               		.loc 2 452 3 view .LVU9
  45               	/* #APP */
  46               	 ;  452 "/usr/avr/include/avr/wdt.h" 1
  47 0008 0FB6      		in __tmp_reg__,__SREG__
  48 000a F894      		cli
  49 000c A895      		wdr
  50 000e 21B5      		in  r18,33
  51 0010 2861      		ori r18,24
  52 0012 21BD      		out 33,r18
  53 0014 11BC      		out 33,__zero_reg__
  54 0016 0FBE      		out __SREG__,__tmp_reg__
  55               		
  56               	 ;  0 "" 2
  57               	.LVL2:
  58               	/* #NOAPP */
  59               	.L2:
  60               		.loc 2 452 3 is_stmt 0 view .LVU10
  61               	.LBE31:
  62               	.LBE30:
  63               	.LBE29:
  57:mcu_program.c **** 
  58:mcu_program.c **** 	eeprom_busy_wait();
  64               		.loc 1 58 2 is_stmt 1 discriminator 1 view .LVU11
  65               		.loc 1 58 2 discriminator 1 view .LVU12
  66               		.loc 1 58 2 discriminator 1 view .LVU13
  67 0018 E199      		sbic 0x1c,1
  68 001a 00C0      		rjmp .L2
  69               	.LVL3:
  59:mcu_program.c **** 	for(page = 0; page < length / SPM_PAGESIZE; page++){
  70               		.loc 1 59 16 view .LVU14
  71               		.loc 1 59 30 is_stmt 0 view .LVU15
  72 001c 880F      		lsl r24
  73 001e 892F      		mov r24,r25
  74 0020 881F      		rol r24
  75 0022 990B      		sbc r25,r25
  76 0024 9195      		neg r25
  77               		.loc 1 59 2 view .LVU16
  78 0026 0097      		sbiw r24,0
  79 0028 01F4      		brne .+2
  80 002a 00C0      		rjmp .L3
  81 002c EC01      		movw r28,r24
  82 002e D695      		lsr r29
  83 0030 DC2F      		mov r29,r28
  84 0032 CC27      		clr r28
  85 0034 D795      		ror r29
  86 0036 C795      		ror r28
  53:mcu_program.c **** 	int page;
  87               		.loc 1 53 11 view .LVU17
  88 0038 D12C      		mov r13,__zero_reg__
  89 003a C12C      		mov r12,__zero_reg__
  90 003c C801      		movw r24,r16
  91 003e 8058      		subi r24,-128
  92 0040 9F4F      		sbci r25,-1
  93 0042 7C01      		movw r14,r24
  94               	.LBB32:
  60:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
  61:mcu_program.c **** 		if((fillcmp(buf, 0) != 0) || (fillcmp(buf, 0xff) != 0)){
  62:mcu_program.c **** 			boot_page_erase(address);
  95               		.loc 1 62 4 view .LVU18
  96 0044 93E0      		ldi r25,lo8(3)
  97 0046 592E      		mov r5,r25
  98               	.LBB33:
  63:mcu_program.c **** 			boot_spm_busy_wait();
  64:mcu_program.c **** 			int i;
  65:mcu_program.c **** 			for(i = 0; i < SPM_PAGESIZE; i += 2){
  66:mcu_program.c **** 				//Set up little-endian word
  67:mcu_program.c **** 				uint16_t w = buf[i+0];
  68:mcu_program.c **** 				w |= buf[i+1] << 8;
  69:mcu_program.c **** 				boot_page_fill(i, w);
  99               		.loc 1 69 5 view .LVU19
 100 0048 7724      		clr r7
 101 004a 7394      		inc r7
 102               	.LBE33:
  70:mcu_program.c **** 			}
  71:mcu_program.c **** 			boot_page_write(address);
 103               		.loc 1 71 4 view .LVU20
 104 004c 25E0      		ldi r18,lo8(5)
 105 004e 622E      		mov r6,r18
 106               	.LVL4:
 107               	.L11:
 108               		.loc 1 71 4 view .LVU21
 109 0050 4501      		movw r8,r10
 110 0052 8C0C      		add r8,r12
 111 0054 9D1C      		adc r9,r13
 112               	.LVL5:
 113               		.loc 1 71 4 view .LVU22
 114               	.LBE32:
  60:mcu_program.c **** 		if((fillcmp(buf, 0) != 0) || (fillcmp(buf, 0xff) != 0)){
 115               		.loc 1 60 3 is_stmt 1 view .LVU23
 116 0056 A801      		movw r20,r16
 117 0058 60E8      		ldi r22,lo8(-128)
 118 005a 70E0      		ldi r23,0
 119 005c C601      		movw r24,r12
 120 005e 0E94 0000 		call mcu_programdata_read
 121               	.LVL6:
  61:mcu_program.c **** 			boot_page_erase(address);
 122               		.loc 1 61 3 view .LVU24
 123               	.LBB35:
 124               	.LBI35:
  38:mcu_program.c **** {
 125               		.loc 1 38 19 view .LVU25
 126               	.LBB36:
  40:mcu_program.c **** 	for(i = 0; i < SPM_PAGESIZE; i += fillsize){
 127               		.loc 1 40 2 view .LVU26
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 128               		.loc 1 41 2 view .LVU27
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 129               		.loc 1 41 13 view .LVU28
 130               	.LBE36:
 131               	.LBE35:
  60:mcu_program.c **** 		if((fillcmp(buf, 0) != 0) || (fillcmp(buf, 0xff) != 0)){
 132               		.loc 1 60 3 is_stmt 0 view .LVU29
 133 0062 F801      		movw r30,r16
 134               	.LVL7:
 135               	.L5:
 136               	.LBB43:
 137               	.LBB41:
  42:mcu_program.c **** 			return 1;
 138               		.loc 1 42 3 is_stmt 1 view .LVU30
 139               	.LBB37:
 140               	.LBI37:
  29:mcu_program.c **** {
 141               		.loc 1 29 19 view .LVU31
 142               	.LBB38:
  33:mcu_program.c **** 	return 0;
 143               		.loc 1 33 2 view .LVU32
 144 0064 8081      		ld r24,Z
 145 0066 8823      		tst r24
 146 0068 01F0      		breq .L23
 147               	.LVL8:
 148               	.L4:
  33:mcu_program.c **** 	return 0;
 149               		.loc 1 33 2 is_stmt 0 view .LVU33
 150               	.LBE38:
 151               	.LBE37:
 152               	.LBE41:
 153               	.LBE43:
 154               	.LBB44:
  62:mcu_program.c **** 			boot_spm_busy_wait();
 155               		.loc 1 62 4 is_stmt 1 view .LVU34
 156 006a F401      		movw r30,r8
 157               	/* #APP */
 158               	 ;  62 "mcu_program.c" 1
 159 006c 5092 5700 		sts 87, r5
 160 0070 E895      		spm
 161               		
 162               	 ;  0 "" 2
 163               	/* #NOAPP */
 164               	.L8:
  63:mcu_program.c **** 			int i;
 165               		.loc 1 63 4 discriminator 1 view .LVU35
  63:mcu_program.c **** 			int i;
 166               		.loc 1 63 4 discriminator 1 view .LVU36
  63:mcu_program.c **** 			int i;
 167               		.loc 1 63 4 discriminator 1 view .LVU37
 168 0072 07B6      		in __tmp_reg__,0x37
 169 0074 00FC      		sbrc __tmp_reg__,0
 170 0076 00C0      		rjmp .L8
 171 0078 D801      		movw r26,r16
  65:mcu_program.c **** 				//Set up little-endian word
 172               		.loc 1 65 10 is_stmt 0 view .LVU38
 173 007a F0E0      		ldi r31,0
 174 007c E0E0      		ldi r30,0
 175               	.L9:
 176               	.LVL9:
 177               	.LBB34:
  67:mcu_program.c **** 				w |= buf[i+1] << 8;
 178               		.loc 1 67 5 is_stmt 1 discriminator 3 view .LVU39
  67:mcu_program.c **** 				w |= buf[i+1] << 8;
 179               		.loc 1 67 14 is_stmt 0 discriminator 3 view .LVU40
 180 007e 8C91      		ld r24,X
 181               	.LVL10:
  68:mcu_program.c **** 				boot_page_fill(i, w);
 182               		.loc 1 68 5 is_stmt 1 discriminator 3 view .LVU41
  69:mcu_program.c **** 			}
 183               		.loc 1 69 5 discriminator 3 view .LVU42
  68:mcu_program.c **** 				boot_page_fill(i, w);
 184               		.loc 1 68 13 is_stmt 0 discriminator 3 view .LVU43
 185 0080 1196      		adiw r26,1
 186 0082 9C91      		ld r25,X
 187 0084 1197      		sbiw r26,1
  69:mcu_program.c **** 			}
 188               		.loc 1 69 5 discriminator 3 view .LVU44
 189               	/* #APP */
 190               	 ;  69 "mcu_program.c" 1
 191 0086 0C01      		movw  r0, r24
 192 0088 7092 5700 		sts 87, r7
 193 008c E895      		spm
 194 008e 1124      		clr  r1
 195               		
 196               	 ;  0 "" 2
 197               	/* #NOAPP */
 198               	.LBE34:
  65:mcu_program.c **** 				//Set up little-endian word
 199               		.loc 1 65 33 is_stmt 1 discriminator 3 view .LVU45
  65:mcu_program.c **** 				//Set up little-endian word
 200               		.loc 1 65 35 is_stmt 0 discriminator 3 view .LVU46
 201 0090 3296      		adiw r30,2
 202               	.LVL11:
  65:mcu_program.c **** 				//Set up little-endian word
 203               		.loc 1 65 15 is_stmt 1 discriminator 3 view .LVU47
 204 0092 1296      		adiw r26,2
 205               	.LVL12:
  65:mcu_program.c **** 				//Set up little-endian word
 206               		.loc 1 65 4 is_stmt 0 discriminator 3 view .LVU48
 207 0094 E038      		cpi r30,-128
 208 0096 F105      		cpc r31,__zero_reg__
 209 0098 01F4      		brne .L9
 210               		.loc 1 71 4 is_stmt 1 view .LVU49
 211 009a F401      		movw r30,r8
 212               	.LVL13:
 213               		.loc 1 71 4 is_stmt 0 view .LVU50
 214               	/* #APP */
 215               	 ;  71 "mcu_program.c" 1
 216 009c 6092 5700 		sts 87, r6
 217 00a0 E895      		spm
 218               		
 219               	 ;  0 "" 2
 220               	/* #NOAPP */
 221               	.L10:
  72:mcu_program.c **** 			boot_spm_busy_wait();
 222               		.loc 1 72 4 is_stmt 1 discriminator 1 view .LVU51
 223               		.loc 1 72 4 discriminator 1 view .LVU52
 224               		.loc 1 72 4 discriminator 1 view .LVU53
 225 00a2 07B6      		in __tmp_reg__,0x37
 226 00a4 00FC      		sbrc __tmp_reg__,0
 227 00a6 00C0      		rjmp .L10
 228               	.LBE44:
  73:mcu_program.c **** 		}
  74:mcu_program.c **** 		offset += SPM_PAGESIZE;
 229               		.loc 1 74 3 discriminator 2 view .LVU54
 230               		.loc 1 74 10 is_stmt 0 discriminator 2 view .LVU55
 231 00a8 F0E8      		ldi r31,-128
 232 00aa CF0E      		add r12,r31
 233 00ac D11C      		adc r13,__zero_reg__
 234               	.LVL14:
  75:mcu_program.c **** 		address += SPM_PAGESIZE;
 235               		.loc 1 75 3 is_stmt 1 discriminator 2 view .LVU56
  59:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
 236               		.loc 1 59 46 discriminator 2 view .LVU57
  59:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
 237               		.loc 1 59 16 discriminator 2 view .LVU58
  59:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
 238               		.loc 1 59 2 is_stmt 0 discriminator 2 view .LVU59
 239 00ae CC15      		cp r28,r12
 240 00b0 DD05      		cpc r29,r13
 241 00b2 01F4      		brne .L11
 242               	.LVL15:
 243               	.L3:
 244               	.L21:
  76:mcu_program.c **** 	}
  77:mcu_program.c **** 	if(0){ //force re-turn power on. keep watchdog disable
  78:mcu_program.c **** 		boot_rww_enable();
  79:mcu_program.c **** 		sei();
  80:mcu_program.c **** 		wdt_enable(WDTO_500MS);
  81:mcu_program.c **** 	}
  82:mcu_program.c **** endless: //wait watchdog interruptting reset
  83:mcu_program.c **** 	goto endless;
 245               		.loc 1 83 2 is_stmt 1 discriminator 1 view .LVU60
 246               		.loc 1 83 2 discriminator 1 view .LVU61
 247 00b4 00C0      		rjmp .L21
 248               	.LVL16:
 249               	.L23:
 250               	.LBB45:
 251               	.LBB42:
 252               	.LBB40:
 253               	.LBB39:
  33:mcu_program.c **** 	return 0;
 254               		.loc 1 33 2 view .LVU62
 255 00b6 8181      		ldd r24,Z+1
 256 00b8 8111      		cpse r24,__zero_reg__
 257 00ba 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 258               		.loc 1 33 2 view .LVU63
 259 00bc 8281      		ldd r24,Z+2
 260 00be 8111      		cpse r24,__zero_reg__
 261 00c0 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 262               		.loc 1 33 2 view .LVU64
 263 00c2 8381      		ldd r24,Z+3
 264 00c4 8111      		cpse r24,__zero_reg__
 265 00c6 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 266               		.loc 1 33 10 view .LVU65
 267 00c8 8481      		ldd r24,Z+4
 268 00ca 8111      		cpse r24,__zero_reg__
 269 00cc 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 270               		.loc 1 33 10 view .LVU66
 271 00ce 8581      		ldd r24,Z+5
 272 00d0 8111      		cpse r24,__zero_reg__
 273 00d2 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 274               		.loc 1 33 10 view .LVU67
 275 00d4 8681      		ldd r24,Z+6
 276 00d6 8111      		cpse r24,__zero_reg__
 277 00d8 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 278               		.loc 1 33 10 view .LVU68
 279 00da 8781      		ldd r24,Z+7
 280 00dc 8111      		cpse r24,__zero_reg__
 281 00de 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 282               		.loc 1 33 18 view .LVU69
 283 00e0 8085      		ldd r24,Z+8
 284 00e2 8111      		cpse r24,__zero_reg__
 285 00e4 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 286               		.loc 1 33 18 view .LVU70
 287 00e6 8185      		ldd r24,Z+9
 288 00e8 8111      		cpse r24,__zero_reg__
 289 00ea 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 290               		.loc 1 33 18 view .LVU71
 291 00ec 8285      		ldd r24,Z+10
 292 00ee 8111      		cpse r24,__zero_reg__
 293 00f0 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 294               		.loc 1 33 18 view .LVU72
 295 00f2 8385      		ldd r24,Z+11
 296 00f4 8111      		cpse r24,__zero_reg__
 297 00f6 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 298               		.loc 1 33 26 view .LVU73
 299 00f8 8485      		ldd r24,Z+12
 300 00fa 8111      		cpse r24,__zero_reg__
 301 00fc 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 302               		.loc 1 33 26 view .LVU74
 303 00fe 8585      		ldd r24,Z+13
 304 0100 8111      		cpse r24,__zero_reg__
 305 0102 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 306               		.loc 1 33 26 view .LVU75
 307 0104 8685      		ldd r24,Z+14
 308 0106 8111      		cpse r24,__zero_reg__
 309 0108 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 310               		.loc 1 33 26 view .LVU76
 311 010a 8785      		ldd r24,Z+15
 312 010c 8111      		cpse r24,__zero_reg__
 313 010e 00C0      		rjmp .L4
 314               	.LVL17:
  33:mcu_program.c **** 	return 0;
 315               		.loc 1 33 26 is_stmt 0 view .LVU77
 316               	.LBE39:
 317               	.LBE40:
  45:mcu_program.c **** 	}
 318               		.loc 1 45 3 is_stmt 1 view .LVU78
  45:mcu_program.c **** 	}
 319               		.loc 1 45 8 is_stmt 0 view .LVU79
 320 0110 7096      		adiw r30,16
 321               	.LVL18:
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 322               		.loc 1 41 31 is_stmt 1 view .LVU80
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 323               		.loc 1 41 13 view .LVU81
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 324               		.loc 1 41 2 is_stmt 0 view .LVU82
 325 0112 EE16      		cp r14,r30
 326 0114 FF06      		cpc r15,r31
 327 0116 01F0      		breq .+2
 328 0118 00C0      		rjmp .L5
 329 011a F801      		movw r30,r16
 330               	.LVL19:
 331               	.L6:
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 332               		.loc 1 41 2 view .LVU83
 333               	.LBE42:
 334               	.LBE45:
 335               	.LBB46:
 336               	.LBB47:
  42:mcu_program.c **** 			return 1;
 337               		.loc 1 42 3 is_stmt 1 view .LVU84
 338               	.LBB48:
 339               	.LBI48:
  29:mcu_program.c **** {
 340               		.loc 1 29 19 view .LVU85
 341               	.LBB49:
  33:mcu_program.c **** 	return 0;
 342               		.loc 1 33 2 view .LVU86
 343 011c 8081      		ld r24,Z
 344 011e 8F3F      		cpi r24,lo8(-1)
 345 0120 01F0      		breq .+2
 346 0122 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 347               		.loc 1 33 2 view .LVU87
 348 0124 8181      		ldd r24,Z+1
 349 0126 8F3F      		cpi r24,lo8(-1)
 350 0128 01F0      		breq .+2
 351 012a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 352               		.loc 1 33 2 view .LVU88
 353 012c 8281      		ldd r24,Z+2
 354 012e 8F3F      		cpi r24,lo8(-1)
 355 0130 01F0      		breq .+2
 356 0132 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 357               		.loc 1 33 2 view .LVU89
 358 0134 8381      		ldd r24,Z+3
 359 0136 8F3F      		cpi r24,lo8(-1)
 360 0138 01F0      		breq .+2
 361 013a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 362               		.loc 1 33 10 view .LVU90
 363 013c 8481      		ldd r24,Z+4
 364 013e 8F3F      		cpi r24,lo8(-1)
 365 0140 01F0      		breq .+2
 366 0142 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 367               		.loc 1 33 10 view .LVU91
 368 0144 8581      		ldd r24,Z+5
 369 0146 8F3F      		cpi r24,lo8(-1)
 370 0148 01F0      		breq .+2
 371 014a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 372               		.loc 1 33 10 view .LVU92
 373 014c 8681      		ldd r24,Z+6
 374 014e 8F3F      		cpi r24,lo8(-1)
 375 0150 01F0      		breq .+2
 376 0152 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 377               		.loc 1 33 10 view .LVU93
 378 0154 8781      		ldd r24,Z+7
 379 0156 8F3F      		cpi r24,lo8(-1)
 380 0158 01F0      		breq .+2
 381 015a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 382               		.loc 1 33 18 view .LVU94
 383 015c 8085      		ldd r24,Z+8
 384 015e 8F3F      		cpi r24,lo8(-1)
 385 0160 01F0      		breq .+2
 386 0162 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 387               		.loc 1 33 18 view .LVU95
 388 0164 8185      		ldd r24,Z+9
 389 0166 8F3F      		cpi r24,lo8(-1)
 390 0168 01F0      		breq .+2
 391 016a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 392               		.loc 1 33 18 view .LVU96
 393 016c 8285      		ldd r24,Z+10
 394 016e 8F3F      		cpi r24,lo8(-1)
 395 0170 01F0      		breq .+2
 396 0172 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 397               		.loc 1 33 18 view .LVU97
 398 0174 8385      		ldd r24,Z+11
 399 0176 8F3F      		cpi r24,lo8(-1)
 400 0178 01F0      		breq .+2
 401 017a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 402               		.loc 1 33 26 view .LVU98
 403 017c 8485      		ldd r24,Z+12
 404 017e 8F3F      		cpi r24,lo8(-1)
 405 0180 01F0      		breq .+2
 406 0182 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 407               		.loc 1 33 26 view .LVU99
 408 0184 8585      		ldd r24,Z+13
 409 0186 8F3F      		cpi r24,lo8(-1)
 410 0188 01F0      		breq .+2
 411 018a 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 412               		.loc 1 33 26 view .LVU100
 413 018c 8685      		ldd r24,Z+14
 414 018e 8F3F      		cpi r24,lo8(-1)
 415 0190 01F0      		breq .+2
 416 0192 00C0      		rjmp .L4
  33:mcu_program.c **** 	return 0;
 417               		.loc 1 33 26 view .LVU101
 418 0194 8785      		ldd r24,Z+15
 419 0196 8F3F      		cpi r24,lo8(-1)
 420 0198 01F0      		breq .+2
 421 019a 00C0      		rjmp .L4
 422               	.LVL20:
  33:mcu_program.c **** 	return 0;
 423               		.loc 1 33 26 is_stmt 0 view .LVU102
 424               	.LBE49:
 425               	.LBE48:
  45:mcu_program.c **** 	}
 426               		.loc 1 45 3 is_stmt 1 view .LVU103
  45:mcu_program.c **** 	}
 427               		.loc 1 45 8 is_stmt 0 view .LVU104
 428 019c 7096      		adiw r30,16
 429               	.LVL21:
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 430               		.loc 1 41 31 is_stmt 1 view .LVU105
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 431               		.loc 1 41 13 view .LVU106
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 432               		.loc 1 41 2 is_stmt 0 view .LVU107
 433 019e EE16      		cp r14,r30
 434 01a0 FF06      		cpc r15,r31
 435 01a2 01F0      		breq .+2
 436 01a4 00C0      		rjmp .L6
 437               	.LVL22:
  41:mcu_program.c **** 		if(my_memcmp(firm, fill) != 0){
 438               		.loc 1 41 2 view .LVU108
 439               	.LBE47:
 440               	.LBE46:
  74:mcu_program.c **** 		address += SPM_PAGESIZE;
 441               		.loc 1 74 3 is_stmt 1 view .LVU109
  74:mcu_program.c **** 		address += SPM_PAGESIZE;
 442               		.loc 1 74 10 is_stmt 0 view .LVU110
 443 01a6 F0E8      		ldi r31,-128
 444 01a8 CF0E      		add r12,r31
 445 01aa D11C      		adc r13,__zero_reg__
 446               	.LVL23:
  75:mcu_program.c **** 	}
 447               		.loc 1 75 3 is_stmt 1 view .LVU111
  59:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
 448               		.loc 1 59 46 view .LVU112
  59:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
 449               		.loc 1 59 16 view .LVU113
  59:mcu_program.c **** 		mcu_programdata_read(offset, SPM_PAGESIZE, buf);
 450               		.loc 1 59 2 is_stmt 0 view .LVU114
 451 01ac CC15      		cp r28,r12
 452 01ae DD05      		cpc r29,r13
 453 01b0 01F0      		breq .+2
 454 01b2 00C0      		rjmp .L11
 455 01b4 00C0      		rjmp .L3
 456               		.cfi_endproc
 457               	.LFE12:
 459               	.global	BOOTLOADER_ASSIGN
 460               		.section	.bootloader.version,"a"
 463               	BOOTLOADER_ASSIGN:
 464 0000 6B61 7A7A 		.string	"kazzo loader 0.1.1"
 464      6F20 6C6F 
 464      6164 6572 
 464      2030 2E31 
 464      2E31 00
 465 0013 0000 0000 		.zero	13
 465      0000 0000 
 465      0000 0000 
 465      00
 466 0020 0000      		.word	gs(mcu_data_program)
 467               		.text
 468               	.Letext0:
 469               		.file 3 "/usr/avr/include/stdint.h"
 470               		.file 4 "mcu_program.h"
 471               		.file 5 "bus_access.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 mcu_program.c
     /tmp/cckOqJ5T.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cckOqJ5T.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cckOqJ5T.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cckOqJ5T.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cckOqJ5T.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cckOqJ5T.s:12     .bootloader.programmer:0000000000000000 mcu_data_program
     /tmp/cckOqJ5T.s:463    .bootloader.version:0000000000000000 BOOTLOADER_ASSIGN

UNDEFINED SYMBOLS
mcu_programdata_read
